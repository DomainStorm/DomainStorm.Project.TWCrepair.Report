{"version":3,"file":"p-BTxWl1MX.js","sources":["src/utils/utils.ts","src/utils/functional/functional.tsx"],"sourcesContent":["import clsx from 'clsx';\nimport equal from 'fast-deep-equal/es6';\nimport { encode as escapeHtml } from 'he';\nimport 'ses';\nimport type { ConditionGroupInterface, ConditionInterface, ListItemInterface } from './interface';\n\nexport { arrayMoveMutable as arrayMove } from 'array-move';\nexport { default as debounce } from 'lodash.debounce';\nexport { default as clone } from 'rfdc';\nexport { clsx, escapeHtml };\n\n/**\n * 格式化名稱，將名稱的不同部分組合成一個完整名稱字串。\n * 自動過濾空值，並以空格分隔各部分。\n *\n * @param first 名稱的第一部分（如果為空值，將會回傳空字串）\n * @param middle 名稱的中間部分（可選）\n * @param last 名稱的最後部分（可選）\n * @returns 組合後的名稱字串\n * @example\n * // 回傳 'John Doe'\n * formatName('John', undefined, 'Doe');\n *\n * // 回傳 'John Smith Doe'\n * formatName('John', 'Smith', 'Doe');\n */\nexport function format(first: string | null | undefined, middle?: string | null, last?: string | null): string {\n  const safeFirst = first || '';\n\n  if (!middle && !last) return safeFirst;\n\n  return [safeFirst, middle, last]\n    .filter(Boolean)\n    .join(' ');\n}\n\n/**\n * 產生唯一標識符（UID）\n *\n * 使用 crypto.randomUUID() 生成 UUID，並可選擇添加前綴和/或後綴。\n * 若前綴或後綴非空，則使用底線「_」連接。\n *\n * @param prefix 產生的 UID 前綴字串，預設為空字串\n * @param suffix 產生的 UID 後綴字串，預設為空字串\n * @returns 組合後的唯一標識符\n * @throws 若環境不支援 crypto.randomUUID() 時拋出錯誤\n *\n * @example\n * // 回傳: 'user_550e8400-e29b-41d4-a716-446655440000'\n * generateUid('user');\n *\n * @example\n * // 回傳: '550e8400-e29b-41d4-a716-446655440000_temp'\n * generateUid('', 'temp');\n */\nexport function generateUid(prefix = '', suffix = ''): string {\n  const uuid = crypto.randomUUID();\n\n  const parts: string[] = [];\n  if (prefix) parts.push(prefix);\n  parts.push(uuid);\n  if (suffix) parts.push(suffix);\n\n  return parts.join('_');\n}\n\n// 優化的欄位解析快取，限制大小以防止記憶體洩漏\nconst fieldParseCache = new Map<string, {\n  type: 'pipe' | 'ampersand' | 'dot' | 'simple';\n  parts?: string[];\n  firstField?: string;\n  subField?: string;\n}>();\n\nconst MAX_CACHE_SIZE = 500;\n\n/**\n * 從物件中取得指定欄位的值。\n *\n * @param obj 目標物件\n * @param field 欄位名稱或索引\n * @returns 欄位的值\n */\nexport function getFieldValue(obj: unknown, field: string | number): unknown {\n  if (obj == null) return obj;\n\n  if (typeof field === 'number') {\n    return Array.isArray(obj) ? obj[field] : undefined;\n  }\n\n  if (typeof field !== 'string') {\n    throw new Error('Field must be a string or a number');\n  }\n\n  const trimmedField = field.trim();\n  if (trimmedField === '') return undefined;\n\n  // 檢查快取\n  let parseInfo = fieldParseCache.get(trimmedField);\n  if (!parseInfo) {\n    parseInfo = parseFieldPath(trimmedField);\n\n    // 限制快取大小\n    if (fieldParseCache.size >= MAX_CACHE_SIZE) {\n      const firstKey = fieldParseCache.keys().next().value;\n      fieldParseCache.delete(firstKey);\n    }\n\n    fieldParseCache.set(trimmedField, parseInfo);\n  }\n\n  switch (parseInfo.type) {\n    case 'pipe':\n      return findFieldValue(obj, parseInfo.parts!);\n    case 'ampersand':\n      return mergeFieldValue(obj, parseInfo.parts!);\n    case 'dot': {\n      const firstValue = getFieldValue(obj, parseInfo.firstField!);\n      return getFieldValue(firstValue, parseInfo.subField!);\n    }\n    case 'simple':\n      if (Array.isArray(obj) && obj.length > 0 && typeof obj[0] === 'object') {\n        return obj.map(item => getFieldValue(item, trimmedField));\n      }\n      if (typeof obj === 'object' && obj !== null) {\n        return (obj as Record<string, unknown>)[trimmedField];\n      }\n  }\n  return undefined;\n}\n\n/**\n * 解析欄位路徑，返回解析信息\n */\nfunction parseFieldPath(field: string): {\n  type: 'pipe' | 'ampersand' | 'dot' | 'simple';\n  parts?: string[];\n  firstField?: string;\n  subField?: string;\n} {\n  const pipeIndex = field.indexOf('|');\n  const ampersandIndex = field.indexOf('&');\n  const dotIndex = field.indexOf('.');\n\n  if (pipeIndex !== -1) {\n    return { type: 'pipe', parts: field.split('|') };\n  }\n\n  if (ampersandIndex !== -1) {\n    return { type: 'ampersand', parts: field.split('&') };\n  }\n\n  if (dotIndex !== -1) {\n    return {\n      type: 'dot',\n      firstField: field.substring(0, dotIndex),\n      subField: field.substring(dotIndex + 1)\n    };\n  }\n\n  return { type: 'simple' };\n}\n\n/**\n * 設定物件中指定欄位的值。\n *\n * @param obj 要設定值的物件\n * @param field 欄位名稱或索引\n * @param value 要設定的值\n */\nexport function setFieldValue(obj: unknown, field: string | number, value: unknown): void {\n  if (obj == null) {\n    return;\n  }\n\n  if (typeof field === 'number') {\n    if (Array.isArray(obj)) {\n      obj[field] = value;\n    }\n    return;\n  }\n\n  if (typeof field !== 'string') {\n    throw new Error('Field must be a string or a number');\n  }\n\n  const trimmedField = field.trim();\n  if (trimmedField === '') return;\n\n  let parseInfo = fieldParseCache.get(trimmedField);\n  if (!parseInfo) {\n    parseInfo = parseFieldPath(trimmedField);\n\n    if (fieldParseCache.size >= MAX_CACHE_SIZE) {\n      const firstKey = fieldParseCache.keys().next().value;\n      fieldParseCache.delete(firstKey);\n    }\n\n    fieldParseCache.set(trimmedField, parseInfo);\n  }\n\n  if (parseInfo.type === 'pipe' || parseInfo.type === 'ampersand') {\n    const parts = parseInfo.parts!;\n    for (let i = 0; i < parts.length; i++) {\n      const trimmedPart = parts[i].trim();\n      if (trimmedPart && getFieldValue(obj, trimmedPart) !== undefined) {\n        setFieldValue(obj, trimmedPart, value);\n        return;\n      }\n    }\n    const firstPart = parts[0]?.trim();\n    if (firstPart) {\n      setFieldValue(obj, firstPart, value);\n    }\n    return;\n  }\n\n  if (parseInfo.type === 'dot') {\n    if (typeof obj === 'object') {\n      const subObj = (obj as Record<string, unknown>)[parseInfo.firstField!];\n      if (subObj !== undefined) {\n        setFieldValue(subObj, parseInfo.subField!, value);\n      }\n    }\n    return;\n  }\n\n  if (Array.isArray(obj) && obj.length > 0 && typeof obj[0] === 'object') {\n    for (let i = 0; i < obj.length; i++) {\n      const subObj = obj[i];\n      if (subObj && typeof subObj === 'object') {\n        (subObj as Record<string, unknown>)[trimmedField] = value;\n      }\n    }\n  } else if (typeof obj === 'object') {\n    (obj as Record<string, unknown>)[trimmedField] = value;\n  }\n}\n\n/**\n * 從給定的物件中尋找特定欄位的值。\n * 遍歷所有欄位路徑，回傳第一個非空值。\n *\n * @param obj 要搜尋的物件\n * @param parts 欄位的路徑，以字串陣列表示\n * @returns 找到的欄位值，如果找不到則回傳 null\n */\nfunction findFieldValue(obj: unknown, parts: readonly string[]): unknown {\n  for (const part of parts) {\n    const trimmedPart = part.trim();\n    if (trimmedPart) {\n      const value = getFieldValue(obj, trimmedPart);\n      if (value != null) return value;\n    }\n  }\n  return null;\n}\n\n/**\n * 合併物件中多個欄位的值。\n * 將所有欄位的值合併成一個陣列，支援巢狀陣列展開。\n *\n * @param obj 要合併值的物件\n * @param parts 欄位名稱的陣列\n * @returns 合併後的值的陣列\n */\nfunction mergeFieldValue(obj: unknown, parts: readonly string[]): unknown[] {\n  const result: unknown[] = [];\n\n  for (const part of parts) {\n    const trimmedPart = part.trim();\n    if (trimmedPart) {\n      const value = getFieldValue(obj, trimmedPart);\n      if (value != null) {\n        if (Array.isArray(value)) {\n          result.push(...value);\n        } else {\n          result.push(value);\n        }\n      }\n    }\n  }\n\n  return result;\n}\n\n/**\n * 從物件中計算值，支援字串路徑、函式呼叫，以及提供預設值。\n *\n * @param obj 要查找的物件\n * @param value 要計算的值，可以是字串路徑、函式或直接的值\n * @param args 傳遞給函式的參數陣列\n * @returns 計算後的值\n */\nexport function calculateObjectValue(obj: unknown, value: unknown, ...args: unknown[]): unknown {\n  if (value == null) return value;\n\n  if (typeof value === 'string') {\n    if (isModuleFunctionString(value)) {\n      value = createFunctionFromString(value);\n    }\n    else {\n      const names = value.split('.');\n      let func: any = obj || (typeof window !== 'undefined' ? window : globalThis);\n\n      for (const name of names) {\n        func = func?.[name];\n        if (func === undefined) break;\n      }\n\n      if (typeof func === 'function') {\n        value = func;\n      }\n    }\n  }\n  if (typeof value === 'function') {\n    return executeFunction(obj, value, ...args);\n  }\n  return value;\n}\n\n/**\n * 從字串中解析並取得預設導出的函數。\n *\n * @param code 包含函數定義的字串，格式必須為 `export default function([params]) { [body] }`\n * @returns 解析後的函數\n * @throws {Error} 當函數字串格式不正確或解析失敗時拋出錯誤\n *\n * // 解析簡單函數\n * const add = createFunctionFromString('export default function(a, b) { return a + b; }');\n * console.log(add(1, 2)); // 輸出 3\n */\nexport function createFunctionFromString(code: string): (...args: any[]) => any {\n  if (typeof code !== 'string' || code.trim() === '') {\n    throw new Error('Function string cannot be empty');\n  }\n\n  const regex = /^export default\\s+(async\\s+)?function\\s*\\(([^)]*)\\)\\s*{([\\s\\S]*)}$/;\n  const matches = regex.exec(code);\n\n  if (!matches) {\n    throw new Error('Invalid function string');\n  }\n\n  const isAsync = !!matches[1];\n  const parameters = matches[2].split(',').map(param => param.trim()).filter(Boolean);\n  const functionBody = matches[3].trim();\n\n  const compartment = new Compartment();\n\n  const FuncConstructor = isAsync\n    ? Object.getPrototypeOf(async function () { }).constructor\n    : Function;\n\n  const func = new compartment.globalThis[FuncConstructor.name](...parameters, functionBody);\n\n  return func as (...args: any[]) => any;\n}\n\n/**\n * 檢查字串是否符合預期的模組函式格式\n *\n * 有效的模組函式字串格式為：\n * `export default function [name]([params]) { [body] }`\n *\n * @param code 要檢查的程式碼字串\n * @returns {boolean} 是否符合模組函式格式\n *\n * @example\n * // 回傳 true\n * isModuleFunctionString('export default function() { return 42; }');\n *\n * @example\n * // 回傳 true\n * isModuleFunctionString('export default function getData(id, type) { return fetch(`/api/${id}`); }');\n *\n * @example\n * // 回傳 false\n * isModuleFunctionString('function test() {}');\n */\nexport function isModuleFunctionString(code: string): boolean {\n  if (typeof code !== 'string') {\n    return false;\n  }\n  const trimmedCode = code.trim();\n  const regex = /^export\\s+default\\s+function\\s*[a-zA-Z0-9_$]*\\s*\\([^)]*\\)\\s*{[\\s\\S]*}$/;\n  return regex.test(trimmedCode);\n}\n\n/**\n * 依據提供的條件計算其真假值。\n *\n * @param value 要計算的條件，可以是一個 bool 值、一個函式、或者一個條件陣列\n * @param data 提供的數據對象\n * @returns 如果條件成立則回傳 true，否則回傳 false\n */\nexport function evaluateConditions(value: ConditionInterface[], data: Record<string, any>): boolean {\n  const andConditions = value.filter(condition => condition.conjunction !== 'or');\n  const orConditions = value.filter(condition => condition.conjunction === 'or');\n\n  if (andConditions.some(condition => !checkCondition(condition, data))) {\n    return false;\n  }\n\n  if (orConditions.length > 0 && !orConditions.some(condition => checkCondition(condition, data))) {\n    return false;\n  }\n\n  return true;\n}\n\n/**\n * 定義支援的條件比較運算符\n */\ntype ConditionOperator =\n  // 數值比較運算符\n  | '>' | '<' | '>=' | '<='\n  // 相等比較運算符\n  | '=' | '!='\n  // 字串操作運算符\n  | 'like'\n  // 陣列內容運算符\n  | 'include' | 'notinclude'\n  // 集合成員檢查運算符\n  | 'in' | 'notin'\n  // 型別檢查運算符\n  | 'typeof' | 'instanceof'\n  // 空值檢查運算符\n  | 'empty' | 'notempty'\n  | 'match';\n\n/**\n * 檢查條件是否符合資料物件\n *\n * 支援多種運算符比較資料屬性值與條件值:\n * - 數值比較: >, <, >=, <= (將兩側值轉換為數值進行比較)\n * - 相等比較: =, != (支援跨型別比較)\n * - 字串操作: like (不區分大小寫的子字串搜尋)\n * - 陣列操作: include, notinclude (檢查陣列中是否包含/不包含值)\n * - 集合檢查: in, notin (檢查值是否在/不在集合中)\n * - 型別檢查: typeof, instanceof (檢查值的型別或類別)\n * - 空值檢查: empty, notempty (檢查值是否為空/非空)\n * - 正則表達式: match (使用正則表達式匹配字串)\n *\n * @param condition 欲檢查的條件，包含欄位、運算符與要比較的值\n * @param data 要檢查的資料物件\n * @returns 若條件符合則回傳 true，否則回傳 false\n * @throws {Error} 當使用不支援的運算符時拋出錯誤\n */\nfunction checkCondition(condition: ConditionInterface, data: Record<string, any>): boolean {\n  try {\n    const field = calculateObjectValue(null, condition.field, data) as string;\n    const operator = calculateObjectValue(null, condition.operator, data) as ConditionOperator;\n    const value = calculateObjectValue(null, condition.value, data);\n    const fieldValue = resolvePropertyValue(data, field);\n\n    if (fieldValue === null || fieldValue === undefined) {\n      if (operator === '=') return value === null || value === undefined;\n      if (operator === '!=') return value !== null && value !== undefined;\n      if (operator === 'empty') return true;\n      if (operator === 'notempty') return false;\n      return false;\n    }\n\n    switch (operator) {\n      case '>': {\n        const numField = +fieldValue;\n        const numValue = +value;\n        return !isNaN(numField) && !isNaN(numValue) && numField > numValue;\n      }\n      case '<': {\n        const numField = +fieldValue;\n        const numValue = +value;\n        return !isNaN(numField) && !isNaN(numValue) && numField < numValue;\n      }\n      case '>=': {\n        const numField = +fieldValue;\n        const numValue = +value;\n        return !isNaN(numField) && !isNaN(numValue) && numField >= numValue;\n      }\n      case '<=': {\n        const numField = +fieldValue;\n        const numValue = +value;\n        return !isNaN(numField) && !isNaN(numValue) && numField <= numValue;\n      }\n      case '=':\n        return fieldValue === value ||\n          (typeof fieldValue === 'number' && typeof value === 'string' && fieldValue === +value && !isNaN(+value)) ||\n          (typeof fieldValue === 'string' && typeof value === 'number' && +fieldValue === value && !isNaN(+fieldValue));\n      case '!=':\n        return fieldValue !== value &&\n          !(typeof fieldValue === 'number' && typeof value === 'string' && fieldValue === +value && !isNaN(+value)) &&\n          !(typeof fieldValue === 'string' && typeof value === 'number' && +fieldValue === value && !isNaN(+fieldValue));\n      case 'like': {\n        const strField = String(fieldValue).toLowerCase();\n        const strValue = String(value).toLowerCase();\n        return strField.includes(strValue);\n      }\n      case 'include':\n        return Array.isArray(fieldValue) && fieldValue.includes(value);\n      case 'notinclude':\n        return Array.isArray(fieldValue) && !fieldValue.includes(value);\n      case 'in':\n        return Array.isArray(value) && value.includes(fieldValue);\n      case 'notin':\n        return Array.isArray(value) && !value.includes(fieldValue);\n      case 'typeof':\n        if (typeof value !== 'string') {\n          console.warn('typeof 運算符需要字串型別的比較值');\n          return false;\n        }\n        return typeof fieldValue === value;\n      case 'instanceof':\n        if (typeof value !== 'function') {\n          console.warn('instanceof 運算符需要函數型別的比較值');\n          return false;\n        }\n        return fieldValue instanceof value;\n      case 'empty':\n        return fieldValue === '' ||\n          (Array.isArray(fieldValue) && fieldValue.length === 0) ||\n          (typeof fieldValue === 'object' && fieldValue !== null &&\n            Object.keys(fieldValue).length === 0);\n      case 'notempty':\n        return fieldValue !== '' &&\n          !(Array.isArray(fieldValue) && fieldValue.length === 0) &&\n          !(typeof fieldValue === 'object' && fieldValue !== null &&\n            Object.keys(fieldValue).length === 0);\n      case 'match':\n        try {\n          const pattern = String(value);\n          return new RegExp(pattern).test(String(fieldValue));\n        } catch (error) {\n          console.error('無效的正則表達式:', value);\n          return false;\n        }\n      default:\n        throw new Error(`不支援的運算符: ${operator}`);\n    }\n  } catch (error) {\n    console.error('條件檢查失敗:', error);\n    return false;\n  }\n}\n\n/**\n * 替換字串中的佔位符為對應的值。\n *\n * @param str 要處理的字串\n * @param data 提供的資料\n * @returns 替換後的字串\n */\nexport function replacePlaceholders(str: string, data: Record<string, any>): string {\n  const placeholderRegex = /\\{([^}]+)\\}/g;\n\n  return str.replace(placeholderRegex, (_, field) => {\n    const value = getFieldValue(data, field);\n    return value !== undefined ? String(value) : '';\n  });\n}\n\n/**\n * 依據輸入值取得對應的類別物件。\n *\n * 內部使用 'clsx' 套件進行類別名稱處理，提供更好的效能。\n *\n * @param value 輸入值，可以是包含類別名稱的物件或者空格分隔的類別字串\n * @returns 對應的類別物件\n */\nexport function parseClassNames(value: string | Record<string, boolean> | null | undefined): Record<string, boolean> {\n  if (!value) return {};\n\n  if (typeof value === 'object') return value;\n\n  const trimmed = value.trim();\n  if (!trimmed) return {};\n\n  // 使用 clsx 處理並轉換為物件格式\n  return trimmed.split(/\\s+/).reduce((result, className) => {\n    if (className) result[className] = true;\n    return result;\n  }, {} as Record<string, boolean>);\n}\n\n/**\n * 合併兩個類別物件或類別字串\n *\n * 內部使用 'clsx' 套件進行類別合併，提供更好的效能和更多功能。\n *\n * @param value1 第一個類別物件或類別字串\n * @param value2 第二個類別物件或類別字串\n * @returns 合併後的類別物件\n */\nexport function mergeClasses(\n  value1: Record<string, boolean> | string | null | undefined,\n  value2: Record<string, boolean> | string | null | undefined\n): Record<string, boolean> {\n  // 使用 clsx 合併類別\n  const merged = clsx(value1, value2);\n  if (!merged) return {};\n\n  // 轉換為物件格式以保持向後兼容性\n  return merged.split(/\\s+/).reduce((result, className) => {\n    if (className) result[className] = true;\n    return result;\n  }, {} as Record<string, boolean>);\n}\n\n/**\n * 從物件中取得指定屬性的值，並依據屬性類型進行處理\n *\n * 此函式支援以下功能:\n * 1. 如果屬性不存在，回傳 null\n * 2. 如果屬性值是符合模組函式格式的字串，會將其轉換為函式並快取\n * 3. 如果屬性值是函式，會以指定物件為上下文執行並回傳結果\n *\n * @template T - 回傳值的預期型別\n * @param targetObject - 要取得屬性的目標物件\n * @param propertyName - 要取得的屬性名稱\n * @param functionArgs - 如果屬性是函式，傳遞給該函式的參數\n * @returns 處理後的屬性值，如果無法取得則回傳 null\n *\n * @example\n * // 取得簡單屬性\n * const name = resolvePropertyValue(user, 'name');\n *\n * @example\n * // 取得並執行函式屬性\n * const fullName = resolvePropertyValue(user, 'getFullName', ['withTitle']);\n */\nexport function resolvePropertyValue(\n  targetObject: Record<string, any> | null | undefined,\n  propertyName: string,\n  functionArgs?: any[]\n): any {\n  if (!targetObject || typeof targetObject !== 'object') {\n    return null;\n  }\n\n  if (!Object.hasOwn(targetObject, propertyName)) {\n    if (propertyName.includes('.')) {\n      const parts = propertyName.split('.');\n      const firstProp = parts.shift()!;\n\n      if (Object.hasOwn(targetObject, firstProp)) {\n        const nestedObj = targetObject[firstProp];\n        return resolvePropertyValue(nestedObj, parts.join('.'), functionArgs);\n      }\n    }\n    return null;\n  }\n\n  let propertyValue = targetObject[propertyName];\n  if (typeof propertyValue === 'string' && isModuleFunctionString(propertyValue)) {\n    try {\n      propertyValue = targetObject[propertyName] = createFunctionFromString(propertyValue);\n    } catch (error) {\n      console.error(`無法解析函式字串 '${propertyName}':`, error);\n      return null;\n    }\n  }\n\n  try {\n    return executeFunction(targetObject, propertyValue, ...(functionArgs || []));\n  } catch (error) {\n    console.error(`執行屬性 '${propertyName}' 時發生錯誤:`, error);\n    return null;\n  }\n}\n\n/**\n * 在文字中標記搜尋關鍵字，使其以指定樣式高亮顯示\n *\n * 此函式將搜尋文字中符合關鍵字的部分，並用 HTML 標記包裹以實現視覺高亮效果。\n * 搜尋過程不區分大小寫（case-insensitive）。\n *\n * @param text 要處理的原始文字\n * @param searchTerm 要高亮顯示的搜尋關鍵字\n * @param highlightTemplate 用於高亮顯示的 HTML 模板，使用 $1 作為關鍵字位置的佔位符\n * @returns 處理後的文字，包含高亮標記；若輸入或搜尋詞為空則回傳原文\n *\n * @example\n * // 回傳: \"找到了重要<span class=\"bg-warning text-dark\">關鍵字</span>！\"\n * highlightSearchTerms(\"找到了重要關鍵字！\", \"關鍵字\");\n *\n * @example\n * // 使用自訂樣式\n * highlightSearchTerms(\"Hello World\", \"world\", '<mark>$1</mark>');\n * // 回傳: \"Hello <mark>World</mark>\"\n */\nexport function appendHighlight(\n  text: string,\n  searchTerm: string,\n  highlightTemplate = '<span class=\"bg-warning text-dark\">$1</span>'\n): string {\n  if (!searchTerm || !text) {\n    return text;\n  }\n\n  try {\n    const escapedSearchTerm = escapeHtml(searchTerm);\n    const searchRegex = new RegExp(`(${escapedSearchTerm})`, 'gi');\n    const processedTemplate = highlightTemplate.replace('$1', '$&');\n    return text.replace(searchRegex, processedTemplate);\n  } catch (error) {\n    console.error('搜尋高亮處理錯誤:', error);\n    return text;\n  }\n}\n\n/**\n * 安全地執行函數\n *\n * 此函式會嘗試以指定的上下文執行目標函數，並處理可能的錯誤。\n * 如果輸入不是函數，則直接回傳原始值，且不會執行任何操作。\n *\n * @template TFunc 函數類型\n * @template TResult 回傳值類型\n * @param context 函數執行的上下文對象（this 指向）\n * @param fn 要執行的函數（若不是函數則原樣回傳）\n * @param args 傳遞給函數的參數列表\n * @returns 函數執行結果、Promise<結果>（如果是非同步函數）或原始值\n *\n * @example\n * // 回傳函數執行結果\n * const result = executeFunction(user, user.getName, 'full');\n *\n * @example\n * // 若 fn 不是函數，直接回傳原始值\n * const result = executeFunction(user, 'notAFunction');\n */\nexport function executeFunction<T = any>(\n  context: any,\n  fn: ((...args: any[]) => T) | any,\n  ...args: any[]\n): T | Promise<T> {\n  if (typeof fn !== 'function') {\n    return fn;\n  }\n\n  return fn.apply(context, args);\n}\n\n/**\n * 檢查是否為有效的條件陣列\n *\n * 有效的條件陣列必須滿足以下條件：\n * 1. 不為 null 或 undefined\n * 2. 為陣列型別\n * 3. 陣列中的每個元素都必須包含 field、operator、value 屬性\n *\n * @param conditions 要檢查的潛在條件陣列\n * @returns 如果是有效的條件陣列則回傳 true，否則回傳 false\n *\n * @example\n * // 回傳 true\n * isConditions([\n *   { field: 'age', operator: '>', value: 18 },\n *   { field: 'status', operator: '=', value: 'active', conjunction: 'and' }\n * ]);\n *\n * @example\n * // 回傳 false - 缺少必要屬性\n * isConditions([{ field: 'name', operator: '=' }]);\n */\nexport function isConditions(value: unknown): value is ConditionInterface[] {\n  if (value == null || !Array.isArray(value)) {\n    return false;\n  }\n\n  return value.every(\n    (item): item is ConditionInterface =>\n      typeof item === 'object' &&\n      item !== null &&\n      'field' in item &&\n      'operator' in item &&\n      'value' in item\n  );\n}\n\n/**\n * 檢查是否為有效的條件群組陣列\n *\n * 有效的條件群組陣列必須滿足以下條件：\n * 1. 不為 null 或 undefined\n * 2. 為陣列型別\n * 3. 陣列中的每個元素都必須包含 conditions 屬性（陣列型別）和 value 屬性\n * 4. conditions 屬性必須是有效的條件陣列\n *\n * @param value 要檢查的潛在條件群組陣列\n * @returns 如果是有效的條件群組陣列則回傳 true，否則回傳 false\n *\n * @example\n * // 回傳 true\n * isConditionGroups([\n *  { conditions: [{ field: 'age', operator: '>', value: 18 }], value: 'adult' },\n * { conditions: [{ field: 'status', operator: '=', value: 'active' }], value: 'active' }\n * ]);\n * * @example\n * // 回傳 false - 缺少必要屬性\n * isConditionGroups([{ conditions: [{ field: 'name', operator: '=' }], value\n * : 'John' }]);\n */\nexport function isConditionGroups(value: unknown): value is ConditionGroupInterface[] {\n  if (value == null || !Array.isArray(value)) {\n    return false;\n  }\n\n  return value.every(\n    (item): item is ConditionGroupInterface =>\n      typeof item === 'object' &&\n      item !== null &&\n      'conditions' in item &&\n      isConditions(item.conditions) &&\n      'value' in item\n  );\n}\n\n/**\n * 取得選中的項目 ID 清單\n *\n * 依據選擇模式回傳不同格式的選中項目 ID：\n * - 'single': 回傳單一選中項目 ID (字串)\n * - 'multiple': 回傳所有選中項目 ID 陣列\n * - 'none': 不允許選擇，回傳 null\n *\n * 若無選中項目：\n * - 若 nullable 為 true，則回傳 null\n * - 若 nullable 為 false，則選擇第一個項目作為預設值\n *\n * @param items 項目清單，包含所有可選擇的項目\n * @param nullable 是否允許空值。true 表示允許回傳 null；false 表示至少選中一個項目\n * @param selection 選擇模式，預設為 'single'（單選）\n * @returns 選中的項目 ID 或 ID 列表，或 null（當無選中項目且 nullable 為 true 時）\n *\n * @example\n * // 回傳單一選中 ID\n * getSelectedItemIds(items, false, 'single');\n *\n * @example\n * // 回傳選中 ID 的陣列\n * getSelectedItemIds(items, true, 'multiple');\n */\nexport function getSelectedItemIds(\n  items: ListItemInterface[],\n  nullable: boolean,\n  selection: 'single' | 'multiple' | 'none' = 'single'\n): string | string[] | null {\n  if (!Array.isArray(items) || items.length === 0) return null;\n\n  const selectedIds = items\n    .filter(item => item.selected === true && item.id)\n    .map(item => String(item.id));\n\n  if (selectedIds.length === 0) {\n    if (nullable || selection === 'none') {\n      return null;\n    }\n\n    const firstItem = items.find(item => item.id);\n    if (firstItem) {\n      selectedIds.push(String(firstItem.id));\n    } else {\n      return null;\n    }\n  }\n\n  return selection === 'single'\n    ? selectedIds[0]\n    : selectedIds;\n}\n\n/**\n * 檢查一個字串或字串陣列是否包含任何非空值\n *\n * 對於單個字串，會檢查去除空格後是否有內容\n * 對於字串陣列，會檢查是否至少有一個字串去除空格後有內容\n *\n * @param value 要檢查的字串或字串陣列\n * @returns 如果至少有一個非空值，則返回 true，否則返回 false\n */\nexport function isNonEmptyValue(value: string | string[]): boolean {\n  if (Array.isArray(value)) {\n    if (value.length === 0) {\n      return false;\n    }\n\n    return value.some(str => isNonEmptyValue(str));\n  }\n\n  return typeof value === 'string' && value.trim() !== '';\n}\n\nexport function deepEqual(a: any, b: any): boolean {\n  return a == b || equal(a, b);\n}\n","import { FunctionalComponent, h } from '@stencil/core';\r\nimport { debounce, parseClassNames } from '../utils';\r\nimport type { FnHrProps, FnIconProps, FnIconSwitchProps, FnSearchInputProps, FnTagProps } from './interface';\r\n\r\n/**\r\n * 圖示\r\n * @param ref 元素的引用函式\r\n * @param class\r\n * @param children 圖示名稱\r\n * @returns JSX 元素\r\n */\r\nexport const FnIcon: FunctionalComponent<FnIconProps & { ref?: (el: HTMLElement | null) => void }> = ({ class: classes, onClick, ref }, children) => {\r\n  if (!children || !Array.isArray(children) || children.length !== 1 || typeof children[0] !== 'string' || !String(children[0]).trim()) return;\r\n\r\n  const iconClass = {\r\n    'material-icons': true,\r\n    'align-middle': true,\r\n    ...parseClassNames(classes),\r\n  };\r\n\r\n  return (\r\n    <i\r\n      class={iconClass}\r\n      ref={ref}\r\n      onClick={ev => {\r\n        if (!onClick) return;\r\n        ev.stopPropagation();\r\n        onClick(ev);\r\n      }}\r\n    >\r\n      {children}\r\n    </i>\r\n  );\r\n};\r\n\r\n/**\r\n * 切換圖示元件\r\n * @param class 類別名稱\r\n * @param on 是否開啟狀態\r\n * @param onToggle 切換狀態的事件處理函式\r\n * @param disabled 是否禁用\r\n * @returns JSX 元素\r\n */\r\nexport const FnIconSwitch: FunctionalComponent<FnIconSwitchProps> = ({ class: classes, on = false, onToggle, toggleOnIcon = 'remove', toggleOffIcon = 'add' }) => {\r\n  let onIconRef: HTMLElement | null = null;\r\n  let offIconRef: HTMLElement | null = null;\r\n  let currentOn = on;\r\n\r\n  const toggleIcons = () => {\r\n    currentOn = !currentOn;\r\n\r\n    if (onIconRef && offIconRef) {\r\n      onIconRef.classList.toggle('d-none', !currentOn);\r\n      offIconRef.classList.toggle('d-none', currentOn);\r\n    }\r\n\r\n    onToggle && onToggle(currentOn);\r\n  };\r\n\r\n  const handleClick = (ev: MouseEvent) => {\r\n    ev.stopPropagation();\r\n    toggleIcons();\r\n  };\r\n  return (\r\n    <span\r\n      class={{\r\n        'cursor-pointer': true,\r\n        ...parseClassNames(classes),\r\n      }}\r\n      onClick={handleClick}\r\n    >\r\n      <FnIcon ref={el => (onIconRef = el)} class={{ 'd-none': !on }}>\r\n        {toggleOnIcon}\r\n      </FnIcon>\r\n      <FnIcon ref={el => (offIconRef = el)} class={{ 'd-none': on }}>\r\n        {toggleOffIcon}\r\n      </FnIcon>\r\n    </span>\r\n  );\r\n};\r\n\r\n/**\r\n * 搜尋框元件\r\n *\r\n * @param ref 對應的 HTMLStormInputGroupElement 元素的引用\r\n * @param value 輸入框目前的值\r\n * @param onValueChanged 當值變更時觸發的事件處理函式\r\n * @param placeholder 輸入框預設文字，預設為 '搜尋'\r\n *\r\n * @returns JSX 元素\r\n */\r\nexport const FnSearchInput: FunctionalComponent<FnSearchInputProps> = ({ ref, value, onValueChanged, placeholder }) => {\r\n  const handleValueChanged = debounce((ev: CustomEvent) => {\r\n    if (!onValueChanged) return;\r\n    onValueChanged(ev);\r\n  }, 500);\r\n\r\n  return (\r\n    <div class=\"mb-1\">\r\n      <storm-input-group\r\n        ref={ref}\r\n        placeholder={placeholder ?? '搜尋'}\r\n        input-style=\"outline\"\r\n        prepend-icon=\"search\"\r\n        value={value}\r\n        onValueChanged={(ev: CustomEvent) => {\r\n          ev.stopPropagation();\r\n          handleValueChanged(ev);\r\n        }}\r\n        onChange={(ev: CustomEvent) => {\r\n          if (ev) ev.stopPropagation();\r\n        }}\r\n      ></storm-input-group>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport const FnHr: FunctionalComponent<FnHrProps> = ({ class: classes }) => (\r\n  <hr\r\n    class={{\r\n      dark: true,\r\n      horizontal: true,\r\n      'mx-2': true,\r\n      'my-0': true,\r\n      ...parseClassNames(classes),\r\n    }}\r\n  />\r\n);\r\n\r\nexport const FnTag: FunctionalComponent<FnTagProps> = ({ lable, onClickCancel }) => (\r\n  <span\r\n    class={{\r\n      'storm-tag': true,\r\n      badge: true,\r\n      'bg-primary': true,\r\n      'rounded-pill': true,\r\n      'me-1': true,\r\n      'px-2': true,\r\n      'py-1': true,\r\n    }}\r\n  >\r\n    {lable}\r\n    {onClickCancel != null ? <FnIcon onClick={onClickCancel}>cancel</FnIcon> : undefined}\r\n  </span>\r\n);\r\n"],"names":[],"mappings":"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"}