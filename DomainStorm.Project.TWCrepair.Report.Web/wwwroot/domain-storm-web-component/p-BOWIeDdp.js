const t=globalThis;const{Array:e,ArrayBuffer:o,Date:r,FinalizationRegistry:n,Float32Array:s,JSON:a,Map:i,Math:c,Number:u,Object:l,Promise:f,Proxy:p,Reflect:d,RegExp:y,Set:g,String:m,Symbol:b,Uint8Array:h,WeakMap:S,WeakSet:P}=globalThis;const{Error:E,RangeError:w,ReferenceError:_,SyntaxError:A,TypeError:v,AggregateError:I}=globalThis;const{assign:T,create:$,defineProperties:x,entries:O,freeze:N,getOwnPropertyDescriptor:C,getOwnPropertyDescriptors:F,getOwnPropertyNames:k,getPrototypeOf:R,is:M,keys:L,prototype:U,preventExtensions:D,setPrototypeOf:B,values:j,fromEntries:G,hasOwn:H}=l;const{species:W,toStringTag:z,iterator:K,matchAll:V,unscopables:q,keyFor:Y,for:J}=b;const{isInteger:Q}=u;const{stringify:X}=a;const{defineProperty:Z}=l;const tt=(t,e,o)=>{const r=Z(t,e,o);if(r!==t){throw v(`Please report that the original defineProperty silently failed to set ${X(m(e))}. (SES_DEFINE_PROPERTY_FAILED_SILENTLY)`)}return r};const{apply:et,construct:ot,get:rt,getOwnPropertyDescriptor:nt,has:st,isExtensible:at,ownKeys:it,preventExtensions:ct,set:ut}=d;const{isArray:lt,prototype:ft}=e;const{prototype:pt}=o;const{prototype:dt}=i;const{prototype:yt}=RegExp;const{prototype:gt}=g;const{prototype:mt}=m;const{prototype:bt}=S;const{prototype:ht}=P;const{prototype:St}=Function;const{prototype:Pt}=f;const{prototype:Et}=R((function*(){}));const wt=R(R(ft.values()));const _t=R(h.prototype);const{bind:At}=St;const vt=At.bind(At.call);const It=vt(ft.filter);const Tt=vt(ft.forEach);const $t=vt(ft.includes);const xt=vt(ft.join);const Ot=vt(ft.map);const Nt=vt(ft.flatMap);const Ct=vt(ft.pop);const Ft=vt(ft.push);const kt=vt(ft.slice);const Rt=vt(ft.some);const Mt=vt(ft.sort);const Lt=vt(ft[K]);const Ut=vt(pt.slice);const Dt=vt(C(pt,"byteLength").get);const Bt=vt(_t.set);const jt=vt(dt.set);const Gt=vt(dt.get);const Ht=vt(dt.has);const Wt=vt(dt.delete);const zt=vt(dt.entries);const Kt=vt(dt[K]);const Vt=vt(gt.add);vt(gt.delete);const qt=vt(gt.forEach);const Yt=vt(gt.has);const Jt=vt(gt[K]);const Qt=vt(yt.test);const Xt=vt(yt.exec);const Zt=vt(yt[V]);const te=vt(mt.endsWith);const ee=vt(mt.includes);const oe=vt(mt.indexOf);vt(mt.match);const re=vt(Et.next);const ne=vt(Et.throw);const se=vt(mt.replace);const ae=vt(mt.search);const ie=vt(mt.slice);const ce=vt(mt.split);const ue=vt(mt.startsWith);const le=vt(mt[K]);const fe=vt(bt.delete);const pe=vt(bt.get);const de=vt(bt.has);const ye=vt(bt.set);const ge=vt(ht.add);const me=vt(ht.has);const be=vt(St.toString);const he=vt(At);vt(Pt.catch);const Se=vt(Pt.then);const Pe=n&&vt(n.prototype.register);n&&vt(n.prototype.unregister);const Ee=t=>!t||typeof t!=="object"&&typeof t!=="function";const we=t=>t instanceof E;const _e=t=>t;const Ae=eval;const ve=Function;const Ie=()=>{throw v('Cannot eval with evalTaming set to "no-eval" (SES_NO_EVAL)')};const Te=C(Error("er1"),"stack");const $e=C(v("er2"),"stack");let xe;let Oe;if(Te&&$e&&Te.get){if(typeof Te.get==="function"&&Te.get===$e.get&&typeof Te.set==="function"&&Te.set===$e.set){xe=N(Te.get);Oe=N(Te.set)}else{throw v("Unexpected Error own stack accessor functions (SES_UNEXPECTED_ERROR_OWN_STACK_ACCESSOR)")}}const Ne=xe;const Ce=Oe;const Fe=()=>{try{return new ve("return (async function* AsyncGeneratorFunctionInstance() {})")()}catch(t){if(t.name==="SyntaxError"){return undefined}else if(t.name==="EvalError"){return async function*t(){}}else{throw t}}};const ke=Fe();function Re(){return this}if(Re()){throw v(`SES failed to initialize, sloppy mode (SES_NO_SLOPPY)`)}const Me=globalThis;const{Object:Le,Reflect:Ue,Array:De,String:Be,JSON:je,Error:Ge}=Me;const{freeze:He}=Le;const{apply:We}=Ue;const ze=t=>(e,...o)=>We(t,e,o);const Ke=ze(De.prototype.push);const Ve=ze(De.prototype.includes);const qe=ze(Be.prototype.split);const Ye=je.stringify;const Je=(t,...e)=>{let o=t[0];for(let r=0;r<e.length;r+=1){o=`${o}${e[r]}${t[r+1]}`}throw Ge(o)};const Qe=(t,e=false)=>{const o=[];const r=(r,n,s=undefined)=>{typeof r==="string"||Je`Environment option name ${Ye(r)} must be a string.`;typeof n==="string"||Je`Environment option default setting ${Ye(n)} must be a string.`;let a=n;const i=t.process||undefined;const c=typeof i==="object"&&i.env||undefined;if(typeof c==="object"){if(r in c){if(!e){Ke(o,r)}const t=c[r];typeof t==="string"||Je`Environment option named ${Ye(r)}, if present, must have a corresponding string value, got ${Ye(t)}`;a=t}}s===undefined||a===n||Ve(s,a)||Je`Unrecognized ${Ye(r)} value ${Ye(a)}. Expected one of ${Ye([n,...s])}`;return a};He(r);const n=t=>{const e=r(t,"");return He(e===""?[]:qe(e,","))};He(n);const s=(t,e)=>Ve(n(t),e);const a=()=>He([...o]);He(a);return He({getEnvironmentOption:r,getEnvironmentOptionsList:n,environmentOptionsListHas:s,getCapturedEnvironmentOptionNames:a})};He(Qe);const{getEnvironmentOption:Xe}=Qe(Me,true);const{ArrayBuffer:Ze,Object:to,Reflect:eo,Symbol:oo,TypeError:ro,Uint8Array:no,WeakMap:so,structuredClone:ao}=globalThis;const{freeze:io,defineProperty:co,getPrototypeOf:uo,getOwnPropertyDescriptor:lo}=to;const{apply:fo,ownKeys:po}=eo;const{toStringTag:yo}=oo;const{prototype:go}=Ze;const{slice:mo,transfer:bo}=go;const{get:ho}=lo(go,"byteLength");const So=uo(no.prototype);const{set:Po}=So;const{get:Eo}=lo(So,"buffer");const wo=(t,e=undefined,o=undefined)=>fo(mo,t,[e,o]);let _o;if(bo){_o=t=>fo(bo,t,[])}else if(ao){_o=t=>{wo(t,0,0);return ao(t,{transfer:[t]})}}else{_o=undefined}const Ao=new so;for(const t of["get","has","set"]){co(Ao,t,{value:Ao[t]})}const vo=t=>{const e=Ao.get(t);if(e){return e}throw ro("Not an emulated Immutable ArrayBuffer")};const Io={__proto__:go,get byteLength(){return fo(ho,vo(this),[])},get detached(){vo(this);return false},get maxByteLength(){return fo(ho,vo(this),[])},get resizable(){vo(this);return false},get immutable(){vo(this);return true},slice(t=undefined,e=undefined){return wo(vo(this),t,e)},sliceToImmutable(t=undefined,e=undefined){return xo(vo(this),t,e)},resize(t=undefined){vo(this);throw ro("Cannot resize an immutable ArrayBuffer")},transfer(t=undefined){vo(this);throw ro("Cannot detach an immutable ArrayBuffer")},transferToFixedLength(t=undefined){vo(this);throw ro("Cannot detach an immutable ArrayBuffer")},transferToImmutable(t=undefined){vo(this);throw ro("Cannot detach an immutable ArrayBuffer")},[yo]:"ImmutableArrayBuffer"};for(const t of po(Io)){co(Io,t,{enumerable:false})}const To=t=>{const e={__proto__:Io};Ao.set(e,t);return e};io(To);const $o=t=>Ao.has(t);const xo=(t,e=undefined,o=undefined)=>{let r=Ao.get(t);if(r===undefined){r=t}return To(wo(r,e,o))};let Oo;if(_o){Oo=(t,e=undefined)=>{if(e===undefined){t=_o(t)}else if(bo){t=fo(bo,t,[e])}else{t=_o(t);const o=t.byteLength;if(e<=o){t=wo(t,0,e)}else{const o=new no(t);const r=new no(e);fo(Po,r,[o]);t=fo(Eo,r,[])}}const o=To(t);return o}}else{Oo=undefined}const No=Oo;const{ArrayBuffer:Co,JSON:Fo,Object:ko,Reflect:Ro}=globalThis;const Mo=No;const{getOwnPropertyDescriptors:Lo,defineProperties:Uo,defineProperty:Do}=ko;const{ownKeys:Bo}=Ro;const{prototype:jo}=Co;const{stringify:Go}=Fo;const Ho={sliceToImmutable(t=undefined,e=undefined){return xo(this,t,e)},get immutable(){return $o(this)},...Mo?{transferToImmutable(t=undefined){return Mo(this,t)}}:{}};for(const t of Bo(Ho)){Do(Ho,t,{enumerable:false})}const Wo=Bo(Ho).filter((t=>t in jo));if(Wo.length>0){console.warn(`About to overwrite ArrayBuffer.prototype properties ${Go(Wo)}`)}Uo(jo,Lo(Ho));const zo=t=>{t=`${t}`;if(t.length>=1&&ee("aeiouAEIOU",t[0])){return`an ${t}`}return`a ${t}`};N(zo);const Ko=(t,e=undefined)=>{const o=new g;const r=(t,e)=>{switch(typeof e){case"object":{if(e===null){return null}if(Yt(o,e)){return"[Seen]"}Vt(o,e);if(we(e)){return`[${e.name}: ${e.message}]`}if(z in e){return`[${e[z]}]`}if(lt(e)){return e}const t=L(e);if(t.length<2){return e}let r=true;for(let e=1;e<t.length;e+=1){if(t[e-1]>=t[e]){r=false;break}}if(r){return e}Mt(t);const n=Ot(t,(t=>[t,e[t]]));return G(n)}case"function":{return`[Function ${e.name||"<anon>"}]`}case"string":{if(ue(e,"[")){return`[${e}]`}return e}case"undefined":case"symbol":{return`[${m(e)}]`}case"bigint":{return`[${e}n]`}case"number":{if(M(e,NaN)){return"[NaN]"}else if(e===Infinity){return"[Infinity]"}else if(e===-Infinity){return"[-Infinity]"}return e}default:{return e}}};try{return X(t,r,e)}catch(t){return"[Something that failed to stringify]"}};N(Ko);const{Error:Vo,TypeError:qo,WeakMap:Yo}=globalThis;const{parse:Jo,stringify:Qo}=JSON;const{isSafeInteger:Xo}=Number;const{freeze:Zo}=Object;const{toStringTag:tr}=Symbol;const er=Symbol("UNKNOWN_KEY");const or=(t,e)=>{const o=Qo(t);const r=Jo(o,e);return r};const rr=(t,e)=>Zo(e);const nr=t=>or(t,rr);const sr=(t,e,o)=>{const r=t?.next;const n={id:e,next:r,prev:t,data:o};t.next=n;r.prev=n;return n};const ar=(t,e,o=e.next)=>{if(t===e||t===o)return;const{prev:r,next:n}=t;r.next=n;n.prev=r;t.prev=e;t.next=o;e.next=t;o.prev=t};const ir=(t,e,o)=>{if(e!==er){t.data.delete(e);return}if(t.data.clear){t.data.clear();return}if(!o){throw Vo("internal: makeMap is required with UNKNOWN_KEY")}t.data=o()};const cr=Zo({totalQueryCount:0,totalHitCount:0});const ur=(t,e={})=>{if(!Xo(t)||t<0){throw qo("capacity must be a non-negative safe integer number <= 2**53 - 1")}const o=(t=>{try{t();return t}catch(e){const o=()=>new t;return o}})(e.makeMap??Yo);const r=o().clear===undefined?"WeakCacheMap":"CacheMap";const n=o();const s={id:0,next:undefined,prev:undefined,data:{has:()=>{throw Vo("internal: sentinel head cell has no data")}}};s.next=s;s.prev=s;let a=0;const i=or(cr);const c=()=>nr(i);const u=t=>{i.totalQueryCount+=1;const e=n.get(t);if(!e?.data.has(t))return undefined;i.totalHitCount+=1;ar(e,s);return e};const l=t=>{const e=u(t);return e!==undefined};Zo(l);const f=t=>{const e=u(t);return e?.data.get(t)};Zo(f);const p=(e,r)=>{let i=u(e);if(i){i.data.set(e,r);return y}if(a<t){i=sr(s,a+1,o());a+=1;i.data.set(e,r)}else if(t>0){i=s.prev;ir(i,er,o);i.data.set(e,r);ar(i,s)}if(i)n.set(e,i);return y};Zo(p);const{delete:d}={delete:t=>{const e=n.get(t);if(!e?.data.has(t)){n.delete(t);return false}ar(e,s.prev);ir(e,t);n.delete(t);return true}};Zo(d);const y={has:l,get:f,set:p,delete:d,[tr]:r};Zo(y);const g={cache:y,getMetrics:c};return Zo(g)};Zo(ur);const{freeze:lr}=Object;const{isSafeInteger:fr}=Number;const pr=1e3;const dr=100;const yr=(t=pr,e=dr)=>{if(!fr(e)||e<1){throw TypeError("argsPerErrorBudget must be a safe positive integer number")}const{cache:o}=ur(t);const r=(t,r)=>{const n=o.get(t);if(n!==undefined){if(n.length>=e){n.shift()}n.push(r)}else{o.set(t,[r])}};lr(r);const n=t=>{const e=o.get(t);o.delete(t);return e};lr(n);return lr({addLogArgs:r,takeLogArgsArray:n})};lr(yr);const gr=new S;const mr=(t,e=undefined)=>{const o=N({toString:N((()=>Ko(t,e)))});ye(gr,o,t);return o};N(mr);const br=N(/^[\w:-]( ?[\w:-])*$/);const hr=(t,e=undefined)=>{if(typeof t!=="string"||!Qt(br,t)){return mr(t,e)}const o=N({toString:N((()=>t))});ye(gr,o,t);return o};N(hr);const Sr=new S;const Pr=({template:t,args:e})=>{const o=[t[0]];for(let r=0;r<e.length;r+=1){const n=e[r];let s;if(de(gr,n)){s=`${n}`}else if(we(n)){s=`(${zo(n.name)})`}else{s=`(${zo(typeof n)})`}Ft(o,s,t[r+1])}return xt(o,"")};const Er=N({toString(){const t=pe(Sr,this);if(t===undefined){return"[Not a DetailsToken]"}return Pr(t)}});N(Er.toString);const wr=(t,...e)=>{const o=N({__proto__:Er});ye(Sr,o,{template:t,args:e});return o};N(wr);const _r=(t,...e)=>{e=Ot(e,(t=>de(gr,t)?t:mr(t)));return wr(t,...e)};N(_r);const Ar=({template:t,args:e})=>{const o=[t[0]];for(let r=0;r<e.length;r+=1){let n=e[r];if(de(gr,n)){n=pe(gr,n)}const s=se(Ct(o)||"",/ $/,"");if(s!==""){Ft(o,s)}const a=se(t[r+1],/^ /,"");Ft(o,n,a)}if(o[o.length-1]===""){Ct(o)}return o};const vr=new S;let Ir=0;const Tr=new S;const $r=(t,e=t.name)=>{let o=pe(Tr,t);if(o!==undefined){return o}Ir+=1;o=`${e}#${Ir}`;ye(Tr,t,o);return o};const xr=t=>{const e=F(t);const{name:o,message:r,errors:n=undefined,cause:s=undefined,stack:a=undefined,...i}=e;const c=it(i);if(c.length>=1){for(const e of c){delete t[e]}const e=$(U,i);kr(t,wr`originally with properties ${mr(e)}`)}for(const o of it(t)){const r=e[o];if(r&&H(r,"get")){tt(t,o,{value:t[o]})}}N(t)};const Or=(e=wr`Assert failed`,o=t.Error,{errorName:r=undefined,cause:n=undefined,errors:s=undefined,sanitize:a=true}={})=>{if(typeof e==="string"){e=wr([e])}const i=pe(Sr,e);if(i===undefined){throw v(`unrecognized details ${mr(e)}`)}const c=Pr(i);const u=n&&{cause:n};let l;if(typeof I!=="undefined"&&o===I){l=I(s||[],c,u)}else{l=o(c,u);if(s!==undefined){tt(l,"errors",{value:s,writable:true,enumerable:false,configurable:true})}}ye(vr,l,Ar(i));if(r!==undefined){$r(l,r)}if(a){xr(l)}return l};N(Or);const{addLogArgs:Nr,takeLogArgsArray:Cr}=yr();const Fr=new S;const kr=(t,e)=>{if(typeof e==="string"){e=wr([e])}const o=pe(Sr,e);if(o===undefined){throw v(`unrecognized details ${mr(e)}`)}const r=Ar(o);const n=pe(Fr,t);if(n!==undefined){for(const e of n){e(t,r)}}else{Nr(t,r)}};N(kr);const Rr=t=>{if(!("stack"in t)){return""}const e=`${t.stack}`;const o=oe(e,"\n");if(ue(e," ")||o===-1){return e}return ie(e,o+1)};const Mr={getStackString:t.getStackString||Rr,tagError:t=>$r(t),resetErrorTagNum:()=>{Ir=0},getMessageLogArgs:t=>pe(vr,t),takeMessageLogArgs:t=>{const e=pe(vr,t);fe(vr,t);return e},takeNoteLogArgsArray:(t,e)=>{const o=Cr(t);if(e!==undefined){const o=pe(Fr,t);if(o){Ft(o,e)}else{ye(Fr,t,[e])}}return o||[]}};N(Mr);const Lr=(t=undefined,e=false)=>{const o=e?_r:wr;const r=o`Check failed`;const n=(e=r,o=undefined,n=undefined)=>{const s=Or(e,o,n);if(t!==undefined){t(s)}throw s};N(n);const s=(t,...e)=>n(o(t,...e));function a(t,e=undefined,o=undefined,r=undefined){t||n(e,o,r)}const i=(t,e,r=undefined,s=undefined,a=undefined)=>{M(t,e)||n(r||o`Expected ${t} is same as ${e}`,s||w,a)};N(i);const c=(t,e,r)=>{if(typeof t===e){return}typeof e==="string"||s`${mr(e)} must be a string`;if(r===undefined){const n=zo(e);r=o`${t} must be ${hr(n)}`}n(r,v)};N(c);const u=(t,e=undefined)=>c(t,"string",e);const l=T(a,{error:Or,fail:n,equal:i,typeof:c,string:u,note:kr,details:o,Fail:s,quote:mr,bare:hr,makeAssert:Lr});return N(l)};N(Lr);const Ur=Lr();const Dr=Ur.equal;const Br=C(_t,z);Ur(Br);const jr=Br.get;Ur(jr);const Gr=t=>{const e=et(jr,t,[]);return e!==undefined};const Hr=t=>{const e=+m(t);return Q(e)&&m(e)===t};const Wr=t=>{D(t);Tt(it(t),(e=>{const o=C(t,e);Ur(o);if(!Hr(e)){tt(t,e,{...o,writable:false,configurable:false})}}))};const zr=()=>{if(typeof t.harden==="function"){const e=t.harden;return e}const e=new P;const{harden:o}={harden(t){const o=new g;function r(t){if(Ee(t)){return}const r=typeof t;if(r!=="object"&&r!=="function"){throw v(`Unexpected typeof: ${r}`)}if(me(e,t)||Yt(o,t)){return}Vt(o,t)}const n=t=>{if(Gr(t)){Wr(t)}else{N(t)}const e=F(t);const o=R(t);r(o);Tt(it(e),(t=>{const o=e[t];if(H(o,"value")){r(o.value)}else{r(o.get);r(o.set)}}))};const s=Ne===undefined&&Ce===undefined?n:t=>{if(we(t)){const e=C(t,"stack");if(e&&e.get===Ne&&e.configurable){tt(t,"stack",{value:et(Ne,t,[])})}}return n(t)};const a=()=>{qt(o,s)};const i=t=>{ge(e,t)};const c=()=>{qt(o,i)};r(t);a();c();return t}};return o};const Kr=(t,e,o,r,{warn:n,error:s})=>{if(!o){n(`Removing ${r}`)}try{delete t[e]}catch(o){if(H(t,e)){if(typeof t==="function"&&e==="prototype"){t.prototype=undefined;if(t.prototype===undefined){n(`Tolerating undeletable ${r} === undefined`);return}}s(`failed to delete ${r}`,o)}else{s(`deleting ${r} threw`,o)}throw o}};const Vr={Infinity:Infinity,NaN,undefined};const qr={isFinite:"isFinite",isNaN:"isNaN",parseFloat:"parseFloat",parseInt:"parseInt",decodeURI:"decodeURI",decodeURIComponent:"decodeURIComponent",encodeURI:"encodeURI",encodeURIComponent:"encodeURIComponent",Array:"Array",ArrayBuffer:"ArrayBuffer",BigInt:"BigInt",BigInt64Array:"BigInt64Array",BigUint64Array:"BigUint64Array",Boolean:"Boolean",DataView:"DataView",EvalError:"EvalError",Float16Array:"Float16Array",Float32Array:"Float32Array",Float64Array:"Float64Array",Int8Array:"Int8Array",Int16Array:"Int16Array",Int32Array:"Int32Array",Map:"Map",Number:"Number",Object:"Object",Promise:"Promise",Proxy:"Proxy",RangeError:"RangeError",ReferenceError:"ReferenceError",Set:"Set",String:"String",SyntaxError:"SyntaxError",TypeError:"TypeError",Uint8Array:"Uint8Array",Uint8ClampedArray:"Uint8ClampedArray",Uint16Array:"Uint16Array",Uint32Array:"Uint32Array",URIError:"URIError",WeakMap:"WeakMap",WeakSet:"WeakSet",Iterator:"Iterator",AsyncIterator:"AsyncIterator",AggregateError:"AggregateError",JSON:"JSON",Reflect:"Reflect",escape:"escape",unescape:"unescape",ModuleSource:"ModuleSource",lockdown:"lockdown",harden:"harden",HandledPromise:"HandledPromise"};const Yr={Date:"%InitialDate%",Error:"%InitialError%",RegExp:"%InitialRegExp%",Math:"%InitialMath%",getStackString:"%InitialGetStackString%"};const Jr={Date:"%SharedDate%",Error:"%SharedError%",RegExp:"%SharedRegExp%",Symbol:"%SharedSymbol%",Math:"%SharedMath%"};const Qr=[EvalError,RangeError,ReferenceError,SyntaxError,TypeError,URIError];if(typeof AggregateError!=="undefined"){Ft(Qr,AggregateError)}const Xr={"[[Proto]]":"%FunctionPrototype%",length:"number",name:"string"};const Zr={"[[Proto]]":"%AsyncFunctionPrototype%"};const tn=Xr;const en=Zr;const on={get:tn,set:"undefined"};const rn={get:tn,set:tn};Tt(["caller","arguments"],(t=>{}));const nn=t=>t===on||t===rn;function sn(t){return{"[[Proto]]":"%SharedError%",prototype:t}}function an(t){return{"[[Proto]]":"%ErrorPrototype%",constructor:t,message:"string",name:"string",toString:false,cause:false}}function cn(t){return{"[[Proto]]":"%TypedArray%",BYTES_PER_ELEMENT:"number",prototype:t}}function un(t){return{"[[Proto]]":"%TypedArrayPrototype%",BYTES_PER_ELEMENT:"number",constructor:t}}const ln={E:"number",LN10:"number",LN2:"number",LOG10E:"number",LOG2E:"number",PI:"number",SQRT1_2:"number",SQRT2:"number","@@toStringTag":"string",abs:tn,acos:tn,acosh:tn,asin:tn,asinh:tn,atan:tn,atanh:tn,atan2:tn,cbrt:tn,ceil:tn,clz32:tn,cos:tn,cosh:tn,exp:tn,expm1:tn,floor:tn,fround:tn,hypot:tn,imul:tn,log:tn,log1p:tn,log10:tn,log2:tn,max:tn,min:tn,pow:tn,round:tn,sign:tn,sin:tn,sinh:tn,sqrt:tn,tan:tn,tanh:tn,trunc:tn,f16round:tn,sumPrecise:tn,idiv:false,idivmod:false,imod:false,imuldiv:false,irem:false,mod:false,irandom:false};const fn={"[[Proto]]":null,"%ThrowTypeError%":tn,Infinity:"number",NaN:"number",undefined:"undefined","%UniqueEval%":tn,isFinite:tn,isNaN:tn,parseFloat:tn,parseInt:tn,decodeURI:tn,decodeURIComponent:tn,encodeURI:tn,encodeURIComponent:tn,Object:{"[[Proto]]":"%FunctionPrototype%",assign:tn,create:tn,defineProperties:tn,defineProperty:tn,entries:tn,freeze:tn,fromEntries:tn,getOwnPropertyDescriptor:tn,getOwnPropertyDescriptors:tn,getOwnPropertyNames:tn,getOwnPropertySymbols:tn,getPrototypeOf:tn,is:tn,isExtensible:tn,isFrozen:tn,isSealed:tn,keys:tn,preventExtensions:tn,prototype:"%ObjectPrototype%",seal:tn,setPrototypeOf:tn,values:tn,hasOwn:tn,groupBy:tn,__getClass:false},"%ObjectPrototype%":{"[[Proto]]":null,constructor:"Object",hasOwnProperty:tn,isPrototypeOf:tn,propertyIsEnumerable:tn,toLocaleString:tn,toString:tn,valueOf:tn,"--proto--":rn,__defineGetter__:tn,__defineSetter__:tn,__lookupGetter__:tn,__lookupSetter__:tn},"%UniqueFunction%":{"[[Proto]]":"%FunctionPrototype%",prototype:"%FunctionPrototype%"},"%InertFunction%":{"[[Proto]]":"%FunctionPrototype%",prototype:"%FunctionPrototype%"},"%FunctionPrototype%":{apply:tn,bind:tn,call:tn,constructor:"%InertFunction%",toString:tn,"@@hasInstance":tn,caller:false,arguments:false,fileName:false,lineNumber:false},Boolean:{"[[Proto]]":"%FunctionPrototype%",prototype:"%BooleanPrototype%"},"%BooleanPrototype%":{constructor:"Boolean",toString:tn,valueOf:tn},"%SharedSymbol%":{"[[Proto]]":"%FunctionPrototype%",asyncIterator:"symbol",for:tn,hasInstance:"symbol",isConcatSpreadable:"symbol",iterator:"symbol",keyFor:tn,match:"symbol",matchAll:"symbol",prototype:"%SymbolPrototype%",replace:"symbol",search:"symbol",species:"symbol",split:"symbol",toPrimitive:"symbol",toStringTag:"symbol",unscopables:"symbol",asyncDispose:"symbol",dispose:"symbol",useSimple:false,useSetter:false,operatorSet:false},"%SymbolPrototype%":{constructor:"%SharedSymbol%",description:on,toString:tn,valueOf:tn,"@@toPrimitive":tn,"@@toStringTag":"string"},"%InitialError%":{"[[Proto]]":"%FunctionPrototype%",prototype:"%ErrorPrototype%",captureStackTrace:tn,stackTraceLimit:rn,prepareStackTrace:rn,isError:tn},"%SharedError%":{"[[Proto]]":"%FunctionPrototype%",prototype:"%ErrorPrototype%",captureStackTrace:tn,stackTraceLimit:rn,prepareStackTrace:rn,isError:tn},"%ErrorPrototype%":{constructor:"%SharedError%",message:"string",name:"string",toString:tn,at:false,stack:rn,cause:false},EvalError:sn("%EvalErrorPrototype%"),RangeError:sn("%RangeErrorPrototype%"),ReferenceError:sn("%ReferenceErrorPrototype%"),SyntaxError:sn("%SyntaxErrorPrototype%"),TypeError:sn("%TypeErrorPrototype%"),URIError:sn("%URIErrorPrototype%"),AggregateError:sn("%AggregateErrorPrototype%"),"%EvalErrorPrototype%":an("EvalError"),"%RangeErrorPrototype%":an("RangeError"),"%ReferenceErrorPrototype%":an("ReferenceError"),"%SyntaxErrorPrototype%":an("SyntaxError"),"%TypeErrorPrototype%":an("TypeError"),"%URIErrorPrototype%":an("URIError"),"%AggregateErrorPrototype%":an("AggregateError"),Number:{"[[Proto]]":"%FunctionPrototype%",EPSILON:"number",isFinite:tn,isInteger:tn,isNaN:tn,isSafeInteger:tn,MAX_SAFE_INTEGER:"number",MAX_VALUE:"number",MIN_SAFE_INTEGER:"number",MIN_VALUE:"number",NaN:"number",NEGATIVE_INFINITY:"number",parseFloat:tn,parseInt:tn,POSITIVE_INFINITY:"number",prototype:"%NumberPrototype%"},"%NumberPrototype%":{constructor:"Number",toExponential:tn,toFixed:tn,toLocaleString:tn,toPrecision:tn,toString:tn,valueOf:tn},BigInt:{"[[Proto]]":"%FunctionPrototype%",asIntN:tn,asUintN:tn,prototype:"%BigIntPrototype%",bitLength:false,fromArrayBuffer:false,tdiv:false,fdiv:false,cdiv:false,ediv:false,tdivrem:false,fdivrem:false,cdivrem:false,edivrem:false,sqrt:false,sqrtrem:false,floorLog2:false,ctz:false},"%BigIntPrototype%":{constructor:"BigInt",toLocaleString:tn,toString:tn,valueOf:tn,"@@toStringTag":"string"},"%InitialMath%":{...ln,random:tn},"%SharedMath%":{...ln,random:tn},"%InitialDate%":{"[[Proto]]":"%FunctionPrototype%",now:tn,parse:tn,prototype:"%DatePrototype%",UTC:tn},"%SharedDate%":{"[[Proto]]":"%FunctionPrototype%",now:tn,parse:tn,prototype:"%DatePrototype%",UTC:tn},"%DatePrototype%":{constructor:"%SharedDate%",getDate:tn,getDay:tn,getFullYear:tn,getHours:tn,getMilliseconds:tn,getMinutes:tn,getMonth:tn,getSeconds:tn,getTime:tn,getTimezoneOffset:tn,getUTCDate:tn,getUTCDay:tn,getUTCFullYear:tn,getUTCHours:tn,getUTCMilliseconds:tn,getUTCMinutes:tn,getUTCMonth:tn,getUTCSeconds:tn,setDate:tn,setFullYear:tn,setHours:tn,setMilliseconds:tn,setMinutes:tn,setMonth:tn,setSeconds:tn,setTime:tn,setUTCDate:tn,setUTCFullYear:tn,setUTCHours:tn,setUTCMilliseconds:tn,setUTCMinutes:tn,setUTCMonth:tn,setUTCSeconds:tn,toDateString:tn,toISOString:tn,toJSON:tn,toLocaleDateString:tn,toLocaleString:tn,toLocaleTimeString:tn,toString:tn,toTimeString:tn,toUTCString:tn,valueOf:tn,"@@toPrimitive":tn,getYear:tn,setYear:tn,toGMTString:tn},String:{"[[Proto]]":"%FunctionPrototype%",fromCharCode:tn,fromCodePoint:tn,prototype:"%StringPrototype%",raw:tn,fromArrayBuffer:false},"%StringPrototype%":{length:"number",charAt:tn,charCodeAt:tn,codePointAt:tn,concat:tn,constructor:"String",endsWith:tn,includes:tn,indexOf:tn,lastIndexOf:tn,localeCompare:tn,match:tn,matchAll:tn,normalize:tn,padEnd:tn,padStart:tn,repeat:tn,replace:tn,replaceAll:tn,search:tn,slice:tn,split:tn,startsWith:tn,substring:tn,toLocaleLowerCase:tn,toLocaleUpperCase:tn,toLowerCase:tn,toString:tn,toUpperCase:tn,trim:tn,trimEnd:tn,trimStart:tn,valueOf:tn,"@@iterator":tn,at:tn,isWellFormed:tn,toWellFormed:tn,unicodeSets:tn,substr:tn,anchor:tn,big:tn,blink:tn,bold:tn,fixed:tn,fontcolor:tn,fontsize:tn,italics:tn,link:tn,small:tn,strike:tn,sub:tn,sup:tn,trimLeft:tn,trimRight:tn,compare:false,__quote:false},"%StringIteratorPrototype%":{"[[Proto]]":"%IteratorPrototype%",next:tn,"@@toStringTag":"string"},"%InitialRegExp%":{"[[Proto]]":"%FunctionPrototype%",prototype:"%RegExpPrototype%","@@species":on,escape:tn,input:false,$_:false,lastMatch:false,"$&":false,lastParen:false,"$+":false,leftContext:false,"$`":false,rightContext:false,"$'":false,$1:false,$2:false,$3:false,$4:false,$5:false,$6:false,$7:false,$8:false,$9:false},"%SharedRegExp%":{"[[Proto]]":"%FunctionPrototype%",prototype:"%RegExpPrototype%","@@species":on,escape:tn},"%RegExpPrototype%":{constructor:"%SharedRegExp%",exec:tn,dotAll:on,flags:on,global:on,hasIndices:on,ignoreCase:on,"@@match":tn,"@@matchAll":tn,multiline:on,"@@replace":tn,"@@search":tn,source:on,"@@split":tn,sticky:on,test:tn,toString:tn,unicode:on,unicodeSets:on,compile:false},"%RegExpStringIteratorPrototype%":{"[[Proto]]":"%IteratorPrototype%",next:tn,"@@toStringTag":"string"},Array:{"[[Proto]]":"%FunctionPrototype%",from:tn,isArray:tn,of:tn,prototype:"%ArrayPrototype%","@@species":on,at:tn,fromAsync:tn},"%ArrayPrototype%":{length:"number",concat:tn,constructor:"Array",copyWithin:tn,entries:tn,every:tn,fill:tn,filter:tn,find:tn,findIndex:tn,flat:tn,flatMap:tn,forEach:tn,includes:tn,indexOf:tn,join:tn,keys:tn,lastIndexOf:tn,map:tn,pop:tn,push:tn,reduce:tn,reduceRight:tn,reverse:tn,shift:tn,slice:tn,some:tn,sort:tn,splice:tn,toLocaleString:tn,toString:tn,unshift:tn,values:tn,"@@iterator":tn,"@@unscopables":{"[[Proto]]":null,copyWithin:"boolean",entries:"boolean",fill:"boolean",find:"boolean",findIndex:"boolean",flat:"boolean",flatMap:"boolean",includes:"boolean",keys:"boolean",values:"boolean",at:"boolean",findLast:"boolean",findLastIndex:"boolean",toReversed:"boolean",toSorted:"boolean",toSpliced:"boolean",with:"boolean",group:"boolean",groupToMap:"boolean",groupBy:"boolean"},findLast:tn,findLastIndex:tn,toReversed:tn,toSorted:tn,toSpliced:tn,with:tn,group:tn,groupToMap:tn,groupBy:tn,at:tn},"%ArrayIteratorPrototype%":{"[[Proto]]":"%IteratorPrototype%",next:tn,"@@toStringTag":"string"},"%TypedArray%":{"[[Proto]]":"%FunctionPrototype%",from:tn,of:tn,prototype:"%TypedArrayPrototype%","@@species":on},"%TypedArrayPrototype%":{buffer:on,byteLength:on,byteOffset:on,constructor:"%TypedArray%",copyWithin:tn,entries:tn,every:tn,fill:tn,filter:tn,find:tn,findIndex:tn,forEach:tn,includes:tn,indexOf:tn,join:tn,keys:tn,lastIndexOf:tn,length:on,map:tn,reduce:tn,reduceRight:tn,reverse:tn,set:tn,slice:tn,some:tn,sort:tn,subarray:tn,toLocaleString:tn,toString:tn,values:tn,"@@iterator":tn,"@@toStringTag":on,at:tn,findLast:tn,findLastIndex:tn,toReversed:tn,toSorted:tn,with:tn},BigInt64Array:cn("%BigInt64ArrayPrototype%"),BigUint64Array:cn("%BigUint64ArrayPrototype%"),Float16Array:cn("%Float16ArrayPrototype%"),Float32Array:cn("%Float32ArrayPrototype%"),Float64Array:cn("%Float64ArrayPrototype%"),Int16Array:cn("%Int16ArrayPrototype%"),Int32Array:cn("%Int32ArrayPrototype%"),Int8Array:cn("%Int8ArrayPrototype%"),Uint16Array:cn("%Uint16ArrayPrototype%"),Uint32Array:cn("%Uint32ArrayPrototype%"),Uint8ClampedArray:cn("%Uint8ClampedArrayPrototype%"),Uint8Array:{...cn("%Uint8ArrayPrototype%"),fromBase64:tn,fromHex:tn},"%BigInt64ArrayPrototype%":un("BigInt64Array"),"%BigUint64ArrayPrototype%":un("BigUint64Array"),"%Float16ArrayPrototype%":un("Float16Array"),"%Float32ArrayPrototype%":un("Float32Array"),"%Float64ArrayPrototype%":un("Float64Array"),"%Int16ArrayPrototype%":un("Int16Array"),"%Int32ArrayPrototype%":un("Int32Array"),"%Int8ArrayPrototype%":un("Int8Array"),"%Uint16ArrayPrototype%":un("Uint16Array"),"%Uint32ArrayPrototype%":un("Uint32Array"),"%Uint8ClampedArrayPrototype%":un("Uint8ClampedArray"),"%Uint8ArrayPrototype%":{...un("Uint8Array"),setFromBase64:tn,setFromHex:tn,toBase64:tn,toHex:tn},Map:{"[[Proto]]":"%FunctionPrototype%","@@species":on,prototype:"%MapPrototype%",groupBy:tn},"%MapPrototype%":{clear:tn,constructor:"Map",delete:tn,entries:tn,forEach:tn,get:tn,has:tn,keys:tn,set:tn,size:on,values:tn,"@@iterator":tn,"@@toStringTag":"string"},"%MapIteratorPrototype%":{"[[Proto]]":"%IteratorPrototype%",next:tn,"@@toStringTag":"string"},Set:{"[[Proto]]":"%FunctionPrototype%",prototype:"%SetPrototype%","@@species":on,groupBy:false},"%SetPrototype%":{add:tn,clear:tn,constructor:"Set",delete:tn,entries:tn,forEach:tn,has:tn,keys:tn,size:on,values:tn,"@@iterator":tn,"@@toStringTag":"string",intersection:tn,union:tn,difference:tn,symmetricDifference:tn,isSubsetOf:tn,isSupersetOf:tn,isDisjointFrom:tn},"%SetIteratorPrototype%":{"[[Proto]]":"%IteratorPrototype%",next:tn,"@@toStringTag":"string"},WeakMap:{"[[Proto]]":"%FunctionPrototype%",prototype:"%WeakMapPrototype%"},"%WeakMapPrototype%":{constructor:"WeakMap",delete:tn,get:tn,has:tn,set:tn,"@@toStringTag":"string"},WeakSet:{"[[Proto]]":"%FunctionPrototype%",prototype:"%WeakSetPrototype%"},"%WeakSetPrototype%":{add:tn,constructor:"WeakSet",delete:tn,has:tn,"@@toStringTag":"string"},ArrayBuffer:{"[[Proto]]":"%FunctionPrototype%",isView:tn,prototype:"%ArrayBufferPrototype%","@@species":on,fromString:false,fromBigInt:false},"%ArrayBufferPrototype%":{byteLength:on,constructor:"ArrayBuffer",slice:tn,"@@toStringTag":"string",concat:false,transfer:tn,resize:tn,resizable:on,maxByteLength:on,transferToFixedLength:tn,detached:on,transferToImmutable:tn,sliceToImmutable:tn,immutable:on},"%ImmutableArrayBufferPrototype%":{"[[Proto]]":"%ArrayBufferPrototype%",byteLength:on,slice:tn,"@@toStringTag":"string",transfer:tn,resize:tn,resizable:on,maxByteLength:on,transferToFixedLength:tn,detached:on,transferToImmutable:tn,sliceToImmutable:tn,immutable:on},SharedArrayBuffer:false,"%SharedArrayBufferPrototype%":false,DataView:{"[[Proto]]":"%FunctionPrototype%",BYTES_PER_ELEMENT:"number",prototype:"%DataViewPrototype%"},"%DataViewPrototype%":{buffer:on,byteLength:on,byteOffset:on,constructor:"DataView",getBigInt64:tn,getBigUint64:tn,getFloat16:tn,getFloat32:tn,getFloat64:tn,getInt8:tn,getInt16:tn,getInt32:tn,getUint8:tn,getUint16:tn,getUint32:tn,setBigInt64:tn,setBigUint64:tn,setFloat16:tn,setFloat32:tn,setFloat64:tn,setInt8:tn,setInt16:tn,setInt32:tn,setUint8:tn,setUint16:tn,setUint32:tn,"@@toStringTag":"string"},Atomics:false,JSON:{parse:tn,stringify:tn,"@@toStringTag":"string",rawJSON:tn,isRawJSON:tn},Iterator:{"[[Proto]]":"%FunctionPrototype%",prototype:"%IteratorPrototype%",from:tn,zip:tn,zipKeyed:tn,concat:tn},"%IteratorPrototype%":{"@@iterator":tn,constructor:"Iterator",map:tn,filter:tn,take:tn,drop:tn,flatMap:tn,reduce:tn,toArray:tn,forEach:tn,some:tn,every:tn,find:tn,"@@toStringTag":"string",toAsync:tn,"@@dispose":false},"%WrapForValidIteratorPrototype%":{"[[Proto]]":"%IteratorPrototype%",next:tn,return:tn},"%IteratorHelperPrototype%":{"[[Proto]]":"%IteratorPrototype%",next:tn,return:tn,"@@toStringTag":"string"},AsyncIterator:{"[[Proto]]":"%FunctionPrototype%",prototype:"%AsyncIteratorPrototype%",from:tn},"%AsyncIteratorPrototype%":{"@@asyncIterator":tn,constructor:"AsyncIterator",map:tn,filter:tn,take:tn,drop:tn,flatMap:tn,reduce:tn,toArray:tn,forEach:tn,some:tn,every:tn,find:tn,"@@toStringTag":"string","@@asyncDispose":false},"%WrapForValidAsyncIteratorPrototype%":{"[[Proto]]":"%AsyncIteratorPrototype%",next:tn,return:tn},"%AsyncIteratorHelperPrototype%":{"[[Proto]]":"%AsyncIteratorPrototype%",next:tn,return:tn,"@@toStringTag":"string"},"%InertGeneratorFunction%":{"[[Proto]]":"%InertFunction%",prototype:"%Generator%"},"%Generator%":{"[[Proto]]":"%FunctionPrototype%",constructor:"%InertGeneratorFunction%",prototype:"%GeneratorPrototype%","@@toStringTag":"string"},"%InertAsyncGeneratorFunction%":{"[[Proto]]":"%InertFunction%",prototype:"%AsyncGenerator%"},"%AsyncGenerator%":{"[[Proto]]":"%FunctionPrototype%",constructor:"%InertAsyncGeneratorFunction%",prototype:"%AsyncGeneratorPrototype%",length:"number","@@toStringTag":"string"},"%GeneratorPrototype%":{"[[Proto]]":"%IteratorPrototype%",constructor:"%Generator%",next:tn,return:tn,throw:tn,"@@toStringTag":"string"},"%AsyncGeneratorPrototype%":{"[[Proto]]":"%AsyncIteratorPrototype%",constructor:"%AsyncGenerator%",next:tn,return:tn,throw:tn,"@@toStringTag":"string"},HandledPromise:{"[[Proto]]":"Promise",applyFunction:tn,applyFunctionSendOnly:tn,applyMethod:tn,applyMethodSendOnly:tn,get:tn,getSendOnly:tn,prototype:"%PromisePrototype%",resolve:tn},ModuleSource:{"[[Proto]]":"%AbstractModuleSource%",prototype:"%ModuleSourcePrototype%"},"%ModuleSourcePrototype%":{"[[Proto]]":"%AbstractModuleSourcePrototype%",constructor:"ModuleSource","@@toStringTag":"string",bindings:on,needsImport:on,needsImportMeta:on,imports:on,exports:on,reexports:on},"%AbstractModuleSource%":{"[[Proto]]":"%FunctionPrototype%",prototype:"%AbstractModuleSourcePrototype%"},"%AbstractModuleSourcePrototype%":{constructor:"%AbstractModuleSource%"},Promise:{"[[Proto]]":"%FunctionPrototype%",all:tn,allSettled:tn,any:tn,prototype:"%PromisePrototype%",race:tn,reject:tn,resolve:tn,withResolvers:tn,"@@species":on,try:tn},"%PromisePrototype%":{catch:tn,constructor:"Promise",finally:tn,then:tn,"@@toStringTag":"string","UniqueSymbol(async_id_symbol)":rn,"UniqueSymbol(trigger_async_id_symbol)":rn,"UniqueSymbol(destroyed)":rn},"%InertAsyncFunction%":{"[[Proto]]":"%InertFunction%",prototype:"%AsyncFunctionPrototype%"},"%AsyncFunctionPrototype%":{"[[Proto]]":"%FunctionPrototype%",constructor:"%InertAsyncFunction%",length:"number","@@toStringTag":"string"},Reflect:{apply:tn,construct:tn,defineProperty:tn,deleteProperty:tn,get:tn,getOwnPropertyDescriptor:tn,getPrototypeOf:tn,has:tn,isExtensible:tn,ownKeys:tn,preventExtensions:tn,set:tn,setPrototypeOf:tn,"@@toStringTag":"string"},Proxy:{"[[Proto]]":"%FunctionPrototype%",revocable:tn},escape:tn,unescape:tn,"%UniqueCompartment%":{"[[Proto]]":"%FunctionPrototype%",prototype:"%CompartmentPrototype%",toString:tn},"%InertCompartment%":{"[[Proto]]":"%FunctionPrototype%",prototype:"%CompartmentPrototype%",toString:tn},"%CompartmentPrototype%":{constructor:"%InertCompartment%",evaluate:tn,globalThis:on,name:on,import:en,load:en,importNow:tn,module:tn,"@@toStringTag":"string"},lockdown:tn,harden:{...tn,isFake:"boolean"},"%InitialGetStackString%":tn};const pn=t=>typeof t==="function";function dn(t,e,o){if(H(t,e)){const r=C(t,e);if(!r||!M(r.value,o.value)||r.get!==o.get||r.set!==o.set||r.writable!==o.writable||r.enumerable!==o.enumerable||r.configurable!==o.configurable){throw v(`Conflicting definitions of ${e}`)}}tt(t,e,o)}function yn(t,e){for(const[o,r]of O(e)){dn(t,o,r)}}function gn(t,e){const o={__proto__:null};for(const[r,n]of O(e)){if(H(t,r)){o[n]=t[r]}}return o}const mn=e=>{const o=$(null);let r;const n=t=>{yn(o,F(t))};N(n);const s=()=>{for(const[t,r]of O(o)){if(Ee(r)){continue}if(!H(r,"prototype")){continue}const n=fn[t];if(typeof n!=="object"){throw v(`Expected permit object at permits.${t}`)}const s=n.prototype;if(!s){Kr(r,"prototype",false,`${t}.prototype`,e);continue}if(typeof s!=="string"||!H(fn,s)){throw v(`Unrecognized ${t}.prototype permits entry`)}const a=r.prototype;if(H(o,s)){if(o[s]!==a){throw v(`Conflicting bindings of ${s}`)}continue}o[s]=a}};N(s);const a=()=>{N(o);r=new P(It(j(o),pn));return o};N(a);const i=t=>{if(!r){throw v("isPseudoNative can only be called after finalIntrinsics")}return me(r,t)};N(i);const c={addIntrinsics:n,completePrototypes:s,finalIntrinsics:a,isPseudoNative:i};N(c);n(Vr);n(gn(t,qr));return c};const bn=(t,e)=>{const{addIntrinsics:o,finalIntrinsics:r}=mn(e);o(gn(t,Jr));return r()};function hn(t,e,o){const r=["undefined","boolean","number","string","symbol"];const n=new i(b?Ot(It(O(fn["%SharedSymbol%"]),(([t,e])=>e==="symbol"&&typeof b[t]==="symbol")),(([t])=>[b[t],`@@${t}`])):[]);function s(t,e){if(typeof e==="string"){return e}const o=Gt(n,e);if(typeof e==="symbol"){if(o){return o}else{const t=Y(e);if(t!==undefined){return`RegisteredSymbol(${t})`}else{return`Unique${m(e)}`}}}throw v(`Unexpected property name type ${t} ${e}`)}function a(e,o,r){if(Ee(o)){throw v(`Object expected: ${e}, ${m(o)}, ${r}`)}const n=R(o);if(n===null&&r===null){return}if(r!==undefined&&typeof r!=="string"){throw v(`Malformed permit ${e}.__proto__`)}if(n===t[r||"%ObjectPrototype%"]){return}throw v(`Unexpected [[Prototype]] at ${e}.__proto__ (expected ${r||"%ObjectPrototype%"})`)}function c(e,o,n,s){if(typeof s==="object"){f(e,o,s);return true}if(s===false){return false}if(typeof s==="string"){if(n==="prototype"||n==="constructor"){if(H(t,s)){if(o!==t[s]){throw v(`Does not match permit for ${e}`)}return true}}else{if($t(r,s)){if(typeof o!==s){throw v(`At ${e} expected ${s} not ${typeof o}`)}return true}}}throw v(`Unexpected property ${n} with permit ${s} at ${e}`)}function u(t,e,o,r){const n=C(e,o);if(!n){throw v(`Property ${o} not found at ${t}`)}if(H(n,"value")){if(nn(r)){throw v(`Accessor expected at ${t}`)}return c(t,n.value,o,r)}if(!nn(r)){throw v(`Accessor not expected at ${t}`)}return c(`${t}<get>`,n.get,o,r.get)&&c(`${t}<set>`,n.set,o,r.set)}function l(t,e,o){const r=o==="__proto__"?"--proto--":o;if(H(e,r)){return e[r]}if(typeof t==="function"){if(H(Xr,r)){return Xr[r]}}return undefined}function f(t,r,n){if(r===undefined||r===null){return}const i=n["[[Proto]]"];a(t,r,i);if(typeof r==="function"){e(r)}for(const e of it(r)){const a=s(t,e);const i=`${t}.${a}`;const c=l(r,n,a);if(!c||!u(i,r,e,c)){Kr(r,e,c===false,i,o)}}}f("intrinsics",t,fn)}function Sn(){try{ve.prototype.constructor("return 1")}catch(t){return N({})}const t={};function e(e,o,r){let n;try{n=(0,eval)(r)}catch(t){if(t instanceof A){return}throw t}const s=R(n);const a=function(){throw v("Function.prototype.constructor is not a valid constructor.")};x(a,{prototype:{value:s},name:{value:e,writable:false,enumerable:false,configurable:true}});x(s,{constructor:{value:a}});if(a!==ve.prototype.constructor){B(a,ve.prototype.constructor)}t[o]=a}e("Function","%InertFunction%","(function(){})");e("GeneratorFunction","%InertGeneratorFunction%","(function*(){})");e("AsyncFunction","%InertAsyncFunction%","(async function(){})");if(ke!==undefined){e("AsyncGeneratorFunction","%InertAsyncGeneratorFunction%","(async function*(){})")}return t}function Pn(){const t=r;const e=t.prototype;const o={now(){throw v("secure mode Calling %SharedDate%.now() throws")}};const n=({powers:o="none"}={})=>{let r;if(o==="original"){r=function e(...o){if(new.target===undefined){return et(t,undefined,o)}return ot(t,o,new.target)}}else{r=function e(...o){if(new.target===undefined){throw v("secure mode Calling %SharedDate% constructor as a function throws")}if(o.length===0){throw v("secure mode Calling new %SharedDate%() with no arguments throws")}return ot(t,o,new.target)}}x(r,{length:{value:7},prototype:{value:e,writable:false,enumerable:false,configurable:false},parse:{value:t.parse,writable:true,enumerable:false,configurable:true},UTC:{value:t.UTC,writable:true,enumerable:false,configurable:true}});return r};const s=n({powers:"original"});const a=n({powers:"none"});x(s,{now:{value:t.now,writable:true,enumerable:false,configurable:true}});x(a,{now:{value:o.now,writable:true,enumerable:false,configurable:true}});x(e,{constructor:{value:a}});return{"%InitialDate%":s,"%SharedDate%":a}}function En(){const t=c;const e=t;const{random:o,...r}=F(t);const n={random(){throw v("secure mode %SharedMath%.random() throws")}};const s=$(U,{...r,random:{value:n.random,writable:true,enumerable:false,configurable:true}});return{"%InitialMath%":e,"%SharedMath%":s}}function wn(t="safe"){const e=y.prototype;const o=(t={})=>{const o=function t(...e){if(new.target===undefined){return y(...e)}return ot(y,e,new.target)};x(o,{length:{value:2},prototype:{value:e,writable:false,enumerable:false,configurable:false}});if(W){const t=C(y,W);if(!t){throw v("no RegExp[Symbol.species] descriptor")}x(o,{[W]:t})}return o};const r=o();const n=o();if(t!=="unsafe"){delete e.compile}x(e,{constructor:{value:n}});return{"%InitialRegExp%":r,"%SharedRegExp%":n}}const _n={"%ObjectPrototype%":{toString:true},"%FunctionPrototype%":{toString:true},"%ErrorPrototype%":{name:true},"%IteratorPrototype%":{toString:true,constructor:true,[z]:true}};const An={"%ObjectPrototype%":{toString:true,valueOf:true},"%ArrayPrototype%":{toString:true,push:true,concat:true,[K]:true},"%FunctionPrototype%":{constructor:true,bind:true,toString:true},"%ErrorPrototype%":{constructor:true,message:true,name:true,toString:true},"%TypeErrorPrototype%":{constructor:true,message:true,name:true},"%SyntaxErrorPrototype%":{message:true,name:true},"%RangeErrorPrototype%":{message:true,name:true},"%URIErrorPrototype%":{message:true,name:true},"%EvalErrorPrototype%":{message:true,name:true},"%ReferenceErrorPrototype%":{message:true,name:true},"%AggregateErrorPrototype%":{message:true,name:true},"%PromisePrototype%":{constructor:true},"%TypedArrayPrototype%":"*","%Generator%":{constructor:true,name:true,toString:true},"%IteratorPrototype%":{toString:true,constructor:true,[z]:true}};const vn={...An,"%ObjectPrototype%":"*","%TypedArrayPrototype%":"*","%MapPrototype%":"*","%SetPrototype%":"*"};function In(t,e,{warn:o},r=[]){const n=new g(r);function s(t,e,r,s){if("value"in s&&s.configurable){const{value:a}=s;const i=Yt(n,r);const{get:c,set:u}=C({get[r](){return a},set[r](n){if(e===this){throw v(`Cannot assign to read only property '${m(r)}' of '${t}'`)}if(H(this,r)){this[r]=n}else{if(i){o(v(`Override property ${r}`))}tt(this,r,{value:n,writable:true,enumerable:true,configurable:true})}}},r);tt(c,"originalValue",{value:a,writable:false,enumerable:false,configurable:false});tt(e,r,{get:c,set:u,enumerable:s.enumerable,configurable:s.configurable})}}function a(t,e,o){const r=C(e,o);if(!r){return}s(t,e,o,r)}function i(t,e){const o=F(e);if(!o){return}Tt(it(o),(r=>s(t,e,r,o[r])))}function c(t,e,o){for(const r of it(o)){const n=C(e,r);if(!n||n.get||n.set){continue}const s=`${t}.${m(r)}`;const u=o[r];if(u===true){a(s,e,r)}else if(u==="*"){i(s,n.value)}else if(!Ee(u)){c(s,n.value,u)}else{throw v(`Unexpected override enablement plan ${s}`)}}}let u;switch(e){case"min":{u=_n;break}case"moderate":{u=An;break}case"severe":{u=vn;break}default:{throw v(`unrecognized overrideTaming ${e}`)}}c("root",t,u)}const{Fail:Tn,quote:$n}=Ur;const xn=/^(\w*[a-z])Locale([A-Z]\w*)$/;const On={localeCompare(t){if(this===null||this===undefined){throw v('Cannot localeCompare with null or undefined "this" value')}const e=`${this}`;const o=`${t}`;if(e<o){return-1}if(e>o){return 1}e===o||Tn`expected ${$n(e)} and ${$n(o)} to compare`;return 0},toString(){return`${this}`}};const Nn=On.localeCompare;const Cn=On.toString;function Fn(t,e="safe"){if(e==="unsafe"){return}tt(m.prototype,"localeCompare",{value:Nn});for(const e of k(t)){const o=t[e];if(!Ee(o)){for(const t of k(o)){const e=Xt(xn,t);if(e){typeof o[t]==="function"||Tn`expected ${$n(t)} to be a function`;const r=`${e[1]}${e[2]}`;const n=o[r];typeof n==="function"||Tn`function ${$n(r)} not found`;tt(o,t,{value:n})}}}}tt(u.prototype,"toLocaleString",{value:Cn})}const kn=t=>{const e={eval(e){if(typeof e!=="string"){return e}return t(e)}}.eval;return e};const{Fail:Rn}=Ur;const Mn=t=>{const e=function e(o){const r=`${Ct(arguments)||""}`;const n=`${xt(arguments,",")}`;new ve(n,"");new ve(r);const s=`(function anonymous(${n}\n) {\n${r}\n})`;return t(s)};x(e,{prototype:{value:ve.prototype,writable:false,enumerable:false,configurable:false}});R(ve)===ve.prototype||Rn`Function prototype is the same accross compartments`;R(e)===ve.prototype||Rn`Function constructor prototype is the same across compartments`;return e};const Ln=t=>{tt(t,q,N(T($(null),{set:N((()=>{throw v(`Cannot set Symbol.unscopables of a Compartment's globalThis`)})),enumerable:false,configurable:false})))};const Un=t=>{for(const[e,o]of O(Vr)){tt(t,e,{value:o,writable:false,enumerable:false,configurable:false})}};const Dn=(t,{intrinsics:e,newGlobalPropertyNames:o,makeCompartmentConstructor:r,markVirtualizedNativeFunction:n,parentCompartment:s})=>{for(const[o,r]of O(qr)){if(H(e,r)){tt(t,o,{value:e[r],writable:true,enumerable:false,configurable:true})}}for(const[r,n]of O(o)){if(H(e,n)){tt(t,r,{value:e[n],writable:true,enumerable:false,configurable:true})}}const a={globalThis:t};a.Compartment=N(r(r,e,n,{parentCompartment:s,enforceNew:true}));for(const[e,o]of O(a)){tt(t,e,{value:o,writable:true,enumerable:false,configurable:true});if(typeof o==="function"){n(o)}}};const Bn=(t,e,o)=>{{const r=N(kn(e));o(r);tt(t,"eval",{value:r,writable:true,enumerable:false,configurable:true})}{const r=N(Mn(e));o(r);tt(t,"Function",{value:r,writable:true,enumerable:false,configurable:true})}};const{Fail:jn,quote:Gn}=Ur;const Hn=N({__proto__:null});const Wn=new p(Hn,N({get(t,e){jn`Please report unexpected scope handler trap: ${Gn(m(e))}`}}));const zn={get(t,e){return undefined},set(t,e,o){throw _(`${m(e)} is not defined`)},has(t,e){return true},getPrototypeOf(t){return null},getOwnPropertyDescriptor(t,e){const o=Gn(m(e));console.warn(`getOwnPropertyDescriptor trap on scopeTerminatorHandler for ${o}`,v().stack);return undefined},ownKeys(t){return[]}};const Kn=N($(Wn,F(zn)));const Vn=new p(Hn,Kn);const qn=N({__proto__:null});const Yn=t=>{const e={...Kn,set(e,o,r){return ut(t,o,r)},has(t,e){return true}};const o=N($(Wn,F(e)));const r=new p(qn,o);return r};N(Yn);const{Fail:Jn}=Ur;const Qn=()=>{const t=$(null);const e=N({eval:{get(){delete t.eval;return Ae},enumerable:false,configurable:true}});const o={evalScope:t,allowNextEvalToBeUnsafe(){const{revoked:r}=o;if(r!==null){Jn`a handler did not reset allowNextEvalToBeUnsafe ${r.err}`}x(t,e)},revoked:null};return o};const Xn="\\s*[@#]\\s*([a-zA-Z][a-zA-Z0-9]*)\\s*=\\s*([^\\s\\*]*)";const Zn=new y(`(?:\\s*//${Xn}|/\\*${Xn}\\s*\\*/)\\s*$`);const ts=t=>{let e="<unknown>";while(t.length>0){const o=Xt(Zn,t);if(o===null){break}t=ie(t,0,t.length-o[0].length);if(o[3]==="sourceURL"){e=o[4]}else if(o[1]==="sourceURL"){e=o[2]}}return e};function es(t,e){const o=ae(t,e);if(o<0){return-1}const r=t[o]==="\n"?1:0;return ce(ie(t,0,o),"\n").length+r}const os=new y(`(?:${"<"}!--|--${">"})`,"g");const rs=t=>{const e=es(t,os);if(e<0){return t}const o=ts(t);throw A(`Possible HTML comment rejected at ${o}:${e}. (SES_HTML_COMMENT_REJECTED)`)};const ns=t=>{const e=t=>t[0]==="<"?"< ! --":"-- >";return se(t,os,e)};const ss=new y("(^|[^.]|\\.\\.\\.)\\bimport(\\s*(?:\\(|/[/*]))","g");const as=t=>{const e=es(t,ss);if(e<0){return t}const o=ts(t);throw A(`Possible import expression rejected at ${o}:${e}. (SES_IMPORT_REJECTED)`)};const is=t=>{const e=(t,e,o)=>`${e}__import__${o}`;return se(t,ss,e)};const cs=new y("(^|[^.])\\beval(\\s*\\()","g");const us=t=>{const e=es(t,cs);if(e<0){return t}const o=ts(t);throw A(`Possible direct eval expression rejected at ${o}:${e}. (SES_EVAL_REJECTED)`)};const ls=t=>{t=rs(t);t=as(t);return t};const fs=(t,e)=>{for(let o=0,r=e.length;o<r;o+=1){const r=e[o];t=r(t)}return t};N({rejectHtmlComments:N(rs),evadeHtmlCommentTest:N(ns),rejectImportExpressions:N(as),evadeImportExpressionTest:N(is),rejectSomeDirectEvalExpressions:N(us),mandatoryTransforms:N(ls),applyTransforms:N(fs)});const ps=["await","break","case","catch","class","const","continue","debugger","default","delete","do","else","export","extends","finally","for","function","if","import","in","instanceof","new","return","super","switch","this","throw","try","typeof","var","void","while","with","yield","let","static","enum","implements","package","protected","interface","private","public","await","null","true","false","this","arguments"];const ds=/^[a-zA-Z_$][\w$]*$/;const ys=t=>t!=="eval"&&!$t(ps,t)&&Qt(ds,t);function gs(t,e){const o=C(t,e);return o&&o.configurable===false&&o.writable===false&&H(o,"value")}const ms=(t,e={})=>{const o=k(t);const r=k(e);const n=It(r,(t=>ys(t)&&gs(e,t)));const s=It(o,(e=>!$t(r,e)&&ys(e)&&gs(t,e)));return{globalObjectConstants:s,moduleLexicalConstants:n}};function bs(t,e){if(t.length===0)return"";return`const {${xt(t,",")}} = this.${e};`}const hs=t=>{const{globalObjectConstants:e,moduleLexicalConstants:o}=ms(t.globalObject,t.moduleLexicals);const r=bs(e,"globalObject");const n=bs(o,"moduleLexicals");const s=ve(`\n    with (this.scopeTerminator) {\n      with (this.globalObject) {\n        with (this.moduleLexicals) {\n          with (this.evalScope) {\n            ${r}\n            ${n}\n            return function() {\n              'use strict';\n              return eval(arguments[0]);\n            };\n          }\n        }\n      }\n    }\n  `);return et(s,t,[])};const{Fail:Ss}=Ur;const Ps=({globalObject:t,moduleLexicals:e={},globalTransforms:o=[],sloppyGlobalsMode:r=false})=>{const n=r?Yn(t):Vn;const s=Qn();const{evalScope:a}=s;const i=N({evalScope:a,moduleLexicals:e,globalObject:t,scopeTerminator:n});let c;const u=()=>{if(!c){c=hs(i)}};const l=(e,r)=>{const{localTransforms:n=[]}=r||{};u();e=fs(e,Nt([n,o,[ls]],_e));let i;try{s.allowNextEvalToBeUnsafe();return et(c,t,[e])}catch(t){i=t;throw t}finally{const t="eval"in a;delete a.eval;if(t){s.revoked={err:i};Ss`handler did not reset allowNextEvalToBeUnsafe ${i}`}}};return{safeEvaluate:l}};const Es=") { [native code] }";let ws;const _s=()=>{if(ws===undefined){const t=new P;const e={toString(){const e=be(this);if(te(e,Es)||!me(t,this)){return e}return`function ${this.name}() { [native code] }`}};tt(St,"toString",{value:e.toString});ws=N((e=>ge(t,e)))}return ws};function As(e="safe"){if(e==="unsafe"){return}const o=t.process||undefined;if(typeof o==="object"){const t=C(o,"domain");if(t!==undefined&&t.get!==undefined){throw v(`SES failed to lockdown, Node.js domains have been initialized (SES_NO_DOMAINS)`)}tt(o,"domain",{value:null,configurable:false,writable:false,enumerable:false})}}const vs=()=>{const e={};const o=t.ModuleSource;if(o!==undefined){e.ModuleSource=o;function r(){}const n=R(o);if(n===St){B(o,r);e["%AbstractModuleSource%"]=r;e["%AbstractModuleSourcePrototype%"]=r.prototype}else{e["%AbstractModuleSource%"]=n;e["%AbstractModuleSourcePrototype%"]=n.prototype}const s=o.prototype;if(s!==undefined){e["%ModuleSourcePrototype%"]=s;const a=R(s);if(a===U){B(o.prototype,r.prototype)}}}return e};const Is=(t,e)=>tt(e,"name",{value:t});const Ts=N([["debug","debug"],["log","log"],["info","info"],["warn","warn"],["error","error"],["trace","log"],["dirxml","log"],["group","log"],["groupCollapsed","log"]]);const $s=N([["assert","error"],["timeLog","log"],["clear",undefined],["count","info"],["countReset",undefined],["dir","log"],["groupEnd","log"],["table","log"],["time","info"],["timeEnd","info"],["profile",undefined],["profileEnd",undefined],["timeStamp",undefined]]);const xs={NOTE:"ERROR_NOTE:",MESSAGE:"ERROR_MESSAGE:",CAUSE:"cause:",ERRORS:"errors:"};N(xs);const Os=(t,e)=>{if(!t){return undefined}const{getStackString:o,tagError:r,takeMessageLogArgs:n,takeNoteLogArgsArray:s}=e;const a=(t,e)=>{const o=Ot(t,(t=>{if(we(t)){Ft(e,t);return`(${r(t)})`}return t}));return o};const i=(e,o,n,s,i)=>{const c=r(o);const u=n===xs.MESSAGE?`${c}:`:`${c} ${n}`;const l=a(s,i);t[e](u,...l)};const c=(e,o,r=undefined)=>{if(o.length===0){return}if(o.length===1&&r===undefined){f(e,o[0]);return}let n;if(o.length===1){n=`Nested error`}else{n=`Nested ${o.length} errors`}if(r!==undefined){n=`${n} under ${r}`}t.group(n);try{for(const t of o){f(e,t)}}finally{if(t.groupEnd){t.groupEnd()}}};const u=new P;const l=t=>(e,o)=>{const n=[];i(t,e,xs.NOTE,o,n);c(t,n,r(e))};const f=(e,a)=>{if(me(u,a)){return}const f=r(a);ge(u,a);const p=[];const d=n(a);const y=s(a,l(e));if(d===undefined){t[e](`${f}:`,a.message)}else{i(e,a,xs.MESSAGE,d,p)}let g=o(a);if(typeof g==="string"&&g.length>=1&&!te(g,"\n")){g+="\n"}t[e](g);if(a.cause){i(e,a,xs.CAUSE,[a.cause],p)}if(a.errors){i(e,a,xs.ERRORS,a.errors,p)}for(const t of y){i(e,a,xs.NOTE,t,p)}c(e,p,f)};const p=Ot(Ts,(([e,o])=>{const r=Is(e,((...o)=>{const r=[];const n=a(o,r);if(t[e]){t[e](...n)}c(e,r)}));return[e,N(r)]}));const d=It($s,(([e,o])=>e in t));const y=Ot(d,(([e,o])=>{const r=Is(e,((...o)=>{t[e](...o);return undefined}));return[e,N(r)]}));const g=G([...p,...y]);return N(g)};N(Os);const Ns=(t,e,o)=>{const[r,...n]=ce(t,e);const s=Nt(n,(t=>[e,...o,t]));return["",r,...s]};const Cs=t=>{const e=e=>{const o=[];const r=(...t)=>{if(o.length>0){t=Nt(t,(t=>typeof t==="string"&&ee(t,"\n")?Ns(t,"\n",o):[t]));t=[...o,...t]}return e(...t)};const n=G([...Ot(Ts,(([t])=>[t,Is(t,((...t)=>r(...t)))])),...Ot($s,(([t])=>[t,Is(t,((...e)=>r(t,...e)))]))]);for(const t of["group","groupCollapsed"]){if(n[t]){n[t]=Is(t,((...t)=>{if(t.length>=1){r(...t)}Ft(o," ")}))}else{n[t]=Is(t,(()=>{}))}}n.groupEnd=Is("groupEnd",n.groupEnd?(...t)=>{Ct(o)}:()=>{});harden(n);const s=Os(n,t);return s};return N(e)};N(Cs);const Fs=t=>{if(n===undefined){return undefined}let e=0;const o=new i;const r=t=>{Wt(o,t)};const s=new S;const a=e=>{if(Ht(o,e)){const n=Gt(o,e);r(e);t(n)}};const c=new n(a);const u=(t,r)=>{e+=1;const n=e;jt(o,n,t);ye(s,r,n);Pe(c,r,n,r)};const l=t=>{const e=pe(s,t);r(e)};const f=()=>{for(const[e,n]of zt(o)){r(e);t(n)}};return{rejectionHandledHandler:l,unhandledRejectionHandler:u,processTerminationHandler:f}};const ks=t=>{throw v(t)};const Rs=(t,e)=>N(((...o)=>et(t,e,o)));const Ms=(e="safe",o="platform",r="report",n=undefined)=>{let s;if(n===undefined){s=Mr}else{s={...Mr,getStackString:n}}const a=typeof t.console!=="undefined"?t.console:typeof t.print==="function"?(t=>N({debug:t,log:t,info:t,warn:t,error:t}))(Rs(t.print)):undefined;if(a&&a.log){for(const t of["warn","error"]){if(!a[t]){tt(a,t,{value:Rs(a.log,a)})}}}const i=e==="unsafe"?a:Os(a,s);const c=t.process||undefined;if(o!=="none"&&typeof c==="object"&&typeof c.on==="function"){let t;if(o==="platform"||o==="exit"){const{exit:e}=c;typeof e==="function"||ks("missing process.exit");t=()=>e(c.exitCode||-1)}else if(o==="abort"){t=c.abort;typeof t==="function"||ks("missing process.abort")}c.on("uncaughtException",(e=>{i.error("SES_UNCAUGHT_EXCEPTION:",e);if(t){t()}}))}if(r!=="none"&&typeof c==="object"&&typeof c.on==="function"){const t=t=>{i.error("SES_UNHANDLED_REJECTION:",t)};const e=Fs(t);if(e){c.on("unhandledRejection",e.unhandledRejectionHandler);c.on("rejectionHandled",e.rejectionHandledHandler);c.on("exit",e.processTerminationHandler)}}const u=t.window||undefined;if(o!=="none"&&typeof u==="object"&&typeof u.addEventListener==="function"){u.addEventListener("error",(t=>{t.preventDefault();i.error("SES_UNCAUGHT_EXCEPTION:",t.error);if(o==="exit"||o==="abort"){u.location.href=`about:blank`}}))}if(r!=="none"&&typeof u==="object"&&typeof u.addEventListener==="function"){const t=t=>{i.error("SES_UNHANDLED_REJECTION:",t)};const e=Fs(t);if(e){u.addEventListener("unhandledrejection",(t=>{t.preventDefault();e.unhandledRejectionHandler(t.reason,t.promise)}));u.addEventListener("rejectionhandled",(t=>{t.preventDefault();e.rejectionHandledHandler(t.promise)}));u.addEventListener("beforeunload",(t=>{e.processTerminationHandler()}))}}return{console:i}};const Ls=["getTypeName","getFunctionName","getMethodName","getFileName","getLineNumber","getColumnNumber","getEvalOrigin","isToplevel","isEval","isNative","isConstructor","isAsync","getPosition","getScriptNameOrSourceURL","toString"];const Us=t=>{const e=e=>{const o=t[e];return[e,()=>et(o,t,[])]};const o=G(Ot(Ls,e));return $(o,{})};const Ds=t=>Ot(t,Us);const Bs=/\/node_modules\//;const js=/^(?:node:)?internal\//;const Gs=/\/packages\/ses\/src\/error\/assert\.js$/;const Hs=/\/packages\/eventual-send\/src\//;const Ws=/\/packages\/ses-ava\/src\/ses-ava-test\.js$/;const zs=[Bs,js,Gs,Hs,Ws];const Ks=t=>{if(!t){return true}for(const e of zs){if(Qt(e,t)){return false}}return true};const Vs=/^((?:.*[( ])?)[:/\w_-]*\/\.\.\.\/(.+)$/;const qs=/^((?:.*[( ])?)\.\.\.\/(.+)$/;const Ys=/^((?:.*[( ])?)[:/\w_-]*\/(packages\/.+)$/;const Js=/^((?:.*[( ])?)file:\/\/([^/].*)$/;const Qs=[Vs,qs,Ys,Js];const Xs=t=>{for(const e of Qs){const o=Xt(e,t);if(o){return xt(kt(o,1),"")}}return t};const Zs=(t,e,o,r)=>{if(o==="unsafe-debug"){throw v("internal: v8+unsafe-debug special case should already be done")}const n=t.captureStackTrace;const s=r==="concise"||r==="omit-frames";const a=r==="concise"||r==="shorten-paths";const i=t=>{if(s){return Ks(t.getFileName())}return true};const c=t=>{let e=`${t}`;if(a){e=Xs(e)}return`\n  at ${e}`};const u=(t,e)=>xt(Ot(It(e,i),c),"");const l=new S;const f={captureStackTrace(e,o=f.captureStackTrace){if(typeof n==="function"){et(n,t,[e,o]);return}ut(e,"stack","")},getStackString(t){let e=pe(l,t);if(e===undefined){e=pe(l,t);if(!e){e={stackString:""};ye(l,t,e)}}if(e.stackString!==undefined){return e.stackString}const o=u(t,e.callSites);ye(l,t,{stackString:o});return o},prepareStackTrace(t,e){if(o==="unsafe"){const o=u(t,e);ye(l,t,{stackString:o});return`${t}${o}`}else{ye(l,t,{callSites:e});return""}}};const p=f.prepareStackTrace;t.prepareStackTrace=p;const d=new P([p]);const y=t=>{if(me(d,t)){return t}const e={prepareStackTrace(e,o){ye(l,e,{callSites:o});return t(e,Ds(o))}};ge(d,e.prepareStackTrace);return e.prepareStackTrace};x(e,{captureStackTrace:{value:f.captureStackTrace,writable:true,enumerable:false,configurable:true},prepareStackTrace:{get(){return t.prepareStackTrace},set(e){if(typeof e==="function"){const o=y(e);t.prepareStackTrace=o}else{t.prepareStackTrace=p}},enumerable:false,configurable:true}});return f.getStackString};const ta=C(E.prototype,"stack");const ea=ta&&ta.get;const oa={getStackString(t){if(typeof ea==="function"){return et(ea,t,[])}else if("stack"in t){return`${t.stack}`}return""}};let ra=oa.getStackString;function na(t="safe",e="concise"){const o=E.prototype;const{captureStackTrace:r}=E;const n=typeof r==="function"?"v8":"unknown";const s=(t={})=>{const e=function t(...o){let s;if(new.target===undefined){s=et(E,this,o)}else{s=ot(E,o,new.target)}if(n==="v8"){et(r,E,[s,e])}return s};x(e,{length:{value:1},prototype:{value:o,writable:false,enumerable:false,configurable:false}});return e};const a=s({});const i=s({});x(o,{constructor:{value:i}});for(const t of Qr){B(t,i)}x(a,{stackTraceLimit:{get(){if(typeof E.stackTraceLimit==="number"){return E.stackTraceLimit}return undefined},set(t){if(typeof t!=="number"){return}if(typeof E.stackTraceLimit==="number"){E.stackTraceLimit=t;return}},enumerable:false,configurable:true}});if(t==="unsafe-debug"&&n==="v8"){x(a,{prepareStackTrace:{get(){return E.prepareStackTrace},set(t){E.prepareStackTrace=t},enumerable:false,configurable:true},captureStackTrace:{value:E.captureStackTrace,writable:true,enumerable:false,configurable:true}});const t=F(a);x(i,{stackTraceLimit:t.stackTraceLimit,prepareStackTrace:t.prepareStackTrace,captureStackTrace:t.captureStackTrace});return{"%InitialGetStackString%":ra,"%InitialError%":a,"%SharedError%":i}}x(i,{stackTraceLimit:{get(){return undefined},set(t){},enumerable:false,configurable:true}});if(n==="v8"){x(i,{prepareStackTrace:{get(){return()=>""},set(t){},enumerable:false,configurable:true},captureStackTrace:{value:(t,e)=>{tt(t,"stack",{value:""})},writable:false,enumerable:false,configurable:true}})}if(n==="v8"){ra=Zs(E,a,t,e)}else if(t==="unsafe"||t==="unsafe-debug"){x(o,{stack:{get(){return ra(this)},set(t){x(this,{stack:{value:t,writable:true,enumerable:true,configurable:true}})}}})}else{x(o,{stack:{get(){return`${this}`},set(t){x(this,{stack:{value:t,writable:true,enumerable:true,configurable:true}})}}})}return{"%InitialGetStackString%":ra,"%InitialError%":a,"%SharedError%":i}}const sa=()=>{};const aa=async(t,e,o)=>{await null;const r=t(...e);let n=re(r);while(!n.done){try{const t=await n.value;n=re(r,t)}catch(t){n=ne(r,o(t))}}return n.value};const ia=(t,e)=>{const o=t(...e);let r=re(o);while(!r.done){try{r=re(o,r.value)}catch(t){r=ne(o,t)}}return r.value};const ca=(t,e)=>N({compartment:t,specifier:e});const ua=(t,e,o)=>{const r=$(null);for(const n of t){const t=e(n,o);r[n]=t}return N(r)};const la=(t,e,o,r,n,s,a,i,c)=>{const{resolveHook:u,name:l}=pe(t,o);const{imports:f}=n;if(!lt(f)||Rt(f,(t=>typeof t!=="string"))){throw Or(wr`Invalid module source: 'imports' must be an array of strings, got ${f} for module ${mr(r)} of compartment ${mr(l)}`)}const p=ua(f,u,r);const d=N({compartment:o,moduleSource:n,moduleSpecifier:r,resolvedImports:p,importMeta:c});for(const r of j(p)){s(pa,[t,e,o,r,s,a,i])}return d};function*fa(t,e,o,r,n,s,a){const{importHook:i,importNowHook:c,moduleMap:u,moduleMapHook:l,moduleRecords:f,parentCompartment:p}=pe(t,o);if(Ht(f,r)){return Gt(f,r)}let d=u[r];if(d===undefined&&l!==undefined){d=l(r)}if(d===undefined){const t=s(i,c);if(t===undefined){const t=s("importHook","importNowHook");throw Or(wr`${hr(t)} needed to load module ${mr(r)} in compartment ${mr(o.name)}`)}d=t(r);if(!de(e,d)){d=yield d}}if(typeof d==="string"){throw Or(wr`Cannot map module ${mr(r)} to ${mr(d)} in parent compartment, use {source} module descriptor`,v)}else if(!Ee(d)){let i=pe(e,d);if(i!==undefined){d=i}if(d.namespace!==undefined){if(typeof d.namespace==="string"){const{compartment:i=p,namespace:c}=d;if(Ee(i)||!de(t,i)){throw Or(wr`Invalid compartment in module descriptor for specifier ${mr(r)} in compartment ${mr(o.name)}`)}const u=yield pa(t,e,i,c,n,s,a);jt(f,r,u);return u}if(!Ee(d.namespace)){const{namespace:c}=d;i=pe(e,c);if(i!==undefined){d=i}else{const i=k(c);const u={imports:[],exports:i,execute(t){for(const e of i){t[e]=c[e]}}};const l=undefined;const p=la(t,e,o,r,u,n,s,a,l);jt(f,r,p);return p}}else{throw Or(wr`Invalid compartment in module descriptor for specifier ${mr(r)} in compartment ${mr(o.name)}`)}}if(d.source!==undefined){if(typeof d.source==="string"){const{source:i,specifier:c=r,compartment:u=p,importMeta:l=undefined}=d;const y=yield pa(t,e,u,i,n,s,a);const{moduleSource:g}=y;const m=la(t,e,o,c,g,n,s,a,l);jt(f,r,m);return m}else{const{source:i,specifier:c=r,importMeta:u}=d;const l=la(t,e,o,c,i,n,s,a,u);jt(f,r,l);return l}}if(d.archive!==undefined){throw Or(wr`Unsupported archive module descriptor for specifier ${mr(r)} in compartment ${mr(o.name)}`)}if(d.record!==undefined){const{compartment:i=o,specifier:c=r,record:u,importMeta:l}=d;const p=la(t,e,i,c,u,n,s,a,l);jt(f,r,p);jt(f,c,p);return p}if(d.compartment!==undefined&&d.specifier!==undefined){if(Ee(d.compartment)||!de(t,d.compartment)||typeof d.specifier!=="string"){throw Or(wr`Invalid compartment in module descriptor for specifier ${mr(r)} in compartment ${mr(o.name)}`)}const i=yield pa(t,e,d.compartment,d.specifier,n,s,a);jt(f,r,i);return i}const c=d;const u=la(t,e,o,r,c,n,s,a);jt(f,r,u);return u}else{throw Or(wr`module descriptor must be a string or object for specifier ${mr(r)} in compartment ${mr(o.name)}`)}}const pa=(t,e,o,r,n,s,a)=>{const{name:c}=pe(t,o);let u=Gt(a,o);if(u===undefined){u=new i;jt(a,o,u)}let l=Gt(u,r);if(l!==undefined){return l}l=s(aa,ia)(fa,[t,e,o,r,n,s,a],(t=>{kr(t,wr`${t.message}, loading ${mr(r)} in compartment ${mr(c)}`);throw t}));jt(u,r,l);return l};const da=({errors:t=[],noAggregateErrors:e=false}={})=>{const o=new g;const r=(r,n)=>{Vt(o,Se(r(...n),sa,(o=>{if(e){throw o}else{Ft(t,o)}})))};const n=async()=>{await null;for(const t of o){await t}};return{enqueueJob:r,drainQueue:n,errors:t}};const ya=({errors:t=[],noAggregateErrors:e=false}={})=>{let o=[];let r=[];const n=(t,e)=>{Ft(r,[t,e])};const s=()=>{for(const[r,n]of o){try{r(...n)}catch(o){if(e){throw o}else{Ft(t,o)}}}o=r;r=[];if(o.length>0)s()};return{enqueueJob:n,drainQueue:s,errors:t}};const ga=({errors:t,errorPrefix:e})=>{if(t.length>0){const o=Xe("COMPARTMENT_LOAD_ERRORS","",["verbose"])==="verbose";throw v(`${e} (${t.length} underlying failures: ${xt(Ot(t,(t=>t.message+(o?t.stack:""))),", ")}`)}};const ma=(t,e)=>e;const ba=(t,e)=>t;const ha=async(t,e,o,r,{noAggregateErrors:n=false}={})=>{const{name:s}=pe(t,o);const a=new i;const{enqueueJob:c,drainQueue:u,errors:l}=da({noAggregateErrors:n});c(pa,[t,e,o,r,c,ba,a]);await u();ga({errors:l,errorPrefix:`Failed to load module ${mr(r)} in package ${mr(s)}`})};const Sa=(t,e,o,r,{noAggregateErrors:n=false}={})=>{const{name:s}=pe(t,o);const a=new i;const{enqueueJob:c,drainQueue:u,errors:l}=ya({noAggregateErrors:n});c(pa,[t,e,o,r,c,ma,a]);u();ga({errors:l,errorPrefix:`Failed to load module ${mr(r)} in package ${mr(s)}`})};const{quote:Pa}=Ur;const Ea=()=>{let t=false;const e=$(null,{[z]:{value:"Module",writable:false,enumerable:false,configurable:false}});return N({activate(){t=true},exportsTarget:e,exportsProxy:new p(e,{get(o,r,n){if(!t){throw v(`Cannot get property ${Pa(r)} of module exports namespace, the module has not yet begun to execute`)}return rt(e,r,n)},set(t,e,o){throw v(`Cannot set property ${Pa(e)} of module exports namespace`)},has(o,r){if(!t){throw v(`Cannot check property ${Pa(r)}, the module has not yet begun to execute`)}return st(e,r)},deleteProperty(t,e){throw v(`Cannot delete property ${Pa(e)}s of module exports namespace`)},ownKeys(o){if(!t){throw v("Cannot enumerate keys, the module has not yet begun to execute")}return it(e)},getOwnPropertyDescriptor(o,r){if(!t){throw v(`Cannot get own property descriptor ${Pa(r)}, the module has not yet begun to execute`)}return nt(e,r)},preventExtensions(o){if(!t){throw v("Cannot prevent extensions of module exports namespace, the module has not yet begun to execute")}return ct(e)},isExtensible(){if(!t){throw v("Cannot check extensibility of module exports namespace, the module has not yet begun to execute")}return at(e)},getPrototypeOf(t){return null},setPrototypeOf(t,e){throw v("Cannot set prototype of module exports namespace")},defineProperty(t,e,o){throw v(`Cannot define property ${Pa(e)} of module exports namespace`)},apply(t,e,o){throw v("Cannot call module exports namespace, it is not a function")},construct(t,e){throw v("Cannot construct module exports namespace, it is not a constructor")}})})};const wa=(t,e,o,r)=>{const{deferredExports:n}=e;if(!Ht(n,r)){const e=Ea();ye(o,e.exportsProxy,ca(t,r));jt(n,r,e)}return Gt(n,r)};const _a=(t,e)=>{const{sloppyGlobalsMode:o=false,__moduleShimLexicals__:r=undefined}=e;let n;if(r===undefined&&!o){({safeEvaluate:n}=t)}else{let{globalTransforms:e}=t;const{globalObject:s}=t;let a;if(r!==undefined){e=undefined;a=$(null,F(r))}({safeEvaluate:n}=Ps({globalObject:s,moduleLexicals:a,globalTransforms:e,sloppyGlobalsMode:o}))}return{safeEvaluate:n}};const Aa=(t,e,o)=>{if(typeof e!=="string"){throw v("first argument of evaluate() must be a string")}const{transforms:r=[],__evadeHtmlCommentTest__:n=false,__evadeImportExpressionTest__:s=false,__rejectSomeDirectEvalExpressions__:a=true}=o;const i=[...r];if(n===true){Ft(i,ns)}if(s===true){Ft(i,is)}if(a===true){Ft(i,us)}const{safeEvaluate:c}=_a(t,o);return c(e,{localTransforms:i})};const{quote:va}=Ur;const Ia=(t,e,o,r,n,s)=>{const{exportsProxy:a,exportsTarget:i,activate:c}=wa(o,pe(t,o),r,n);const u=$(null);if(e.exports){if(!lt(e.exports)||Rt(e.exports,(t=>typeof t!=="string"))){throw v(`SES virtual module source "exports" property must be an array of strings for module ${n}`)}Tt(e.exports,(t=>{let e=i[t];const o=[];const r=()=>e;const n=t=>{e=t;for(const e of o){e(t)}};tt(i,t,{get:r,set:n,enumerable:true,configurable:false});u[t]=t=>{Ft(o,t);t(e)}}));u["*"]=t=>{t(i)}}const l={activated:false};return N({notifiers:u,exportsProxy:a,execute(){if(st(l,"errorFromExecute")){throw l.errorFromExecute}if(!l.activated){c();l.activated=true;try{e.execute(i,o,s)}catch(t){l.errorFromExecute=t;throw t}}}})};const Ta=(t,e,o,r)=>{const{compartment:n,moduleSpecifier:s,moduleSource:a,importMeta:i}=o;const{reexports:c=[],__syncModuleProgram__:u,__fixedExportMap__:l={},__liveExportMap__:f={},__reexportMap__:p={},__needsImport__:d=false,__needsImportMeta__:y=false,__syncModuleFunctor__:g}=a;const m=pe(t,n);const{__shimTransforms__:b,resolveHook:h,importMetaHook:S,compartmentImport:P}=m;const{exportsProxy:E,exportsTarget:w,activate:I}=wa(n,m,e,s);const x=$(null);const C=$(null);const F=$(null);const k=$(null);const R=$(null);if(i){T(R,i)}if(y&&S){S(s,R)}let M;if(d){M=async t=>P(h(t,s))}const U=$(null);const D=$(null);Tt(O(l),(([t,[e]])=>{let o=U[e];if(!o){let t;let r=true;let n=[];const s=()=>{if(r){throw _(`binding ${va(e)} not yet initialized`)}return t};const a=N((o=>{if(!r){throw v(`Internal: binding ${va(e)} already initialized`)}t=o;const s=n;n=null;r=false;for(const t of s||[]){t(o)}return o}));const i=e=>{if(e===a){return}if(r){Ft(n||[],e)}else{e(t)}};o={get:s,notify:i};U[e]=o;F[e]=a}x[t]={get:o.get,set:undefined,enumerable:true,configurable:false};D[t]=o.notify}));Tt(O(f),(([t,[e,o]])=>{let r=U[e];if(!r){let n;let s=true;const a=[];const i=()=>{if(s){throw _(`binding ${va(t)} not yet initialized`)}return n};const c=N((t=>{n=t;s=false;for(const e of a){e(t)}}));const u=t=>{if(s){throw _(`binding ${va(e)} not yet initialized`)}n=t;for(const e of a){e(t)}};const l=t=>{if(t===c){return}Ft(a,t);if(!s){t(n)}};r={get:i,notify:l};U[e]=r;if(o){tt(C,e,{get:i,set:u,enumerable:true,configurable:false})}k[e]=c}x[t]={get:r.get,set:undefined,enumerable:true,configurable:false};D[t]=r.notify}));const B=t=>{t(w)};D["*"]=B;function j(t){const e=$(null);e.default=false;for(const[o,n]of t){const t=Gt(r,o);t.execute();const{notifiers:s}=t;for(const[t,e]of n){const r=s[t];if(!r){throw A(`The requested module '${o}' does not provide an export named '${t}'`)}for(const t of e){r(t)}}if($t(c,o)){for(const[t,o]of O(s)){if(e[t]===undefined){e[t]=o}else{e[t]=false}}}if(p[o]){for(const[t,r]of p[o]){e[r]=s[t]}}}for(const[t,o]of O(e)){if(!D[t]&&o!==false){D[t]=o;let e;const r=t=>e=t;o(r);x[t]={get(){return e},set:undefined,enumerable:true,configurable:false}}}Tt(Mt(L(x)),(t=>tt(w,t,x[t])));N(w);I()}let G;if(g!==undefined){G=g}else{G=Aa(m,u,{transforms:b,__moduleShimLexicals__:C})}let H=false;let W;function z(){if(G){const t=G;G=null;try{t(N({imports:N(j),onceVar:N(F),liveVar:N(k),import:M,importMeta:R}))}catch(t){H=true;W=t}}if(H){throw W}}return N({notifiers:D,exportsProxy:E,execute:z})};const{Fail:$a,quote:xa}=Ur;const Oa=(t,e,o,r)=>{const{name:n,moduleRecords:s}=pe(t,o);const a=Gt(s,r);if(a===undefined){throw _(`Missing link to module ${xa(r)} from compartment ${xa(n)}`)}return Ma(t,e,a)};function Na(t){return typeof t.__syncModuleProgram__==="string"}function Ca(t,e){const{__fixedExportMap__:o,__liveExportMap__:r}=t;!Ee(o)||$a`Property '__fixedExportMap__' of a precompiled module source must be an object, got ${xa(o)}, for module ${xa(e)}`;!Ee(r)||$a`Property '__liveExportMap__' of a precompiled module source must be an object, got ${xa(r)}, for module ${xa(e)}`}function Fa(t){return typeof t.execute==="function"}function ka(t,e){const{exports:o}=t;lt(o)||$a`Invalid module source: 'exports' of a virtual module source must be an array, got ${xa(o)}, for module ${xa(e)}`}function Ra(t,e){!Ee(t)||$a`Invalid module source: must be of type object, got ${xa(t)}, for module ${xa(e)}`;const{imports:o,exports:r,reexports:n=[]}=t;lt(o)||$a`Invalid module source: 'imports' must be an array, got ${xa(o)}, for module ${xa(e)}`;lt(r)||$a`Invalid module source: 'exports' must be an array, got ${xa(r)}, for module ${xa(e)}`;lt(n)||$a`Invalid module source: 'reexports' must be an array if present, got ${xa(n)}, for module ${xa(e)}`}const Ma=(t,e,o)=>{const{compartment:r,moduleSpecifier:n,resolvedImports:s,moduleSource:a}=o;const{instances:c}=pe(t,r);if(Ht(c,n)){return Gt(c,n)}Ra(a,n);const u=new i;let l;if(Na(a)){Ca(a,n);l=Ta(t,e,o,u)}else if(Fa(a)){ka(a,n);l=Ia(t,a,r,e,n,s)}else{throw v(`Invalid module source, got ${xa(a)}`)}jt(c,n,l);for(const[o,n]of O(s)){const s=Oa(t,e,r,n);jt(u,o,s)}return l};const La=new S;const Ua=new S;const Da=function t(e={},o={},r={}){throw v("Compartment.prototype.constructor is not a valid constructor.")};const Ba=(t,e)=>{const{execute:o,exportsProxy:r}=Oa(Ua,La,t,e);o();return r};const ja={constructor:Da,get globalThis(){return pe(Ua,this).globalObject},get name(){return pe(Ua,this).name},evaluate(t,e={}){const o=pe(Ua,this);return Aa(o,t,e)},module(t){if(typeof t!=="string"){throw v("first argument of module() must be a string")}const{exportsProxy:e}=wa(this,pe(Ua,this),La,t);return e},async import(t){const{noNamespaceBox:e,noAggregateLoadErrors:o}=pe(Ua,this);if(typeof t!=="string"){throw v("first argument of import() must be a string")}return Se(ha(Ua,La,this,t,{noAggregateErrors:o}),(()=>{const o=Ba(this,t);if(e){return o}return{namespace:o}}))},async load(t){if(typeof t!=="string"){throw v("first argument of load() must be a string")}const{noAggregateLoadErrors:e}=pe(Ua,this);return ha(Ua,La,this,t,{noAggregateErrors:e})},importNow(t){if(typeof t!=="string"){throw v("first argument of importNow() must be a string")}const{noAggregateLoadErrors:e}=pe(Ua,this);Sa(Ua,La,this,t,{noAggregateErrors:e});return Ba(this,t)}};x(ja,{[z]:{value:"Compartment",writable:false,enumerable:false,configurable:true}});x(Da,{prototype:{value:ja}});const Ga=(...t)=>{if(t.length===0){return{}}if(t.length===1&&typeof t[0]==="object"&&t[0]!==null&&"__options__"in t[0]){const{__options__:e,...o}=t[0];Ur(e===true,`Compartment constructor only supports true __options__ sigil, got ${e}`);return o}else{const[e={},o={},r={}]=t;Dr(r.modules,undefined,`Compartment constructor must receive either a module map argument or modules option, not both`);Dr(r.globals,undefined,`Compartment constructor must receive either globals argument or option, not both`);return{...r,globals:e,modules:o}}};const Ha=(t,e,o,{parentCompartment:r=undefined,enforceNew:n=false}={})=>{function s(...s){if(n&&new.target===undefined){throw v("Class constructor Compartment cannot be invoked without 'new'")}const{name:a="<unknown>",transforms:c=[],__shimTransforms__:u=[],globals:l={},modules:f={},resolveHook:p,importHook:d,importNowHook:y,moduleMapHook:g,importMetaHook:m,__noNamespaceBox__:b=false,noAggregateLoadErrors:h=false}=Ga(...s);const S=Nt([c,u],_e);const P={__proto__:null,...l};const E={__proto__:null,...f};const w=new i;const _=new i;const A=new i;const I={};const $=this;Ln(I);Un(I);const{safeEvaluate:x}=Ps({globalObject:I,globalTransforms:S,sloppyGlobalsMode:false});Dn(I,{intrinsics:e,newGlobalPropertyNames:Jr,makeCompartmentConstructor:t,parentCompartment:this,markVirtualizedNativeFunction:o});Bn(I,x,o);T(I,P);const O=async t=>{if(typeof p!=="function"){throw v(`Compartment does not support dynamic import: no configured resolveHook for compartment ${mr(a)}`)}await ha(Ua,La,$,t,{noAggregateErrors:h});const{execute:e,exportsProxy:o}=Oa(Ua,La,$,t);e();return o};ye(Ua,this,{name:`${a}`,globalTransforms:S,globalObject:I,safeEvaluate:x,resolveHook:p,importHook:d,importNowHook:y,moduleMap:E,moduleMapHook:g,importMetaHook:m,moduleRecords:w,__shimTransforms__:u,deferredExports:A,instances:_,parentCompartment:r,noNamespaceBox:b,compartmentImport:O,noAggregateLoadErrors:h})}s.prototype=ja;return s};function Wa(t){return R(t).constructor}function za(){return arguments}const Ka=()=>{const e=ve.prototype.constructor;const r=C(za(),"callee");const n=r&&r.get;const a=le(new m);const c=R(a);const u=yt[V]&&Zt(/./);const l=u&&R(u);const f=Lt([]);const p=R(f);const d=R(s);const y=Kt(new i);const b=R(y);const h=Jt(new g);const S=R(h);const P=R(p);function*E(){}const w=Wa(E);const _=w.prototype;async function A(){}const v=Wa(A);const I={"%InertFunction%":e,"%ArrayIteratorPrototype%":p,"%InertAsyncFunction%":v,"%Generator%":_,"%InertGeneratorFunction%":w,"%IteratorPrototype%":P,"%MapIteratorPrototype%":b,"%RegExpStringIteratorPrototype%":l,"%SetIteratorPrototype%":S,"%StringIteratorPrototype%":c,"%ThrowTypeError%":n,"%TypedArray%":d,"%InertCompartment%":Da};if(ke!==undefined){const t=Wa(ke);const e=t.prototype;const o=e.prototype;const r=R(o);T(I,{"%AsyncGenerator%":e,"%InertAsyncGeneratorFunction%":t,"%AsyncGeneratorPrototype%":o,"%AsyncIteratorPrototype%":r})}if(t.Iterator){I["%IteratorHelperPrototype%"]=R(t.Iterator.from([]).take(0));I["%WrapForValidIteratorPrototype%"]=R(t.Iterator.from({next(){return{value:undefined}}}))}if(t.AsyncIterator){I["%AsyncIteratorHelperPrototype%"]=R(t.AsyncIterator.from([]).take(0));I["%WrapForValidAsyncIteratorPrototype%"]=R(t.AsyncIterator.from({next(){}}))}const $=new o(0);const x=$.sliceToImmutable();const O=R(x);if(O!==o.prototype){I["%ImmutableArrayBufferPrototype%"]=O}return I};const Va=(t,e)=>{if(e==="safe"){return t}Object.isExtensible=()=>false;Object.isFrozen=()=>true;Object.isSealed=()=>true;Reflect.isExtensible=()=>false;if(t.isFake){return t}const o=t=>t;o.isFake=true;return N(o)};N(Va);const qa=()=>{const t=b;const e=t.prototype;const o=he(b,undefined);x(e,{constructor:{value:o}});const r=O(F(t));const n=G(Ot(r,(([t,e])=>[t,{...e,configurable:true}])));x(o,n);return{"%SharedSymbol%":o}};const Ya=t=>{try{t();return false}catch(t){return true}};const Ja=(t,e,o)=>{if(t===undefined){return false}const r=C(t,e);if(!r||"value"in r){return false}const{get:n,set:s}=r;if(typeof n!=="function"||typeof s!=="function"){return false}if(n()!==o){return false}if(et(n,t,[])!==o){return false}const a="Seems to be a setter";const i={__proto__:null};et(s,i,[a]);if(i[e]!==a){return false}const c={__proto__:t};et(s,c,[a]);if(c[e]!==a){return false}if(!Ya((()=>et(s,t,[o])))){return false}if("originalValue"in n){return false}if(r.configurable===false){return false}tt(t,e,{value:o,writable:true,enumerable:r.enumerable,configurable:true});return true};const Qa=t=>{Ja(t["%IteratorPrototype%"],"constructor",t.Iterator);Ja(t["%IteratorPrototype%"],z,"Iterator")};const Xa=()=>{const t=wt[K];tt(wt,K,{configurable:true,get(){return t},set(t){if(this===wt)return;if(H(this,K)){this[K]=t}tt(this,K,{value:t,writable:true,enumerable:true,configurable:true})}})};const Za=()=>{if(typeof pt.transfer==="function"){return{}}const e=t.structuredClone;if(typeof e!=="function"){return{}}const r={transfer(t=undefined){const r=Dt(this);if(t===undefined||t===r){return e(this,{transfer:[this]})}if(typeof t!=="number"){throw v(`transfer newLength if provided must be a number`)}if(t>r){const r=new o(t);const n=new h(this);const s=new h(r);Bt(s,n);e(this,{transfer:[this]});return r}else{const o=Ut(this,0,t);e(this,{transfer:[this]});return o}}};tt(pt,"transfer",{value:r.transfer,writable:true,enumerable:false,configurable:true});return{}};const ti=t=>{let e=false;const o=(...o)=>{if(e){t(" ",...o)}else{t(...o)}};return{warn(...t){o(...t)},error(...t){o(...t)},groupCollapsed(...o){Ur(!e);t(...o);e=true},groupEnd(){e=false}}};const ei=()=>{};const oi=e=>{if(e==="none"){return ti(ei)}if(e==="console"||t.window===t||t.importScripts!==undefined){return console}if(t.console!==undefined){const e=t.console;const o=he(e.error,e);return ti(o)}if(t.print!==undefined){return ti(t.print)}return ti(ei)};const ri=(t,e,o)=>{const{warn:r,error:n,groupCollapsed:s,groupEnd:a}=e;const i=s&&a;let c=false;try{return o({warn(...e){if(i&&!c){s(t);c=true}r(...e)},error(...e){if(i&&!c){s(t);c=true}n(...e)}})}finally{if(i&&c){a();c=false}}};const{Fail:ni,details:si,quote:ai}=Ur;let ii;let ci;const ui=zr();const li=()=>{let e;try{e=ve("return true")()}catch(t){e=false}let o;try{o=Ae("true")}catch(t){o=false}let r;if(e&&o){r=ve("eval","SES_changed",`        eval("SES_changed = true");\n        return SES_changed;\n      `)(Ae,false);if(!r){delete t.SES_changed}}return{functionAllowed:e,evalAllowed:o,directEvalAllowed:r}};const fi=(e={})=>{const{errorTaming:o=Xe("LOCKDOWN_ERROR_TAMING","safe",["unsafe","unsafe-debug"]),errorTrapping:r=Xe("LOCKDOWN_ERROR_TRAPPING","platform",["none","report","abort","exit"]),reporting:n=Xe("LOCKDOWN_REPORTING","platform",["console","none"]),unhandledRejectionTrapping:s=Xe("LOCKDOWN_UNHANDLED_REJECTION_TRAPPING","report",["none"]),regExpTaming:a=Xe("LOCKDOWN_REGEXP_TAMING","safe",["unsafe"]),localeTaming:i=Xe("LOCKDOWN_LOCALE_TAMING","safe",["unsafe"]),consoleTaming:c=Xe("LOCKDOWN_CONSOLE_TAMING","safe",["unsafe"]),overrideTaming:u=Xe("LOCKDOWN_OVERRIDE_TAMING","moderate",["min","severe"]),stackFiltering:l=Xe("LOCKDOWN_STACK_FILTERING","concise",["omit-frames","shorten-paths","verbose"]),domainTaming:f=Xe("LOCKDOWN_DOMAIN_TAMING","safe",["unsafe"]),evalTaming:p=Xe("LOCKDOWN_EVAL_TAMING","safe-eval",["unsafe-eval","no-eval","safeEval","unsafeEval","noEval"]),overrideDebug:d=It(ce(Xe("LOCKDOWN_OVERRIDE_DEBUG",""),","),(t=>t!=="")),legacyRegeneratorRuntimeTaming:y=Xe("LOCKDOWN_LEGACY_REGENERATOR_RUNTIME_TAMING","safe",["unsafe-ignore"]),__hardenTaming__:g=Xe("LOCKDOWN_HARDEN_TAMING","safe",["unsafe"]),dateTaming:m,mathTaming:b,...h}=e;const S=it(h);S.length===0||ni`lockdown(): non supported option ${ai(S)}`;const P=oi(n);const{warn:E}=P;if(m!==undefined){E(`SES The 'dateTaming' option is deprecated and does nothing. In the future specifying it will be an error.`)}if(b!==undefined){E(`SES The 'mathTaming' option is deprecated and does nothing. In the future specifying it will be an error.`)}ii===undefined||Ur.fail(si`Already locked down at ${ii} (SES_ALREADY_LOCKED_DOWN)`,v);ii=v("Prior lockdown (SES_ALREADY_LOCKED_DOWN)");const{functionAllowed:w,evalAllowed:_,directEvalAllowed:A}=li();if(A===false&&p==="safe-eval"&&(w||_)){throw v("SES cannot initialize unless 'eval' is the original intrinsic 'eval', suitable for direct eval (dynamically scoped eval) (SES_DIRECT_EVAL)")}const I=()=>t.Function.prototype.constructor!==t.Function&&typeof t.harden==="function"&&typeof t.lockdown==="function"&&t.Date.prototype.constructor!==t.Date&&typeof t.Date.now==="function"&&M(t.Date.prototype.constructor.now(),NaN);if(I()){throw v(`Already locked down but not by this SES instance (SES_MULTIPLE_INSTANCES)`)}As(f);const T=_s();const{addIntrinsics:$,completePrototypes:x,finalIntrinsics:O}=mn(P);const N=Va(ui,g);$({harden:N});$(Sn());$(Pn());$(na(o,l));$(En());$(wn(a));$(qa());$(Za());$(vs());$(Ka());x();const C=O();const F={__proto__:null};if(typeof t.Buffer==="function"){F.Buffer=t.Buffer}let L;if(o==="safe"){L=C["%InitialGetStackString%"]}const U=Ms(c,r,s,L);t.console=U.console;if(typeof U.console._times==="object"){F.SafeMap=R(U.console._times)}if((o==="unsafe"||o==="unsafe-debug")&&t.assert===Ur){t.assert=Lr(undefined,true)}Fn(C,i);Qa(C);ri("SES Removing unpermitted intrinsics",P,(t=>hn(C,T,t)));Un(t);Dn(t,{intrinsics:C,newGlobalPropertyNames:Yr,makeCompartmentConstructor:Ha,markVirtualizedNativeFunction:T});if(p==="no-eval"||p==="noEval"){Bn(t,Ie,T)}else if(p==="safe-eval"||p==="safeEval"){const{safeEvaluate:e}=Ps({globalObject:t});Bn(t,e,T)}else;const D=()=>{ci===undefined||Ur.fail(si`Already locked down at ${ci} (SES_ALREADY_LOCKED_DOWN)`,v);ci=v("Prior lockdown (SES_ALREADY_LOCKED_DOWN)");ri("SES Enabling property overrides",P,(t=>In(C,u,t,d)));if(y==="unsafe-ignore"){Xa()}const e={intrinsics:C,hostIntrinsics:F,globals:{Function:t.Function,eval:t.eval,Compartment:t.Compartment,Symbol:t.Symbol}};for(const o of k(Yr)){e.globals[o]=t[o]}N(e);return N};return D};t.lockdown=e=>{const o=fi(e);t.harden=o()};t.repairIntrinsics=e=>{const o=fi(e);t.hardenIntrinsics=()=>{t.harden=o()}};const pi=_s();const di=oi("none");t.Compartment=Ha(Ha,bn(t,di),pi,{enforceNew:true});t.assert=Ur;const yi=Cs(Mr);const gi=J("MAKE_CAUSAL_CONSOLE_FROM_LOGGER_KEY_FOR_SES_AVA");t[gi]=yi;
//# sourceMappingURL=p-BOWIeDdp.js.map