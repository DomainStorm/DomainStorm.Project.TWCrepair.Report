const t=globalThis;const{Array:e,ArrayBuffer:r,Date:o,FinalizationRegistry:n,Float32Array:s,JSON:a,Map:i,Math:c,Number:u,Object:f,Promise:l,Proxy:p,Reflect:d,RegExp:y,Set:g,String:m,Symbol:b,Uint8Array:h,WeakMap:S,WeakSet:E}=globalThis;const{Error:P,RangeError:w,ReferenceError:A,SyntaxError:_,TypeError:v,AggregateError:I}=globalThis;const{assign:T,create:$,defineProperties:x,entries:N,freeze:O,getOwnPropertyDescriptor:C,getOwnPropertyDescriptors:F,getOwnPropertyNames:k,getPrototypeOf:R,is:M,keys:L,prototype:U,preventExtensions:D,setPrototypeOf:j,values:B,fromEntries:G,hasOwn:H}=f;const{species:W,toStringTag:z,iterator:K,matchAll:q,unscopables:V,keyFor:Y,for:J}=b;const{isInteger:Q}=u;const{stringify:X}=a;const{defineProperty:Z}=f;const tt=(t,e,r)=>{const o=Z(t,e,r);if(o!==t){throw v(`Please report that the original defineProperty silently failed to set ${X(m(e))}. (SES_DEFINE_PROPERTY_FAILED_SILENTLY)`)}return o};const{apply:et,construct:rt,get:ot,getOwnPropertyDescriptor:nt,has:st,isExtensible:at,ownKeys:it,preventExtensions:ct,set:ut}=d;const{isArray:ft,prototype:lt}=e;const{prototype:pt}=r;const{prototype:dt}=i;const{prototype:yt}=RegExp;const{prototype:gt}=g;const{prototype:mt}=m;const{prototype:bt}=S;const{prototype:ht}=E;const{prototype:St}=Function;const{prototype:Et}=l;const{prototype:Pt}=R((function*(){}));const wt=R(R(lt.values()));const At=R(h.prototype);const{bind:_t}=St;const vt=_t.bind(_t.call);const It=vt(lt.filter);const Tt=vt(lt.forEach);const $t=vt(lt.includes);const xt=vt(lt.join);const Nt=vt(lt.map);const Ot=vt(lt.flatMap);const Ct=vt(lt.pop);const Ft=vt(lt.push);const kt=vt(lt.slice);const Rt=vt(lt.some);const Mt=vt(lt.sort);const Lt=vt(lt[K]);const Ut=vt(pt.slice);const Dt=vt(C(pt,"byteLength").get);const jt=vt(At.set);const Bt=vt(dt.set);const Gt=vt(dt.get);const Ht=vt(dt.has);const Wt=vt(dt.delete);const zt=vt(dt.entries);const Kt=vt(dt[K]);const qt=vt(gt.add);vt(gt.delete);const Vt=vt(gt.forEach);const Yt=vt(gt.has);const Jt=vt(gt[K]);const Qt=vt(yt.test);const Xt=vt(yt.exec);const Zt=vt(yt[q]);const te=vt(mt.endsWith);const ee=vt(mt.includes);const re=vt(mt.indexOf);vt(mt.match);const oe=vt(Pt.next);const ne=vt(Pt.throw);const se=vt(mt.replace);const ae=vt(mt.search);const ie=vt(mt.slice);const ce=vt(mt.split);const ue=vt(mt.startsWith);const fe=vt(mt[K]);const le=vt(bt.delete);const pe=vt(bt.get);const de=vt(bt.has);const ye=vt(bt.set);const ge=vt(ht.add);const me=vt(ht.has);const be=vt(St.toString);const he=vt(_t);vt(Et.catch);const Se=vt(Et.then);const Ee=n&&vt(n.prototype.register);n&&vt(n.prototype.unregister);const Pe=t=>!t||typeof t!=="object"&&typeof t!=="function";const we=t=>t instanceof P;const Ae=t=>t;const _e=eval;const ve=Function;const Ie=()=>{throw v('Cannot eval with evalTaming set to "no-eval" (SES_NO_EVAL)')};const Te=C(Error("er1"),"stack");const $e=C(v("er2"),"stack");let xe;let Ne;if(Te&&$e&&Te.get){if(typeof Te.get==="function"&&Te.get===$e.get&&typeof Te.set==="function"&&Te.set===$e.set){xe=O(Te.get);Ne=O(Te.set)}else{throw v("Unexpected Error own stack accessor functions (SES_UNEXPECTED_ERROR_OWN_STACK_ACCESSOR)")}}const Oe=xe;const Ce=Ne;const Fe=()=>{try{return new ve("return (async function* AsyncGeneratorFunctionInstance() {})")()}catch(t){if(t.name==="SyntaxError"){return undefined}else if(t.name==="EvalError"){return async function*t(){}}else{throw t}}};const ke=Fe();function Re(){return this}if(Re()){throw v(`SES failed to initialize, sloppy mode (SES_NO_SLOPPY)`)}const Me=globalThis;const{Object:Le,Reflect:Ue,Array:De,String:je,JSON:Be,Error:Ge}=Me;const{freeze:He}=Le;const{apply:We}=Ue;const ze=t=>(e,...r)=>We(t,e,r);const Ke=ze(De.prototype.push);const qe=ze(De.prototype.includes);const Ve=ze(je.prototype.split);const Ye=Be.stringify;const Je=(t,...e)=>{let r=t[0];for(let o=0;o<e.length;o+=1){r=`${r}${e[o]}${t[o+1]}`}throw Ge(r)};const Qe=(t,e=false)=>{const r=[];const o=(o,n,s=undefined)=>{typeof o==="string"||Je`Environment option name ${Ye(o)} must be a string.`;typeof n==="string"||Je`Environment option default setting ${Ye(n)} must be a string.`;let a=n;const i=t.process||undefined;const c=typeof i==="object"&&i.env||undefined;if(typeof c==="object"){if(o in c){if(!e){Ke(r,o)}const t=c[o];typeof t==="string"||Je`Environment option named ${Ye(o)}, if present, must have a corresponding string value, got ${Ye(t)}`;a=t}}s===undefined||a===n||qe(s,a)||Je`Unrecognized ${Ye(o)} value ${Ye(a)}. Expected one of ${Ye([n,...s])}`;return a};He(o);const n=t=>{const e=o(t,"");return He(e===""?[]:Ve(e,","))};He(n);const s=(t,e)=>qe(n(t),e);const a=()=>He([...r]);He(a);return He({getEnvironmentOption:o,getEnvironmentOptionsList:n,environmentOptionsListHas:s,getCapturedEnvironmentOptionNames:a})};He(Qe);const{getEnvironmentOption:Xe}=Qe(Me,true);const{ArrayBuffer:Ze,Object:tr,Reflect:er,Symbol:rr,TypeError:or,Uint8Array:nr,WeakMap:sr,structuredClone:ar}=globalThis;const{freeze:ir,defineProperty:cr,getPrototypeOf:ur,getOwnPropertyDescriptor:fr}=tr;const{apply:lr,ownKeys:pr}=er;const{toStringTag:dr}=rr;const{prototype:yr}=Ze;const{slice:gr,transfer:mr}=yr;const{get:br}=fr(yr,"byteLength");const hr=ur(nr.prototype);const{set:Sr}=hr;const{get:Er}=fr(hr,"buffer");const Pr=(t,e=undefined,r=undefined)=>lr(gr,t,[e,r]);let wr;if(mr){wr=t=>lr(mr,t,[])}else if(ar){wr=t=>{Pr(t,0,0);return ar(t,{transfer:[t]})}}else{wr=undefined}const Ar=new sr;for(const t of["get","has","set"]){cr(Ar,t,{value:Ar[t]})}const _r=t=>{const e=Ar.get(t);if(e){return e}throw or("Not an emulated Immutable ArrayBuffer")};const vr={__proto__:yr,get byteLength(){return lr(br,_r(this),[])},get detached(){_r(this);return false},get maxByteLength(){return lr(br,_r(this),[])},get resizable(){_r(this);return false},get immutable(){_r(this);return true},slice(t=undefined,e=undefined){return Pr(_r(this),t,e)},sliceToImmutable(t=undefined,e=undefined){return $r(_r(this),t,e)},resize(t=undefined){_r(this);throw or("Cannot resize an immutable ArrayBuffer")},transfer(t=undefined){_r(this);throw or("Cannot detach an immutable ArrayBuffer")},transferToFixedLength(t=undefined){_r(this);throw or("Cannot detach an immutable ArrayBuffer")},transferToImmutable(t=undefined){_r(this);throw or("Cannot detach an immutable ArrayBuffer")},[dr]:"ImmutableArrayBuffer"};for(const t of pr(vr)){cr(vr,t,{enumerable:false})}const Ir=t=>{const e={__proto__:vr};Ar.set(e,t);return e};ir(Ir);const Tr=t=>Ar.has(t);const $r=(t,e=undefined,r=undefined)=>{let o=Ar.get(t);if(o===undefined){o=t}return Ir(Pr(o,e,r))};let xr;if(wr){xr=(t,e=undefined)=>{if(e===undefined){t=wr(t)}else if(mr){t=lr(mr,t,[e])}else{t=wr(t);const r=t.byteLength;if(e<=r){t=Pr(t,0,e)}else{const r=new nr(t);const o=new nr(e);lr(Sr,o,[r]);t=lr(Er,o,[])}}const r=Ir(t);return r}}else{xr=undefined}const Nr=xr;const{ArrayBuffer:Or,JSON:Cr,Object:Fr,Reflect:kr}=globalThis;const Rr=Nr;const{getOwnPropertyDescriptors:Mr,defineProperties:Lr,defineProperty:Ur}=Fr;const{ownKeys:Dr}=kr;const{prototype:jr}=Or;const{stringify:Br}=Cr;const Gr={sliceToImmutable(t=undefined,e=undefined){return $r(this,t,e)},get immutable(){return Tr(this)},...Rr?{transferToImmutable(t=undefined){return Rr(this,t)}}:{}};for(const t of Dr(Gr)){Ur(Gr,t,{enumerable:false})}const Hr=Dr(Gr).filter((t=>t in jr));if(Hr.length>0){console.warn(`About to overwrite ArrayBuffer.prototype properties ${Br(Hr)}`)}Lr(jr,Mr(Gr));const Wr=t=>{t=`${t}`;if(t.length>=1&&ee("aeiouAEIOU",t[0])){return`an ${t}`}return`a ${t}`};O(Wr);const zr=(t,e=undefined)=>{const r=new g;const o=(t,e)=>{switch(typeof e){case"object":{if(e===null){return null}if(Yt(r,e)){return"[Seen]"}qt(r,e);if(we(e)){return`[${e.name}: ${e.message}]`}if(z in e){return`[${e[z]}]`}if(ft(e)){return e}const t=L(e);if(t.length<2){return e}let o=true;for(let e=1;e<t.length;e+=1){if(t[e-1]>=t[e]){o=false;break}}if(o){return e}Mt(t);const n=Nt(t,(t=>[t,e[t]]));return G(n)}case"function":{return`[Function ${e.name||"<anon>"}]`}case"string":{if(ue(e,"[")){return`[${e}]`}return e}case"undefined":case"symbol":{return`[${m(e)}]`}case"bigint":{return`[${e}n]`}case"number":{if(M(e,NaN)){return"[NaN]"}else if(e===Infinity){return"[Infinity]"}else if(e===-Infinity){return"[-Infinity]"}return e}default:{return e}}};try{return X(t,o,e)}catch(t){return"[Something that failed to stringify]"}};O(zr);const{Error:Kr,TypeError:qr,WeakMap:Vr}=globalThis;const{parse:Yr,stringify:Jr}=JSON;const{isSafeInteger:Qr}=Number;const{freeze:Xr}=Object;const{toStringTag:Zr}=Symbol;const to=Symbol("UNKNOWN_KEY");const eo=(t,e)=>{const r=Jr(t);const o=Yr(r,e);return o};const ro=(t,e)=>Xr(e);const oo=t=>eo(t,ro);const no=(t,e,r)=>{const o=t?.next;const n={id:e,next:o,prev:t,data:r};t.next=n;o.prev=n;return n};const so=(t,e,r=e.next)=>{if(t===e||t===r)return;const{prev:o,next:n}=t;o.next=n;n.prev=o;t.prev=e;t.next=r;e.next=t;r.prev=t};const ao=(t,e,r)=>{if(e!==to){t.data.delete(e);return}if(t.data.clear){t.data.clear();return}if(!r){throw Kr("internal: makeMap is required with UNKNOWN_KEY")}t.data=r()};const io=Xr({totalQueryCount:0,totalHitCount:0});const co=(t,e={})=>{if(!Qr(t)||t<0){throw qr("capacity must be a non-negative safe integer number <= 2**53 - 1")}const r=(t=>{try{t();return t}catch(e){const r=()=>new t;return r}})(e.makeMap??Vr);const o=r().clear===undefined?"WeakCacheMap":"CacheMap";const n=r();const s={id:0,next:undefined,prev:undefined,data:{has:()=>{throw Kr("internal: sentinel head cell has no data")}}};s.next=s;s.prev=s;let a=0;const i=eo(io);const c=()=>oo(i);const u=t=>{i.totalQueryCount+=1;const e=n.get(t);if(!e?.data.has(t))return undefined;i.totalHitCount+=1;so(e,s);return e};const f=t=>{const e=u(t);return e!==undefined};Xr(f);const l=t=>{const e=u(t);return e?.data.get(t)};Xr(l);const p=(e,o)=>{let i=u(e);if(i){i.data.set(e,o);return y}if(a<t){i=no(s,a+1,r());a+=1;i.data.set(e,o)}else if(t>0){i=s.prev;ao(i,to,r);i.data.set(e,o);so(i,s)}if(i)n.set(e,i);return y};Xr(p);const{delete:d}={delete:t=>{const e=n.get(t);if(!e?.data.has(t)){n.delete(t);return false}so(e,s.prev);ao(e,t);n.delete(t);return true}};Xr(d);const y={has:f,get:l,set:p,delete:d,[Zr]:o};Xr(y);const g={cache:y,getMetrics:c};return Xr(g)};Xr(co);const{freeze:uo}=Object;const{isSafeInteger:fo}=Number;const lo=1e3;const po=100;const yo=(t=lo,e=po)=>{if(!fo(e)||e<1){throw TypeError("argsPerErrorBudget must be a safe positive integer number")}const{cache:r}=co(t);const o=(t,o)=>{const n=r.get(t);if(n!==undefined){if(n.length>=e){n.shift()}n.push(o)}else{r.set(t,[o])}};uo(o);const n=t=>{const e=r.get(t);r.delete(t);return e};uo(n);return uo({addLogArgs:o,takeLogArgsArray:n})};uo(yo);const go=new S;const mo=(t,e=undefined)=>{const r=O({toString:O((()=>zr(t,e)))});ye(go,r,t);return r};O(mo);const bo=O(/^[\w:-]( ?[\w:-])*$/);const ho=(t,e=undefined)=>{if(typeof t!=="string"||!Qt(bo,t)){return mo(t,e)}const r=O({toString:O((()=>t))});ye(go,r,t);return r};O(ho);const So=new S;const Eo=({template:t,args:e})=>{const r=[t[0]];for(let o=0;o<e.length;o+=1){const n=e[o];let s;if(de(go,n)){s=`${n}`}else if(we(n)){s=`(${Wr(n.name)})`}else{s=`(${Wr(typeof n)})`}Ft(r,s,t[o+1])}return xt(r,"")};const Po=O({toString(){const t=pe(So,this);if(t===undefined){return"[Not a DetailsToken]"}return Eo(t)}});O(Po.toString);const wo=(t,...e)=>{const r=O({__proto__:Po});ye(So,r,{template:t,args:e});return r};O(wo);const Ao=(t,...e)=>{e=Nt(e,(t=>de(go,t)?t:mo(t)));return wo(t,...e)};O(Ao);const _o=({template:t,args:e})=>{const r=[t[0]];for(let o=0;o<e.length;o+=1){let n=e[o];if(de(go,n)){n=pe(go,n)}const s=se(Ct(r)||"",/ $/,"");if(s!==""){Ft(r,s)}const a=se(t[o+1],/^ /,"");Ft(r,n,a)}if(r[r.length-1]===""){Ct(r)}return r};const vo=new S;let Io=0;const To=new S;const $o=(t,e=t.name)=>{let r=pe(To,t);if(r!==undefined){return r}Io+=1;r=`${e}#${Io}`;ye(To,t,r);return r};const xo=t=>{const e=F(t);const{name:r,message:o,errors:n=undefined,cause:s=undefined,stack:a=undefined,...i}=e;const c=it(i);if(c.length>=1){for(const e of c){delete t[e]}const e=$(U,i);ko(t,wo`originally with properties ${mo(e)}`)}for(const r of it(t)){const o=e[r];if(o&&H(o,"get")){tt(t,r,{value:t[r]})}}O(t)};const No=(e=wo`Assert failed`,r=t.Error,{errorName:o=undefined,cause:n=undefined,errors:s=undefined,sanitize:a=true}={})=>{if(typeof e==="string"){e=wo([e])}const i=pe(So,e);if(i===undefined){throw v(`unrecognized details ${mo(e)}`)}const c=Eo(i);const u=n&&{cause:n};let f;if(typeof I!=="undefined"&&r===I){f=I(s||[],c,u)}else{f=r(c,u);if(s!==undefined){tt(f,"errors",{value:s,writable:true,enumerable:false,configurable:true})}}ye(vo,f,_o(i));if(o!==undefined){$o(f,o)}if(a){xo(f)}return f};O(No);const{addLogArgs:Oo,takeLogArgsArray:Co}=yo();const Fo=new S;const ko=(t,e)=>{if(typeof e==="string"){e=wo([e])}const r=pe(So,e);if(r===undefined){throw v(`unrecognized details ${mo(e)}`)}const o=_o(r);const n=pe(Fo,t);if(n!==undefined){for(const e of n){e(t,o)}}else{Oo(t,o)}};O(ko);const Ro=t=>{if(!("stack"in t)){return""}const e=`${t.stack}`;const r=re(e,"\n");if(ue(e," ")||r===-1){return e}return ie(e,r+1)};const Mo={getStackString:t.getStackString||Ro,tagError:t=>$o(t),resetErrorTagNum:()=>{Io=0},getMessageLogArgs:t=>pe(vo,t),takeMessageLogArgs:t=>{const e=pe(vo,t);le(vo,t);return e},takeNoteLogArgsArray:(t,e)=>{const r=Co(t);if(e!==undefined){const r=pe(Fo,t);if(r){Ft(r,e)}else{ye(Fo,t,[e])}}return r||[]}};O(Mo);const Lo=(t=undefined,e=false)=>{const r=e?Ao:wo;const o=r`Check failed`;const n=(e=o,r=undefined,n=undefined)=>{const s=No(e,r,n);if(t!==undefined){t(s)}throw s};O(n);const s=(t,...e)=>n(r(t,...e));function a(t,e=undefined,r=undefined,o=undefined){t||n(e,r,o)}const i=(t,e,o=undefined,s=undefined,a=undefined)=>{M(t,e)||n(o||r`Expected ${t} is same as ${e}`,s||w,a)};O(i);const c=(t,e,o)=>{if(typeof t===e){return}typeof e==="string"||s`${mo(e)} must be a string`;if(o===undefined){const n=Wr(e);o=r`${t} must be ${ho(n)}`}n(o,v)};O(c);const u=(t,e=undefined)=>c(t,"string",e);const f=T(a,{error:No,fail:n,equal:i,typeof:c,string:u,note:ko,details:r,Fail:s,quote:mo,bare:ho,makeAssert:Lo});return O(f)};O(Lo);const Uo=Lo();const Do=Uo.equal;const jo=C(At,z);Uo(jo);const Bo=jo.get;Uo(Bo);const Go=t=>{const e=et(Bo,t,[]);return e!==undefined};const Ho=t=>{const e=+m(t);return Q(e)&&m(e)===t};const Wo=t=>{D(t);Tt(it(t),(e=>{const r=C(t,e);Uo(r);if(!Ho(e)){tt(t,e,{...r,writable:false,configurable:false})}}))};const zo=()=>{if(typeof t.harden==="function"){const e=t.harden;return e}const e=new E;const{harden:r}={harden(t){const r=new g;function o(t){if(Pe(t)){return}const o=typeof t;if(o!=="object"&&o!=="function"){throw v(`Unexpected typeof: ${o}`)}if(me(e,t)||Yt(r,t)){return}qt(r,t)}const n=t=>{if(Go(t)){Wo(t)}else{O(t)}const e=F(t);const r=R(t);o(r);Tt(it(e),(t=>{const r=e[t];if(H(r,"value")){o(r.value)}else{o(r.get);o(r.set)}}))};const s=Oe===undefined&&Ce===undefined?n:t=>{if(we(t)){const e=C(t,"stack");if(e&&e.get===Oe&&e.configurable){tt(t,"stack",{value:et(Oe,t,[])})}}return n(t)};const a=()=>{Vt(r,s)};const i=t=>{ge(e,t)};const c=()=>{Vt(r,i)};o(t);a();c();return t}};return r};const Ko=(t,e,r,o,{warn:n,error:s})=>{if(!r){n(`Removing ${o}`)}try{delete t[e]}catch(r){if(H(t,e)){if(typeof t==="function"&&e==="prototype"){t.prototype=undefined;if(t.prototype===undefined){n(`Tolerating undeletable ${o} === undefined`);return}}s(`failed to delete ${o}`,r)}else{s(`deleting ${o} threw`,r)}throw r}};const qo={Infinity:Infinity,NaN,undefined};const Vo={isFinite:"isFinite",isNaN:"isNaN",parseFloat:"parseFloat",parseInt:"parseInt",decodeURI:"decodeURI",decodeURIComponent:"decodeURIComponent",encodeURI:"encodeURI",encodeURIComponent:"encodeURIComponent",Array:"Array",ArrayBuffer:"ArrayBuffer",BigInt:"BigInt",BigInt64Array:"BigInt64Array",BigUint64Array:"BigUint64Array",Boolean:"Boolean",DataView:"DataView",EvalError:"EvalError",Float16Array:"Float16Array",Float32Array:"Float32Array",Float64Array:"Float64Array",Int8Array:"Int8Array",Int16Array:"Int16Array",Int32Array:"Int32Array",Map:"Map",Number:"Number",Object:"Object",Promise:"Promise",Proxy:"Proxy",RangeError:"RangeError",ReferenceError:"ReferenceError",Set:"Set",String:"String",SyntaxError:"SyntaxError",TypeError:"TypeError",Uint8Array:"Uint8Array",Uint8ClampedArray:"Uint8ClampedArray",Uint16Array:"Uint16Array",Uint32Array:"Uint32Array",URIError:"URIError",WeakMap:"WeakMap",WeakSet:"WeakSet",Iterator:"Iterator",AsyncIterator:"AsyncIterator",AggregateError:"AggregateError",JSON:"JSON",Reflect:"Reflect",escape:"escape",unescape:"unescape",ModuleSource:"ModuleSource",lockdown:"lockdown",harden:"harden",HandledPromise:"HandledPromise"};const Yo={Date:"%InitialDate%",Error:"%InitialError%",RegExp:"%InitialRegExp%",Math:"%InitialMath%",getStackString:"%InitialGetStackString%"};const Jo={Date:"%SharedDate%",Error:"%SharedError%",RegExp:"%SharedRegExp%",Symbol:"%SharedSymbol%",Math:"%SharedMath%"};const Qo=[EvalError,RangeError,ReferenceError,SyntaxError,TypeError,URIError];if(typeof AggregateError!=="undefined"){Ft(Qo,AggregateError)}const Xo={"[[Proto]]":"%FunctionPrototype%",length:"number",name:"string"};const Zo={"[[Proto]]":"%AsyncFunctionPrototype%"};const tn=Xo;const en=Zo;const rn={get:tn,set:"undefined"};const on={get:tn,set:tn};Tt(["caller","arguments"],(t=>{}));const nn=t=>t===rn||t===on;function sn(t){return{"[[Proto]]":"%SharedError%",prototype:t}}function an(t){return{"[[Proto]]":"%ErrorPrototype%",constructor:t,message:"string",name:"string",toString:false,cause:false}}function cn(t){return{"[[Proto]]":"%TypedArray%",BYTES_PER_ELEMENT:"number",prototype:t}}function un(t){return{"[[Proto]]":"%TypedArrayPrototype%",BYTES_PER_ELEMENT:"number",constructor:t}}const fn={E:"number",LN10:"number",LN2:"number",LOG10E:"number",LOG2E:"number",PI:"number",SQRT1_2:"number",SQRT2:"number","@@toStringTag":"string",abs:tn,acos:tn,acosh:tn,asin:tn,asinh:tn,atan:tn,atanh:tn,atan2:tn,cbrt:tn,ceil:tn,clz32:tn,cos:tn,cosh:tn,exp:tn,expm1:tn,floor:tn,fround:tn,hypot:tn,imul:tn,log:tn,log1p:tn,log10:tn,log2:tn,max:tn,min:tn,pow:tn,round:tn,sign:tn,sin:tn,sinh:tn,sqrt:tn,tan:tn,tanh:tn,trunc:tn,f16round:tn,sumPrecise:tn,idiv:false,idivmod:false,imod:false,imuldiv:false,irem:false,mod:false,irandom:false};const ln={"[[Proto]]":null,"%ThrowTypeError%":tn,Infinity:"number",NaN:"number",undefined:"undefined","%UniqueEval%":tn,isFinite:tn,isNaN:tn,parseFloat:tn,parseInt:tn,decodeURI:tn,decodeURIComponent:tn,encodeURI:tn,encodeURIComponent:tn,Object:{"[[Proto]]":"%FunctionPrototype%",assign:tn,create:tn,defineProperties:tn,defineProperty:tn,entries:tn,freeze:tn,fromEntries:tn,getOwnPropertyDescriptor:tn,getOwnPropertyDescriptors:tn,getOwnPropertyNames:tn,getOwnPropertySymbols:tn,getPrototypeOf:tn,is:tn,isExtensible:tn,isFrozen:tn,isSealed:tn,keys:tn,preventExtensions:tn,prototype:"%ObjectPrototype%",seal:tn,setPrototypeOf:tn,values:tn,hasOwn:tn,groupBy:tn,__getClass:false},"%ObjectPrototype%":{"[[Proto]]":null,constructor:"Object",hasOwnProperty:tn,isPrototypeOf:tn,propertyIsEnumerable:tn,toLocaleString:tn,toString:tn,valueOf:tn,"--proto--":on,__defineGetter__:tn,__defineSetter__:tn,__lookupGetter__:tn,__lookupSetter__:tn},"%UniqueFunction%":{"[[Proto]]":"%FunctionPrototype%",prototype:"%FunctionPrototype%"},"%InertFunction%":{"[[Proto]]":"%FunctionPrototype%",prototype:"%FunctionPrototype%"},"%FunctionPrototype%":{apply:tn,bind:tn,call:tn,constructor:"%InertFunction%",toString:tn,"@@hasInstance":tn,caller:false,arguments:false,fileName:false,lineNumber:false},Boolean:{"[[Proto]]":"%FunctionPrototype%",prototype:"%BooleanPrototype%"},"%BooleanPrototype%":{constructor:"Boolean",toString:tn,valueOf:tn},"%SharedSymbol%":{"[[Proto]]":"%FunctionPrototype%",asyncIterator:"symbol",for:tn,hasInstance:"symbol",isConcatSpreadable:"symbol",iterator:"symbol",keyFor:tn,match:"symbol",matchAll:"symbol",prototype:"%SymbolPrototype%",replace:"symbol",search:"symbol",species:"symbol",split:"symbol",toPrimitive:"symbol",toStringTag:"symbol",unscopables:"symbol",asyncDispose:"symbol",dispose:"symbol",useSimple:false,useSetter:false,operatorSet:false},"%SymbolPrototype%":{constructor:"%SharedSymbol%",description:rn,toString:tn,valueOf:tn,"@@toPrimitive":tn,"@@toStringTag":"string"},"%InitialError%":{"[[Proto]]":"%FunctionPrototype%",prototype:"%ErrorPrototype%",captureStackTrace:tn,stackTraceLimit:on,prepareStackTrace:on,isError:tn},"%SharedError%":{"[[Proto]]":"%FunctionPrototype%",prototype:"%ErrorPrototype%",captureStackTrace:tn,stackTraceLimit:on,prepareStackTrace:on,isError:tn},"%ErrorPrototype%":{constructor:"%SharedError%",message:"string",name:"string",toString:tn,at:false,stack:on,cause:false},EvalError:sn("%EvalErrorPrototype%"),RangeError:sn("%RangeErrorPrototype%"),ReferenceError:sn("%ReferenceErrorPrototype%"),SyntaxError:sn("%SyntaxErrorPrototype%"),TypeError:sn("%TypeErrorPrototype%"),URIError:sn("%URIErrorPrototype%"),AggregateError:sn("%AggregateErrorPrototype%"),"%EvalErrorPrototype%":an("EvalError"),"%RangeErrorPrototype%":an("RangeError"),"%ReferenceErrorPrototype%":an("ReferenceError"),"%SyntaxErrorPrototype%":an("SyntaxError"),"%TypeErrorPrototype%":an("TypeError"),"%URIErrorPrototype%":an("URIError"),"%AggregateErrorPrototype%":an("AggregateError"),Number:{"[[Proto]]":"%FunctionPrototype%",EPSILON:"number",isFinite:tn,isInteger:tn,isNaN:tn,isSafeInteger:tn,MAX_SAFE_INTEGER:"number",MAX_VALUE:"number",MIN_SAFE_INTEGER:"number",MIN_VALUE:"number",NaN:"number",NEGATIVE_INFINITY:"number",parseFloat:tn,parseInt:tn,POSITIVE_INFINITY:"number",prototype:"%NumberPrototype%"},"%NumberPrototype%":{constructor:"Number",toExponential:tn,toFixed:tn,toLocaleString:tn,toPrecision:tn,toString:tn,valueOf:tn},BigInt:{"[[Proto]]":"%FunctionPrototype%",asIntN:tn,asUintN:tn,prototype:"%BigIntPrototype%",bitLength:false,fromArrayBuffer:false,tdiv:false,fdiv:false,cdiv:false,ediv:false,tdivrem:false,fdivrem:false,cdivrem:false,edivrem:false,sqrt:false,sqrtrem:false,floorLog2:false,ctz:false},"%BigIntPrototype%":{constructor:"BigInt",toLocaleString:tn,toString:tn,valueOf:tn,"@@toStringTag":"string"},"%InitialMath%":{...fn,random:tn},"%SharedMath%":{...fn,random:tn},"%InitialDate%":{"[[Proto]]":"%FunctionPrototype%",now:tn,parse:tn,prototype:"%DatePrototype%",UTC:tn},"%SharedDate%":{"[[Proto]]":"%FunctionPrototype%",now:tn,parse:tn,prototype:"%DatePrototype%",UTC:tn},"%DatePrototype%":{constructor:"%SharedDate%",getDate:tn,getDay:tn,getFullYear:tn,getHours:tn,getMilliseconds:tn,getMinutes:tn,getMonth:tn,getSeconds:tn,getTime:tn,getTimezoneOffset:tn,getUTCDate:tn,getUTCDay:tn,getUTCFullYear:tn,getUTCHours:tn,getUTCMilliseconds:tn,getUTCMinutes:tn,getUTCMonth:tn,getUTCSeconds:tn,setDate:tn,setFullYear:tn,setHours:tn,setMilliseconds:tn,setMinutes:tn,setMonth:tn,setSeconds:tn,setTime:tn,setUTCDate:tn,setUTCFullYear:tn,setUTCHours:tn,setUTCMilliseconds:tn,setUTCMinutes:tn,setUTCMonth:tn,setUTCSeconds:tn,toDateString:tn,toISOString:tn,toJSON:tn,toLocaleDateString:tn,toLocaleString:tn,toLocaleTimeString:tn,toString:tn,toTimeString:tn,toUTCString:tn,valueOf:tn,"@@toPrimitive":tn,getYear:tn,setYear:tn,toGMTString:tn},String:{"[[Proto]]":"%FunctionPrototype%",fromCharCode:tn,fromCodePoint:tn,prototype:"%StringPrototype%",raw:tn,fromArrayBuffer:false},"%StringPrototype%":{length:"number",charAt:tn,charCodeAt:tn,codePointAt:tn,concat:tn,constructor:"String",endsWith:tn,includes:tn,indexOf:tn,lastIndexOf:tn,localeCompare:tn,match:tn,matchAll:tn,normalize:tn,padEnd:tn,padStart:tn,repeat:tn,replace:tn,replaceAll:tn,search:tn,slice:tn,split:tn,startsWith:tn,substring:tn,toLocaleLowerCase:tn,toLocaleUpperCase:tn,toLowerCase:tn,toString:tn,toUpperCase:tn,trim:tn,trimEnd:tn,trimStart:tn,valueOf:tn,"@@iterator":tn,at:tn,isWellFormed:tn,toWellFormed:tn,unicodeSets:tn,substr:tn,anchor:tn,big:tn,blink:tn,bold:tn,fixed:tn,fontcolor:tn,fontsize:tn,italics:tn,link:tn,small:tn,strike:tn,sub:tn,sup:tn,trimLeft:tn,trimRight:tn,compare:false,__quote:false},"%StringIteratorPrototype%":{"[[Proto]]":"%IteratorPrototype%",next:tn,"@@toStringTag":"string"},"%InitialRegExp%":{"[[Proto]]":"%FunctionPrototype%",prototype:"%RegExpPrototype%","@@species":rn,escape:tn,input:false,$_:false,lastMatch:false,"$&":false,lastParen:false,"$+":false,leftContext:false,"$`":false,rightContext:false,"$'":false,$1:false,$2:false,$3:false,$4:false,$5:false,$6:false,$7:false,$8:false,$9:false},"%SharedRegExp%":{"[[Proto]]":"%FunctionPrototype%",prototype:"%RegExpPrototype%","@@species":rn,escape:tn},"%RegExpPrototype%":{constructor:"%SharedRegExp%",exec:tn,dotAll:rn,flags:rn,global:rn,hasIndices:rn,ignoreCase:rn,"@@match":tn,"@@matchAll":tn,multiline:rn,"@@replace":tn,"@@search":tn,source:rn,"@@split":tn,sticky:rn,test:tn,toString:tn,unicode:rn,unicodeSets:rn,compile:false},"%RegExpStringIteratorPrototype%":{"[[Proto]]":"%IteratorPrototype%",next:tn,"@@toStringTag":"string"},Array:{"[[Proto]]":"%FunctionPrototype%",from:tn,isArray:tn,of:tn,prototype:"%ArrayPrototype%","@@species":rn,at:tn,fromAsync:tn},"%ArrayPrototype%":{length:"number",concat:tn,constructor:"Array",copyWithin:tn,entries:tn,every:tn,fill:tn,filter:tn,find:tn,findIndex:tn,flat:tn,flatMap:tn,forEach:tn,includes:tn,indexOf:tn,join:tn,keys:tn,lastIndexOf:tn,map:tn,pop:tn,push:tn,reduce:tn,reduceRight:tn,reverse:tn,shift:tn,slice:tn,some:tn,sort:tn,splice:tn,toLocaleString:tn,toString:tn,unshift:tn,values:tn,"@@iterator":tn,"@@unscopables":{"[[Proto]]":null,copyWithin:"boolean",entries:"boolean",fill:"boolean",find:"boolean",findIndex:"boolean",flat:"boolean",flatMap:"boolean",includes:"boolean",keys:"boolean",values:"boolean",at:"boolean",findLast:"boolean",findLastIndex:"boolean",toReversed:"boolean",toSorted:"boolean",toSpliced:"boolean",with:"boolean",group:"boolean",groupToMap:"boolean",groupBy:"boolean"},findLast:tn,findLastIndex:tn,toReversed:tn,toSorted:tn,toSpliced:tn,with:tn,group:tn,groupToMap:tn,groupBy:tn,at:tn},"%ArrayIteratorPrototype%":{"[[Proto]]":"%IteratorPrototype%",next:tn,"@@toStringTag":"string"},"%TypedArray%":{"[[Proto]]":"%FunctionPrototype%",from:tn,of:tn,prototype:"%TypedArrayPrototype%","@@species":rn},"%TypedArrayPrototype%":{buffer:rn,byteLength:rn,byteOffset:rn,constructor:"%TypedArray%",copyWithin:tn,entries:tn,every:tn,fill:tn,filter:tn,find:tn,findIndex:tn,forEach:tn,includes:tn,indexOf:tn,join:tn,keys:tn,lastIndexOf:tn,length:rn,map:tn,reduce:tn,reduceRight:tn,reverse:tn,set:tn,slice:tn,some:tn,sort:tn,subarray:tn,toLocaleString:tn,toString:tn,values:tn,"@@iterator":tn,"@@toStringTag":rn,at:tn,findLast:tn,findLastIndex:tn,toReversed:tn,toSorted:tn,with:tn},BigInt64Array:cn("%BigInt64ArrayPrototype%"),BigUint64Array:cn("%BigUint64ArrayPrototype%"),Float16Array:cn("%Float16ArrayPrototype%"),Float32Array:cn("%Float32ArrayPrototype%"),Float64Array:cn("%Float64ArrayPrototype%"),Int16Array:cn("%Int16ArrayPrototype%"),Int32Array:cn("%Int32ArrayPrototype%"),Int8Array:cn("%Int8ArrayPrototype%"),Uint16Array:cn("%Uint16ArrayPrototype%"),Uint32Array:cn("%Uint32ArrayPrototype%"),Uint8ClampedArray:cn("%Uint8ClampedArrayPrototype%"),Uint8Array:{...cn("%Uint8ArrayPrototype%"),fromBase64:tn,fromHex:tn},"%BigInt64ArrayPrototype%":un("BigInt64Array"),"%BigUint64ArrayPrototype%":un("BigUint64Array"),"%Float16ArrayPrototype%":un("Float16Array"),"%Float32ArrayPrototype%":un("Float32Array"),"%Float64ArrayPrototype%":un("Float64Array"),"%Int16ArrayPrototype%":un("Int16Array"),"%Int32ArrayPrototype%":un("Int32Array"),"%Int8ArrayPrototype%":un("Int8Array"),"%Uint16ArrayPrototype%":un("Uint16Array"),"%Uint32ArrayPrototype%":un("Uint32Array"),"%Uint8ClampedArrayPrototype%":un("Uint8ClampedArray"),"%Uint8ArrayPrototype%":{...un("Uint8Array"),setFromBase64:tn,setFromHex:tn,toBase64:tn,toHex:tn},Map:{"[[Proto]]":"%FunctionPrototype%","@@species":rn,prototype:"%MapPrototype%",groupBy:tn},"%MapPrototype%":{clear:tn,constructor:"Map",delete:tn,entries:tn,forEach:tn,get:tn,has:tn,keys:tn,set:tn,size:rn,values:tn,"@@iterator":tn,"@@toStringTag":"string"},"%MapIteratorPrototype%":{"[[Proto]]":"%IteratorPrototype%",next:tn,"@@toStringTag":"string"},Set:{"[[Proto]]":"%FunctionPrototype%",prototype:"%SetPrototype%","@@species":rn,groupBy:false},"%SetPrototype%":{add:tn,clear:tn,constructor:"Set",delete:tn,entries:tn,forEach:tn,has:tn,keys:tn,size:rn,values:tn,"@@iterator":tn,"@@toStringTag":"string",intersection:tn,union:tn,difference:tn,symmetricDifference:tn,isSubsetOf:tn,isSupersetOf:tn,isDisjointFrom:tn},"%SetIteratorPrototype%":{"[[Proto]]":"%IteratorPrototype%",next:tn,"@@toStringTag":"string"},WeakMap:{"[[Proto]]":"%FunctionPrototype%",prototype:"%WeakMapPrototype%"},"%WeakMapPrototype%":{constructor:"WeakMap",delete:tn,get:tn,has:tn,set:tn,"@@toStringTag":"string"},WeakSet:{"[[Proto]]":"%FunctionPrototype%",prototype:"%WeakSetPrototype%"},"%WeakSetPrototype%":{add:tn,constructor:"WeakSet",delete:tn,has:tn,"@@toStringTag":"string"},ArrayBuffer:{"[[Proto]]":"%FunctionPrototype%",isView:tn,prototype:"%ArrayBufferPrototype%","@@species":rn,fromString:false,fromBigInt:false},"%ArrayBufferPrototype%":{byteLength:rn,constructor:"ArrayBuffer",slice:tn,"@@toStringTag":"string",concat:false,transfer:tn,resize:tn,resizable:rn,maxByteLength:rn,transferToFixedLength:tn,detached:rn,transferToImmutable:tn,sliceToImmutable:tn,immutable:rn},"%ImmutableArrayBufferPrototype%":{"[[Proto]]":"%ArrayBufferPrototype%",byteLength:rn,slice:tn,"@@toStringTag":"string",transfer:tn,resize:tn,resizable:rn,maxByteLength:rn,transferToFixedLength:tn,detached:rn,transferToImmutable:tn,sliceToImmutable:tn,immutable:rn},SharedArrayBuffer:false,"%SharedArrayBufferPrototype%":false,DataView:{"[[Proto]]":"%FunctionPrototype%",BYTES_PER_ELEMENT:"number",prototype:"%DataViewPrototype%"},"%DataViewPrototype%":{buffer:rn,byteLength:rn,byteOffset:rn,constructor:"DataView",getBigInt64:tn,getBigUint64:tn,getFloat16:tn,getFloat32:tn,getFloat64:tn,getInt8:tn,getInt16:tn,getInt32:tn,getUint8:tn,getUint16:tn,getUint32:tn,setBigInt64:tn,setBigUint64:tn,setFloat16:tn,setFloat32:tn,setFloat64:tn,setInt8:tn,setInt16:tn,setInt32:tn,setUint8:tn,setUint16:tn,setUint32:tn,"@@toStringTag":"string"},Atomics:false,JSON:{parse:tn,stringify:tn,"@@toStringTag":"string",rawJSON:tn,isRawJSON:tn},Iterator:{"[[Proto]]":"%FunctionPrototype%",prototype:"%IteratorPrototype%",from:tn,zip:tn,zipKeyed:tn,concat:tn},"%IteratorPrototype%":{"@@iterator":tn,constructor:"Iterator",map:tn,filter:tn,take:tn,drop:tn,flatMap:tn,reduce:tn,toArray:tn,forEach:tn,some:tn,every:tn,find:tn,"@@toStringTag":"string",toAsync:tn,"@@dispose":false},"%WrapForValidIteratorPrototype%":{"[[Proto]]":"%IteratorPrototype%",next:tn,return:tn},"%IteratorHelperPrototype%":{"[[Proto]]":"%IteratorPrototype%",next:tn,return:tn,"@@toStringTag":"string"},AsyncIterator:{"[[Proto]]":"%FunctionPrototype%",prototype:"%AsyncIteratorPrototype%",from:tn},"%AsyncIteratorPrototype%":{"@@asyncIterator":tn,constructor:"AsyncIterator",map:tn,filter:tn,take:tn,drop:tn,flatMap:tn,reduce:tn,toArray:tn,forEach:tn,some:tn,every:tn,find:tn,"@@toStringTag":"string","@@asyncDispose":false},"%WrapForValidAsyncIteratorPrototype%":{"[[Proto]]":"%AsyncIteratorPrototype%",next:tn,return:tn},"%AsyncIteratorHelperPrototype%":{"[[Proto]]":"%AsyncIteratorPrototype%",next:tn,return:tn,"@@toStringTag":"string"},"%InertGeneratorFunction%":{"[[Proto]]":"%InertFunction%",prototype:"%Generator%"},"%Generator%":{"[[Proto]]":"%FunctionPrototype%",constructor:"%InertGeneratorFunction%",prototype:"%GeneratorPrototype%","@@toStringTag":"string"},"%InertAsyncGeneratorFunction%":{"[[Proto]]":"%InertFunction%",prototype:"%AsyncGenerator%"},"%AsyncGenerator%":{"[[Proto]]":"%FunctionPrototype%",constructor:"%InertAsyncGeneratorFunction%",prototype:"%AsyncGeneratorPrototype%",length:"number","@@toStringTag":"string"},"%GeneratorPrototype%":{"[[Proto]]":"%IteratorPrototype%",constructor:"%Generator%",next:tn,return:tn,throw:tn,"@@toStringTag":"string"},"%AsyncGeneratorPrototype%":{"[[Proto]]":"%AsyncIteratorPrototype%",constructor:"%AsyncGenerator%",next:tn,return:tn,throw:tn,"@@toStringTag":"string"},HandledPromise:{"[[Proto]]":"Promise",applyFunction:tn,applyFunctionSendOnly:tn,applyMethod:tn,applyMethodSendOnly:tn,get:tn,getSendOnly:tn,prototype:"%PromisePrototype%",resolve:tn},ModuleSource:{"[[Proto]]":"%AbstractModuleSource%",prototype:"%ModuleSourcePrototype%"},"%ModuleSourcePrototype%":{"[[Proto]]":"%AbstractModuleSourcePrototype%",constructor:"ModuleSource","@@toStringTag":"string",bindings:rn,needsImport:rn,needsImportMeta:rn,imports:rn,exports:rn,reexports:rn},"%AbstractModuleSource%":{"[[Proto]]":"%FunctionPrototype%",prototype:"%AbstractModuleSourcePrototype%"},"%AbstractModuleSourcePrototype%":{constructor:"%AbstractModuleSource%"},Promise:{"[[Proto]]":"%FunctionPrototype%",all:tn,allSettled:tn,any:tn,prototype:"%PromisePrototype%",race:tn,reject:tn,resolve:tn,withResolvers:tn,"@@species":rn,try:tn},"%PromisePrototype%":{catch:tn,constructor:"Promise",finally:tn,then:tn,"@@toStringTag":"string","UniqueSymbol(async_id_symbol)":on,"UniqueSymbol(trigger_async_id_symbol)":on,"UniqueSymbol(destroyed)":on},"%InertAsyncFunction%":{"[[Proto]]":"%InertFunction%",prototype:"%AsyncFunctionPrototype%"},"%AsyncFunctionPrototype%":{"[[Proto]]":"%FunctionPrototype%",constructor:"%InertAsyncFunction%",length:"number","@@toStringTag":"string"},Reflect:{apply:tn,construct:tn,defineProperty:tn,deleteProperty:tn,get:tn,getOwnPropertyDescriptor:tn,getPrototypeOf:tn,has:tn,isExtensible:tn,ownKeys:tn,preventExtensions:tn,set:tn,setPrototypeOf:tn,"@@toStringTag":"string"},Proxy:{"[[Proto]]":"%FunctionPrototype%",revocable:tn},escape:tn,unescape:tn,"%UniqueCompartment%":{"[[Proto]]":"%FunctionPrototype%",prototype:"%CompartmentPrototype%",toString:tn},"%InertCompartment%":{"[[Proto]]":"%FunctionPrototype%",prototype:"%CompartmentPrototype%",toString:tn},"%CompartmentPrototype%":{constructor:"%InertCompartment%",evaluate:tn,globalThis:rn,name:rn,import:en,load:en,importNow:tn,module:tn,"@@toStringTag":"string"},lockdown:tn,harden:{...tn,isFake:"boolean"},"%InitialGetStackString%":tn};const pn=t=>typeof t==="function";function dn(t,e,r){if(H(t,e)){const o=C(t,e);if(!o||!M(o.value,r.value)||o.get!==r.get||o.set!==r.set||o.writable!==r.writable||o.enumerable!==r.enumerable||o.configurable!==r.configurable){throw v(`Conflicting definitions of ${e}`)}}tt(t,e,r)}function yn(t,e){for(const[r,o]of N(e)){dn(t,r,o)}}function gn(t,e){const r={__proto__:null};for(const[o,n]of N(e)){if(H(t,o)){r[n]=t[o]}}return r}const mn=e=>{const r=$(null);let o;const n=t=>{yn(r,F(t))};O(n);const s=()=>{for(const[t,o]of N(r)){if(Pe(o)){continue}if(!H(o,"prototype")){continue}const n=ln[t];if(typeof n!=="object"){throw v(`Expected permit object at permits.${t}`)}const s=n.prototype;if(!s){Ko(o,"prototype",false,`${t}.prototype`,e);continue}if(typeof s!=="string"||!H(ln,s)){throw v(`Unrecognized ${t}.prototype permits entry`)}const a=o.prototype;if(H(r,s)){if(r[s]!==a){throw v(`Conflicting bindings of ${s}`)}continue}r[s]=a}};O(s);const a=()=>{O(r);o=new E(It(B(r),pn));return r};O(a);const i=t=>{if(!o){throw v("isPseudoNative can only be called after finalIntrinsics")}return me(o,t)};O(i);const c={addIntrinsics:n,completePrototypes:s,finalIntrinsics:a,isPseudoNative:i};O(c);n(qo);n(gn(t,Vo));return c};const bn=(t,e)=>{const{addIntrinsics:r,finalIntrinsics:o}=mn(e);r(gn(t,Jo));return o()};function hn(t,e,r){const o=["undefined","boolean","number","string","symbol"];const n=new i(b?Nt(It(N(ln["%SharedSymbol%"]),(([t,e])=>e==="symbol"&&typeof b[t]==="symbol")),(([t])=>[b[t],`@@${t}`])):[]);function s(t,e){if(typeof e==="string"){return e}const r=Gt(n,e);if(typeof e==="symbol"){if(r){return r}else{const t=Y(e);if(t!==undefined){return`RegisteredSymbol(${t})`}else{return`Unique${m(e)}`}}}throw v(`Unexpected property name type ${t} ${e}`)}function a(e,r,o){if(Pe(r)){throw v(`Object expected: ${e}, ${m(r)}, ${o}`)}const n=R(r);if(n===null&&o===null){return}if(o!==undefined&&typeof o!=="string"){throw v(`Malformed permit ${e}.__proto__`)}if(n===t[o||"%ObjectPrototype%"]){return}throw v(`Unexpected [[Prototype]] at ${e}.__proto__ (expected ${o||"%ObjectPrototype%"})`)}function c(e,r,n,s){if(typeof s==="object"){l(e,r,s);return true}if(s===false){return false}if(typeof s==="string"){if(n==="prototype"||n==="constructor"){if(H(t,s)){if(r!==t[s]){throw v(`Does not match permit for ${e}`)}return true}}else{if($t(o,s)){if(typeof r!==s){throw v(`At ${e} expected ${s} not ${typeof r}`)}return true}}}throw v(`Unexpected property ${n} with permit ${s} at ${e}`)}function u(t,e,r,o){const n=C(e,r);if(!n){throw v(`Property ${r} not found at ${t}`)}if(H(n,"value")){if(nn(o)){throw v(`Accessor expected at ${t}`)}return c(t,n.value,r,o)}if(!nn(o)){throw v(`Accessor not expected at ${t}`)}return c(`${t}<get>`,n.get,r,o.get)&&c(`${t}<set>`,n.set,r,o.set)}function f(t,e,r){const o=r==="__proto__"?"--proto--":r;if(H(e,o)){return e[o]}if(typeof t==="function"){if(H(Xo,o)){return Xo[o]}}return undefined}function l(t,o,n){if(o===undefined||o===null){return}const i=n["[[Proto]]"];a(t,o,i);if(typeof o==="function"){e(o)}for(const e of it(o)){const a=s(t,e);const i=`${t}.${a}`;const c=f(o,n,a);if(!c||!u(i,o,e,c)){Ko(o,e,c===false,i,r)}}}l("intrinsics",t,ln)}function Sn(){try{ve.prototype.constructor("return 1")}catch(t){return O({})}const t={};function e(e,r,o){let n;try{n=(0,eval)(o)}catch(t){if(t instanceof _){return}throw t}const s=R(n);const a=function(){throw v("Function.prototype.constructor is not a valid constructor.")};x(a,{prototype:{value:s},name:{value:e,writable:false,enumerable:false,configurable:true}});x(s,{constructor:{value:a}});if(a!==ve.prototype.constructor){j(a,ve.prototype.constructor)}t[r]=a}e("Function","%InertFunction%","(function(){})");e("GeneratorFunction","%InertGeneratorFunction%","(function*(){})");e("AsyncFunction","%InertAsyncFunction%","(async function(){})");if(ke!==undefined){e("AsyncGeneratorFunction","%InertAsyncGeneratorFunction%","(async function*(){})")}return t}function En(){const t=o;const e=t.prototype;const r={now(){throw v("secure mode Calling %SharedDate%.now() throws")}};const n=({powers:r="none"}={})=>{let o;if(r==="original"){o=function e(...r){if(new.target===undefined){return et(t,undefined,r)}return rt(t,r,new.target)}}else{o=function e(...r){if(new.target===undefined){throw v("secure mode Calling %SharedDate% constructor as a function throws")}if(r.length===0){throw v("secure mode Calling new %SharedDate%() with no arguments throws")}return rt(t,r,new.target)}}x(o,{length:{value:7},prototype:{value:e,writable:false,enumerable:false,configurable:false},parse:{value:t.parse,writable:true,enumerable:false,configurable:true},UTC:{value:t.UTC,writable:true,enumerable:false,configurable:true}});return o};const s=n({powers:"original"});const a=n({powers:"none"});x(s,{now:{value:t.now,writable:true,enumerable:false,configurable:true}});x(a,{now:{value:r.now,writable:true,enumerable:false,configurable:true}});x(e,{constructor:{value:a}});return{"%InitialDate%":s,"%SharedDate%":a}}function Pn(){const t=c;const e=t;const{random:r,...o}=F(t);const n={random(){throw v("secure mode %SharedMath%.random() throws")}};const s=$(U,{...o,random:{value:n.random,writable:true,enumerable:false,configurable:true}});return{"%InitialMath%":e,"%SharedMath%":s}}function wn(t="safe"){const e=y.prototype;const r=(t={})=>{const r=function t(...e){if(new.target===undefined){return y(...e)}return rt(y,e,new.target)};x(r,{length:{value:2},prototype:{value:e,writable:false,enumerable:false,configurable:false}});if(W){const t=C(y,W);if(!t){throw v("no RegExp[Symbol.species] descriptor")}x(r,{[W]:t})}return r};const o=r();const n=r();if(t!=="unsafe"){delete e.compile}x(e,{constructor:{value:n}});return{"%InitialRegExp%":o,"%SharedRegExp%":n}}const An={"%ObjectPrototype%":{toString:true},"%FunctionPrototype%":{toString:true},"%ErrorPrototype%":{name:true},"%IteratorPrototype%":{toString:true,constructor:true,[z]:true}};const _n={"%ObjectPrototype%":{toString:true,valueOf:true},"%ArrayPrototype%":{toString:true,push:true,concat:true,[K]:true},"%FunctionPrototype%":{constructor:true,bind:true,toString:true},"%ErrorPrototype%":{constructor:true,message:true,name:true,toString:true},"%TypeErrorPrototype%":{constructor:true,message:true,name:true},"%SyntaxErrorPrototype%":{message:true,name:true},"%RangeErrorPrototype%":{message:true,name:true},"%URIErrorPrototype%":{message:true,name:true},"%EvalErrorPrototype%":{message:true,name:true},"%ReferenceErrorPrototype%":{message:true,name:true},"%AggregateErrorPrototype%":{message:true,name:true},"%PromisePrototype%":{constructor:true},"%TypedArrayPrototype%":"*","%Generator%":{constructor:true,name:true,toString:true},"%IteratorPrototype%":{toString:true,constructor:true,[z]:true}};const vn={..._n,"%ObjectPrototype%":"*","%TypedArrayPrototype%":"*","%MapPrototype%":"*","%SetPrototype%":"*"};function In(t,e,{warn:r},o=[]){const n=new g(o);function s(t,e,o,s){if("value"in s&&s.configurable){const{value:a}=s;const i=Yt(n,o);const{get:c,set:u}=C({get[o](){return a},set[o](n){if(e===this){throw v(`Cannot assign to read only property '${m(o)}' of '${t}'`)}if(H(this,o)){this[o]=n}else{if(i){r(v(`Override property ${o}`))}tt(this,o,{value:n,writable:true,enumerable:true,configurable:true})}}},o);tt(c,"originalValue",{value:a,writable:false,enumerable:false,configurable:false});tt(e,o,{get:c,set:u,enumerable:s.enumerable,configurable:s.configurable})}}function a(t,e,r){const o=C(e,r);if(!o){return}s(t,e,r,o)}function i(t,e){const r=F(e);if(!r){return}Tt(it(r),(o=>s(t,e,o,r[o])))}function c(t,e,r){for(const o of it(r)){const n=C(e,o);if(!n||n.get||n.set){continue}const s=`${t}.${m(o)}`;const u=r[o];if(u===true){a(s,e,o)}else if(u==="*"){i(s,n.value)}else if(!Pe(u)){c(s,n.value,u)}else{throw v(`Unexpected override enablement plan ${s}`)}}}let u;switch(e){case"min":{u=An;break}case"moderate":{u=_n;break}case"severe":{u=vn;break}default:{throw v(`unrecognized overrideTaming ${e}`)}}c("root",t,u)}const{Fail:Tn,quote:$n}=Uo;const xn=/^(\w*[a-z])Locale([A-Z]\w*)$/;const Nn={localeCompare(t){if(this===null||this===undefined){throw v('Cannot localeCompare with null or undefined "this" value')}const e=`${this}`;const r=`${t}`;if(e<r){return-1}if(e>r){return 1}e===r||Tn`expected ${$n(e)} and ${$n(r)} to compare`;return 0},toString(){return`${this}`}};const On=Nn.localeCompare;const Cn=Nn.toString;function Fn(t,e="safe"){if(e==="unsafe"){return}tt(m.prototype,"localeCompare",{value:On});for(const e of k(t)){const r=t[e];if(!Pe(r)){for(const t of k(r)){const e=Xt(xn,t);if(e){typeof r[t]==="function"||Tn`expected ${$n(t)} to be a function`;const o=`${e[1]}${e[2]}`;const n=r[o];typeof n==="function"||Tn`function ${$n(o)} not found`;tt(r,t,{value:n})}}}}tt(u.prototype,"toLocaleString",{value:Cn})}const kn=t=>{const e={eval(e){if(typeof e!=="string"){return e}return t(e)}}.eval;return e};const{Fail:Rn}=Uo;const Mn=t=>{const e=function e(r){const o=`${Ct(arguments)||""}`;const n=`${xt(arguments,",")}`;new ve(n,"");new ve(o);const s=`(function anonymous(${n}\n) {\n${o}\n})`;return t(s)};x(e,{prototype:{value:ve.prototype,writable:false,enumerable:false,configurable:false}});R(ve)===ve.prototype||Rn`Function prototype is the same accross compartments`;R(e)===ve.prototype||Rn`Function constructor prototype is the same across compartments`;return e};const Ln=t=>{tt(t,V,O(T($(null),{set:O((()=>{throw v(`Cannot set Symbol.unscopables of a Compartment's globalThis`)})),enumerable:false,configurable:false})))};const Un=t=>{for(const[e,r]of N(qo)){tt(t,e,{value:r,writable:false,enumerable:false,configurable:false})}};const Dn=(t,{intrinsics:e,newGlobalPropertyNames:r,makeCompartmentConstructor:o,markVirtualizedNativeFunction:n,parentCompartment:s})=>{for(const[r,o]of N(Vo)){if(H(e,o)){tt(t,r,{value:e[o],writable:true,enumerable:false,configurable:true})}}for(const[o,n]of N(r)){if(H(e,n)){tt(t,o,{value:e[n],writable:true,enumerable:false,configurable:true})}}const a={globalThis:t};a.Compartment=O(o(o,e,n,{parentCompartment:s,enforceNew:true}));for(const[e,r]of N(a)){tt(t,e,{value:r,writable:true,enumerable:false,configurable:true});if(typeof r==="function"){n(r)}}};const jn=(t,e,r)=>{{const o=O(kn(e));r(o);tt(t,"eval",{value:o,writable:true,enumerable:false,configurable:true})}{const o=O(Mn(e));r(o);tt(t,"Function",{value:o,writable:true,enumerable:false,configurable:true})}};const{Fail:Bn,quote:Gn}=Uo;const Hn=O({__proto__:null});const Wn=new p(Hn,O({get(t,e){Bn`Please report unexpected scope handler trap: ${Gn(m(e))}`}}));const zn={get(t,e){return undefined},set(t,e,r){throw A(`${m(e)} is not defined`)},has(t,e){return true},getPrototypeOf(t){return null},getOwnPropertyDescriptor(t,e){const r=Gn(m(e));console.warn(`getOwnPropertyDescriptor trap on scopeTerminatorHandler for ${r}`,v().stack);return undefined},ownKeys(t){return[]}};const Kn=O($(Wn,F(zn)));const qn=new p(Hn,Kn);const Vn=O({__proto__:null});const Yn=t=>{const e={...Kn,set(e,r,o){return ut(t,r,o)},has(t,e){return true}};const r=O($(Wn,F(e)));const o=new p(Vn,r);return o};O(Yn);const{Fail:Jn}=Uo;const Qn=()=>{const t=$(null);const e=O({eval:{get(){delete t.eval;return _e},enumerable:false,configurable:true}});const r={evalScope:t,allowNextEvalToBeUnsafe(){const{revoked:o}=r;if(o!==null){Jn`a handler did not reset allowNextEvalToBeUnsafe ${o.err}`}x(t,e)},revoked:null};return r};const Xn="\\s*[@#]\\s*([a-zA-Z][a-zA-Z0-9]*)\\s*=\\s*([^\\s\\*]*)";const Zn=new y(`(?:\\s*//${Xn}|/\\*${Xn}\\s*\\*/)\\s*$`);const ts=t=>{let e="<unknown>";while(t.length>0){const r=Xt(Zn,t);if(r===null){break}t=ie(t,0,t.length-r[0].length);if(r[3]==="sourceURL"){e=r[4]}else if(r[1]==="sourceURL"){e=r[2]}}return e};function es(t,e){const r=ae(t,e);if(r<0){return-1}const o=t[r]==="\n"?1:0;return ce(ie(t,0,r),"\n").length+o}const rs=new y(`(?:${"<"}!--|--${">"})`,"g");const os=t=>{const e=es(t,rs);if(e<0){return t}const r=ts(t);throw _(`Possible HTML comment rejected at ${r}:${e}. (SES_HTML_COMMENT_REJECTED)`)};const ns=t=>{const e=t=>t[0]==="<"?"< ! --":"-- >";return se(t,rs,e)};const ss=new y("(^|[^.]|\\.\\.\\.)\\bimport(\\s*(?:\\(|/[/*]))","g");const as=t=>{const e=es(t,ss);if(e<0){return t}const r=ts(t);throw _(`Possible import expression rejected at ${r}:${e}. (SES_IMPORT_REJECTED)`)};const is=t=>{const e=(t,e,r)=>`${e}__import__${r}`;return se(t,ss,e)};const cs=new y("(^|[^.])\\beval(\\s*\\()","g");const us=t=>{const e=es(t,cs);if(e<0){return t}const r=ts(t);throw _(`Possible direct eval expression rejected at ${r}:${e}. (SES_EVAL_REJECTED)`)};const fs=t=>{t=os(t);t=as(t);return t};const ls=(t,e)=>{for(let r=0,o=e.length;r<o;r+=1){const o=e[r];t=o(t)}return t};O({rejectHtmlComments:O(os),evadeHtmlCommentTest:O(ns),rejectImportExpressions:O(as),evadeImportExpressionTest:O(is),rejectSomeDirectEvalExpressions:O(us),mandatoryTransforms:O(fs),applyTransforms:O(ls)});const ps=["await","break","case","catch","class","const","continue","debugger","default","delete","do","else","export","extends","finally","for","function","if","import","in","instanceof","new","return","super","switch","this","throw","try","typeof","var","void","while","with","yield","let","static","enum","implements","package","protected","interface","private","public","await","null","true","false","this","arguments"];const ds=/^[a-zA-Z_$][\w$]*$/;const ys=t=>t!=="eval"&&!$t(ps,t)&&Qt(ds,t);function gs(t,e){const r=C(t,e);return r&&r.configurable===false&&r.writable===false&&H(r,"value")}const ms=(t,e={})=>{const r=k(t);const o=k(e);const n=It(o,(t=>ys(t)&&gs(e,t)));const s=It(r,(e=>!$t(o,e)&&ys(e)&&gs(t,e)));return{globalObjectConstants:s,moduleLexicalConstants:n}};function bs(t,e){if(t.length===0)return"";return`const {${xt(t,",")}} = this.${e};`}const hs=t=>{const{globalObjectConstants:e,moduleLexicalConstants:r}=ms(t.globalObject,t.moduleLexicals);const o=bs(e,"globalObject");const n=bs(r,"moduleLexicals");const s=ve(`\n    with (this.scopeTerminator) {\n      with (this.globalObject) {\n        with (this.moduleLexicals) {\n          with (this.evalScope) {\n            ${o}\n            ${n}\n            return function() {\n              'use strict';\n              return eval(arguments[0]);\n            };\n          }\n        }\n      }\n    }\n  `);return et(s,t,[])};const{Fail:Ss}=Uo;const Es=({globalObject:t,moduleLexicals:e={},globalTransforms:r=[],sloppyGlobalsMode:o=false})=>{const n=o?Yn(t):qn;const s=Qn();const{evalScope:a}=s;const i=O({evalScope:a,moduleLexicals:e,globalObject:t,scopeTerminator:n});let c;const u=()=>{if(!c){c=hs(i)}};const f=(e,o)=>{const{localTransforms:n=[]}=o||{};u();e=ls(e,Ot([n,r,[fs]],Ae));let i;try{s.allowNextEvalToBeUnsafe();return et(c,t,[e])}catch(t){i=t;throw t}finally{const t="eval"in a;delete a.eval;if(t){s.revoked={err:i};Ss`handler did not reset allowNextEvalToBeUnsafe ${i}`}}};return{safeEvaluate:f}};const Ps=") { [native code] }";let ws;const As=()=>{if(ws===undefined){const t=new E;const e={toString(){const e=be(this);if(te(e,Ps)||!me(t,this)){return e}return`function ${this.name}() { [native code] }`}};tt(St,"toString",{value:e.toString});ws=O((e=>ge(t,e)))}return ws};function _s(e="safe"){if(e==="unsafe"){return}const r=t.process||undefined;if(typeof r==="object"){const t=C(r,"domain");if(t!==undefined&&t.get!==undefined){throw v(`SES failed to lockdown, Node.js domains have been initialized (SES_NO_DOMAINS)`)}tt(r,"domain",{value:null,configurable:false,writable:false,enumerable:false})}}const vs=()=>{const e={};const r=t.ModuleSource;if(r!==undefined){e.ModuleSource=r;function o(){}const n=R(r);if(n===St){j(r,o);e["%AbstractModuleSource%"]=o;e["%AbstractModuleSourcePrototype%"]=o.prototype}else{e["%AbstractModuleSource%"]=n;e["%AbstractModuleSourcePrototype%"]=n.prototype}const s=r.prototype;if(s!==undefined){e["%ModuleSourcePrototype%"]=s;const a=R(s);if(a===U){j(r.prototype,o.prototype)}}}return e};const Is=(t,e)=>tt(e,"name",{value:t});const Ts=O([["debug","debug"],["log","log"],["info","info"],["warn","warn"],["error","error"],["trace","log"],["dirxml","log"],["group","log"],["groupCollapsed","log"]]);const $s=O([["assert","error"],["timeLog","log"],["clear",undefined],["count","info"],["countReset",undefined],["dir","log"],["groupEnd","log"],["table","log"],["time","info"],["timeEnd","info"],["profile",undefined],["profileEnd",undefined],["timeStamp",undefined]]);const xs={NOTE:"ERROR_NOTE:",MESSAGE:"ERROR_MESSAGE:",CAUSE:"cause:",ERRORS:"errors:"};O(xs);const Ns=(t,e)=>{if(!t){return undefined}const{getStackString:r,tagError:o,takeMessageLogArgs:n,takeNoteLogArgsArray:s}=e;const a=(t,e)=>{const r=Nt(t,(t=>{if(we(t)){Ft(e,t);return`(${o(t)})`}return t}));return r};const i=(e,r,n,s,i)=>{const c=o(r);const u=n===xs.MESSAGE?`${c}:`:`${c} ${n}`;const f=a(s,i);t[e](u,...f)};const c=(e,r,o=undefined)=>{if(r.length===0){return}if(r.length===1&&o===undefined){l(e,r[0]);return}let n;if(r.length===1){n=`Nested error`}else{n=`Nested ${r.length} errors`}if(o!==undefined){n=`${n} under ${o}`}t.group(n);try{for(const t of r){l(e,t)}}finally{if(t.groupEnd){t.groupEnd()}}};const u=new E;const f=t=>(e,r)=>{const n=[];i(t,e,xs.NOTE,r,n);c(t,n,o(e))};const l=(e,a)=>{if(me(u,a)){return}const l=o(a);ge(u,a);const p=[];const d=n(a);const y=s(a,f(e));if(d===undefined){t[e](`${l}:`,a.message)}else{i(e,a,xs.MESSAGE,d,p)}let g=r(a);if(typeof g==="string"&&g.length>=1&&!te(g,"\n")){g+="\n"}t[e](g);if(a.cause){i(e,a,xs.CAUSE,[a.cause],p)}if(a.errors){i(e,a,xs.ERRORS,a.errors,p)}for(const t of y){i(e,a,xs.NOTE,t,p)}c(e,p,l)};const p=Nt(Ts,(([e,r])=>{const o=Is(e,((...r)=>{const o=[];const n=a(r,o);if(t[e]){t[e](...n)}c(e,o)}));return[e,O(o)]}));const d=It($s,(([e,r])=>e in t));const y=Nt(d,(([e,r])=>{const o=Is(e,((...r)=>{t[e](...r);return undefined}));return[e,O(o)]}));const g=G([...p,...y]);return O(g)};O(Ns);const Os=(t,e,r)=>{const[o,...n]=ce(t,e);const s=Ot(n,(t=>[e,...r,t]));return["",o,...s]};const Cs=t=>{const e=e=>{const r=[];const o=(...t)=>{if(r.length>0){t=Ot(t,(t=>typeof t==="string"&&ee(t,"\n")?Os(t,"\n",r):[t]));t=[...r,...t]}return e(...t)};const n=G([...Nt(Ts,(([t])=>[t,Is(t,((...t)=>o(...t)))])),...Nt($s,(([t])=>[t,Is(t,((...e)=>o(t,...e)))]))]);for(const t of["group","groupCollapsed"]){if(n[t]){n[t]=Is(t,((...t)=>{if(t.length>=1){o(...t)}Ft(r," ")}))}else{n[t]=Is(t,(()=>{}))}}n.groupEnd=Is("groupEnd",n.groupEnd?(...t)=>{Ct(r)}:()=>{});harden(n);const s=Ns(n,t);return s};return O(e)};O(Cs);const Fs=t=>{if(n===undefined){return undefined}let e=0;const r=new i;const o=t=>{Wt(r,t)};const s=new S;const a=e=>{if(Ht(r,e)){const n=Gt(r,e);o(e);t(n)}};const c=new n(a);const u=(t,o)=>{e+=1;const n=e;Bt(r,n,t);ye(s,o,n);Ee(c,o,n,o)};const f=t=>{const e=pe(s,t);o(e)};const l=()=>{for(const[e,n]of zt(r)){o(e);t(n)}};return{rejectionHandledHandler:f,unhandledRejectionHandler:u,processTerminationHandler:l}};const ks=t=>{throw v(t)};const Rs=(t,e)=>O(((...r)=>et(t,e,r)));const Ms=(e="safe",r="platform",o="report",n=undefined)=>{let s;if(n===undefined){s=Mo}else{s={...Mo,getStackString:n}}const a=typeof t.console!=="undefined"?t.console:typeof t.print==="function"?(t=>O({debug:t,log:t,info:t,warn:t,error:t}))(Rs(t.print)):undefined;if(a&&a.log){for(const t of["warn","error"]){if(!a[t]){tt(a,t,{value:Rs(a.log,a)})}}}const i=e==="unsafe"?a:Ns(a,s);const c=t.process||undefined;if(r!=="none"&&typeof c==="object"&&typeof c.on==="function"){let t;if(r==="platform"||r==="exit"){const{exit:e}=c;typeof e==="function"||ks("missing process.exit");t=()=>e(c.exitCode||-1)}else if(r==="abort"){t=c.abort;typeof t==="function"||ks("missing process.abort")}c.on("uncaughtException",(e=>{i.error("SES_UNCAUGHT_EXCEPTION:",e);if(t){t()}}))}if(o!=="none"&&typeof c==="object"&&typeof c.on==="function"){const t=t=>{i.error("SES_UNHANDLED_REJECTION:",t)};const e=Fs(t);if(e){c.on("unhandledRejection",e.unhandledRejectionHandler);c.on("rejectionHandled",e.rejectionHandledHandler);c.on("exit",e.processTerminationHandler)}}const u=t.window||undefined;if(r!=="none"&&typeof u==="object"&&typeof u.addEventListener==="function"){u.addEventListener("error",(t=>{t.preventDefault();i.error("SES_UNCAUGHT_EXCEPTION:",t.error);if(r==="exit"||r==="abort"){u.location.href=`about:blank`}}))}if(o!=="none"&&typeof u==="object"&&typeof u.addEventListener==="function"){const t=t=>{i.error("SES_UNHANDLED_REJECTION:",t)};const e=Fs(t);if(e){u.addEventListener("unhandledrejection",(t=>{t.preventDefault();e.unhandledRejectionHandler(t.reason,t.promise)}));u.addEventListener("rejectionhandled",(t=>{t.preventDefault();e.rejectionHandledHandler(t.promise)}));u.addEventListener("beforeunload",(t=>{e.processTerminationHandler()}))}}return{console:i}};const Ls=["getTypeName","getFunctionName","getMethodName","getFileName","getLineNumber","getColumnNumber","getEvalOrigin","isToplevel","isEval","isNative","isConstructor","isAsync","getPosition","getScriptNameOrSourceURL","toString"];const Us=t=>{const e=e=>{const r=t[e];return[e,()=>et(r,t,[])]};const r=G(Nt(Ls,e));return $(r,{})};const Ds=t=>Nt(t,Us);const js=/\/node_modules\//;const Bs=/^(?:node:)?internal\//;const Gs=/\/packages\/ses\/src\/error\/assert\.js$/;const Hs=/\/packages\/eventual-send\/src\//;const Ws=/\/packages\/ses-ava\/src\/ses-ava-test\.js$/;const zs=[js,Bs,Gs,Hs,Ws];const Ks=t=>{if(!t){return true}for(const e of zs){if(Qt(e,t)){return false}}return true};const qs=/^((?:.*[( ])?)[:/\w_-]*\/\.\.\.\/(.+)$/;const Vs=/^((?:.*[( ])?)\.\.\.\/(.+)$/;const Ys=/^((?:.*[( ])?)[:/\w_-]*\/(packages\/.+)$/;const Js=/^((?:.*[( ])?)file:\/\/([^/].*)$/;const Qs=[qs,Vs,Ys,Js];const Xs=t=>{for(const e of Qs){const r=Xt(e,t);if(r){return xt(kt(r,1),"")}}return t};const Zs=(t,e,r,o)=>{if(r==="unsafe-debug"){throw v("internal: v8+unsafe-debug special case should already be done")}const n=t.captureStackTrace;const s=o==="concise"||o==="omit-frames";const a=o==="concise"||o==="shorten-paths";const i=t=>{if(s){return Ks(t.getFileName())}return true};const c=t=>{let e=`${t}`;if(a){e=Xs(e)}return`\n  at ${e}`};const u=(t,e)=>xt(Nt(It(e,i),c),"");const f=new S;const l={captureStackTrace(e,r=l.captureStackTrace){if(typeof n==="function"){et(n,t,[e,r]);return}ut(e,"stack","")},getStackString(t){let e=pe(f,t);if(e===undefined){e=pe(f,t);if(!e){e={stackString:""};ye(f,t,e)}}if(e.stackString!==undefined){return e.stackString}const r=u(t,e.callSites);ye(f,t,{stackString:r});return r},prepareStackTrace(t,e){if(r==="unsafe"){const r=u(t,e);ye(f,t,{stackString:r});return`${t}${r}`}else{ye(f,t,{callSites:e});return""}}};const p=l.prepareStackTrace;t.prepareStackTrace=p;const d=new E([p]);const y=t=>{if(me(d,t)){return t}const e={prepareStackTrace(e,r){ye(f,e,{callSites:r});return t(e,Ds(r))}};ge(d,e.prepareStackTrace);return e.prepareStackTrace};x(e,{captureStackTrace:{value:l.captureStackTrace,writable:true,enumerable:false,configurable:true},prepareStackTrace:{get(){return t.prepareStackTrace},set(e){if(typeof e==="function"){const r=y(e);t.prepareStackTrace=r}else{t.prepareStackTrace=p}},enumerable:false,configurable:true}});return l.getStackString};const ta=C(P.prototype,"stack");const ea=ta&&ta.get;const ra={getStackString(t){if(typeof ea==="function"){return et(ea,t,[])}else if("stack"in t){return`${t.stack}`}return""}};let oa=ra.getStackString;function na(t="safe",e="concise"){const r=P.prototype;const{captureStackTrace:o}=P;const n=typeof o==="function"?"v8":"unknown";const s=(t={})=>{const e=function t(...r){let s;if(new.target===undefined){s=et(P,this,r)}else{s=rt(P,r,new.target)}if(n==="v8"){et(o,P,[s,e])}return s};x(e,{length:{value:1},prototype:{value:r,writable:false,enumerable:false,configurable:false}});return e};const a=s({});const i=s({});x(r,{constructor:{value:i}});for(const t of Qo){j(t,i)}x(a,{stackTraceLimit:{get(){if(typeof P.stackTraceLimit==="number"){return P.stackTraceLimit}return undefined},set(t){if(typeof t!=="number"){return}if(typeof P.stackTraceLimit==="number"){P.stackTraceLimit=t;return}},enumerable:false,configurable:true}});if(t==="unsafe-debug"&&n==="v8"){x(a,{prepareStackTrace:{get(){return P.prepareStackTrace},set(t){P.prepareStackTrace=t},enumerable:false,configurable:true},captureStackTrace:{value:P.captureStackTrace,writable:true,enumerable:false,configurable:true}});const t=F(a);x(i,{stackTraceLimit:t.stackTraceLimit,prepareStackTrace:t.prepareStackTrace,captureStackTrace:t.captureStackTrace});return{"%InitialGetStackString%":oa,"%InitialError%":a,"%SharedError%":i}}x(i,{stackTraceLimit:{get(){return undefined},set(t){},enumerable:false,configurable:true}});if(n==="v8"){x(i,{prepareStackTrace:{get(){return()=>""},set(t){},enumerable:false,configurable:true},captureStackTrace:{value:(t,e)=>{tt(t,"stack",{value:""})},writable:false,enumerable:false,configurable:true}})}if(n==="v8"){oa=Zs(P,a,t,e)}else if(t==="unsafe"||t==="unsafe-debug"){x(r,{stack:{get(){return oa(this)},set(t){x(this,{stack:{value:t,writable:true,enumerable:true,configurable:true}})}}})}else{x(r,{stack:{get(){return`${this}`},set(t){x(this,{stack:{value:t,writable:true,enumerable:true,configurable:true}})}}})}return{"%InitialGetStackString%":oa,"%InitialError%":a,"%SharedError%":i}}const sa=()=>{};const aa=async(t,e,r)=>{await null;const o=t(...e);let n=oe(o);while(!n.done){try{const t=await n.value;n=oe(o,t)}catch(t){n=ne(o,r(t))}}return n.value};const ia=(t,e)=>{const r=t(...e);let o=oe(r);while(!o.done){try{o=oe(r,o.value)}catch(t){o=ne(r,t)}}return o.value};const ca=(t,e)=>O({compartment:t,specifier:e});const ua=(t,e,r)=>{const o=$(null);for(const n of t){const t=e(n,r);o[n]=t}return O(o)};const fa=(t,e,r,o,n,s,a,i,c)=>{const{resolveHook:u,name:f}=pe(t,r);const{imports:l}=n;if(!ft(l)||Rt(l,(t=>typeof t!=="string"))){throw No(wo`Invalid module source: 'imports' must be an array of strings, got ${l} for module ${mo(o)} of compartment ${mo(f)}`)}const p=ua(l,u,o);const d=O({compartment:r,moduleSource:n,moduleSpecifier:o,resolvedImports:p,importMeta:c});for(const o of B(p)){s(pa,[t,e,r,o,s,a,i])}return d};function*la(t,e,r,o,n,s,a){const{importHook:i,importNowHook:c,moduleMap:u,moduleMapHook:f,moduleRecords:l,parentCompartment:p}=pe(t,r);if(Ht(l,o)){return Gt(l,o)}let d=u[o];if(d===undefined&&f!==undefined){d=f(o)}if(d===undefined){const t=s(i,c);if(t===undefined){const t=s("importHook","importNowHook");throw No(wo`${ho(t)} needed to load module ${mo(o)} in compartment ${mo(r.name)}`)}d=t(o);if(!de(e,d)){d=yield d}}if(typeof d==="string"){throw No(wo`Cannot map module ${mo(o)} to ${mo(d)} in parent compartment, use {source} module descriptor`,v)}else if(!Pe(d)){let i=pe(e,d);if(i!==undefined){d=i}if(d.namespace!==undefined){if(typeof d.namespace==="string"){const{compartment:i=p,namespace:c}=d;if(Pe(i)||!de(t,i)){throw No(wo`Invalid compartment in module descriptor for specifier ${mo(o)} in compartment ${mo(r.name)}`)}const u=yield pa(t,e,i,c,n,s,a);Bt(l,o,u);return u}if(!Pe(d.namespace)){const{namespace:c}=d;i=pe(e,c);if(i!==undefined){d=i}else{const i=k(c);const u={imports:[],exports:i,execute(t){for(const e of i){t[e]=c[e]}}};const f=undefined;const p=fa(t,e,r,o,u,n,s,a,f);Bt(l,o,p);return p}}else{throw No(wo`Invalid compartment in module descriptor for specifier ${mo(o)} in compartment ${mo(r.name)}`)}}if(d.source!==undefined){if(typeof d.source==="string"){const{source:i,specifier:c=o,compartment:u=p,importMeta:f=undefined}=d;const y=yield pa(t,e,u,i,n,s,a);const{moduleSource:g}=y;const m=fa(t,e,r,c,g,n,s,a,f);Bt(l,o,m);return m}else{const{source:i,specifier:c=o,importMeta:u}=d;const f=fa(t,e,r,c,i,n,s,a,u);Bt(l,o,f);return f}}if(d.archive!==undefined){throw No(wo`Unsupported archive module descriptor for specifier ${mo(o)} in compartment ${mo(r.name)}`)}if(d.record!==undefined){const{compartment:i=r,specifier:c=o,record:u,importMeta:f}=d;const p=fa(t,e,i,c,u,n,s,a,f);Bt(l,o,p);Bt(l,c,p);return p}if(d.compartment!==undefined&&d.specifier!==undefined){if(Pe(d.compartment)||!de(t,d.compartment)||typeof d.specifier!=="string"){throw No(wo`Invalid compartment in module descriptor for specifier ${mo(o)} in compartment ${mo(r.name)}`)}const i=yield pa(t,e,d.compartment,d.specifier,n,s,a);Bt(l,o,i);return i}const c=d;const u=fa(t,e,r,o,c,n,s,a);Bt(l,o,u);return u}else{throw No(wo`module descriptor must be a string or object for specifier ${mo(o)} in compartment ${mo(r.name)}`)}}const pa=(t,e,r,o,n,s,a)=>{const{name:c}=pe(t,r);let u=Gt(a,r);if(u===undefined){u=new i;Bt(a,r,u)}let f=Gt(u,o);if(f!==undefined){return f}f=s(aa,ia)(la,[t,e,r,o,n,s,a],(t=>{ko(t,wo`${t.message}, loading ${mo(o)} in compartment ${mo(c)}`);throw t}));Bt(u,o,f);return f};const da=({errors:t=[],noAggregateErrors:e=false}={})=>{const r=new g;const o=(o,n)=>{qt(r,Se(o(...n),sa,(r=>{if(e){throw r}else{Ft(t,r)}})))};const n=async()=>{await null;for(const t of r){await t}};return{enqueueJob:o,drainQueue:n,errors:t}};const ya=({errors:t=[],noAggregateErrors:e=false}={})=>{let r=[];let o=[];const n=(t,e)=>{Ft(o,[t,e])};const s=()=>{for(const[o,n]of r){try{o(...n)}catch(r){if(e){throw r}else{Ft(t,r)}}}r=o;o=[];if(r.length>0)s()};return{enqueueJob:n,drainQueue:s,errors:t}};const ga=({errors:t,errorPrefix:e})=>{if(t.length>0){const r=Xe("COMPARTMENT_LOAD_ERRORS","",["verbose"])==="verbose";throw v(`${e} (${t.length} underlying failures: ${xt(Nt(t,(t=>t.message+(r?t.stack:""))),", ")}`)}};const ma=(t,e)=>e;const ba=(t,e)=>t;const ha=async(t,e,r,o,{noAggregateErrors:n=false}={})=>{const{name:s}=pe(t,r);const a=new i;const{enqueueJob:c,drainQueue:u,errors:f}=da({noAggregateErrors:n});c(pa,[t,e,r,o,c,ba,a]);await u();ga({errors:f,errorPrefix:`Failed to load module ${mo(o)} in package ${mo(s)}`})};const Sa=(t,e,r,o,{noAggregateErrors:n=false}={})=>{const{name:s}=pe(t,r);const a=new i;const{enqueueJob:c,drainQueue:u,errors:f}=ya({noAggregateErrors:n});c(pa,[t,e,r,o,c,ma,a]);u();ga({errors:f,errorPrefix:`Failed to load module ${mo(o)} in package ${mo(s)}`})};const{quote:Ea}=Uo;const Pa=()=>{let t=false;const e=$(null,{[z]:{value:"Module",writable:false,enumerable:false,configurable:false}});return O({activate(){t=true},exportsTarget:e,exportsProxy:new p(e,{get(r,o,n){if(!t){throw v(`Cannot get property ${Ea(o)} of module exports namespace, the module has not yet begun to execute`)}return ot(e,o,n)},set(t,e,r){throw v(`Cannot set property ${Ea(e)} of module exports namespace`)},has(r,o){if(!t){throw v(`Cannot check property ${Ea(o)}, the module has not yet begun to execute`)}return st(e,o)},deleteProperty(t,e){throw v(`Cannot delete property ${Ea(e)}s of module exports namespace`)},ownKeys(r){if(!t){throw v("Cannot enumerate keys, the module has not yet begun to execute")}return it(e)},getOwnPropertyDescriptor(r,o){if(!t){throw v(`Cannot get own property descriptor ${Ea(o)}, the module has not yet begun to execute`)}return nt(e,o)},preventExtensions(r){if(!t){throw v("Cannot prevent extensions of module exports namespace, the module has not yet begun to execute")}return ct(e)},isExtensible(){if(!t){throw v("Cannot check extensibility of module exports namespace, the module has not yet begun to execute")}return at(e)},getPrototypeOf(t){return null},setPrototypeOf(t,e){throw v("Cannot set prototype of module exports namespace")},defineProperty(t,e,r){throw v(`Cannot define property ${Ea(e)} of module exports namespace`)},apply(t,e,r){throw v("Cannot call module exports namespace, it is not a function")},construct(t,e){throw v("Cannot construct module exports namespace, it is not a constructor")}})})};const wa=(t,e,r,o)=>{const{deferredExports:n}=e;if(!Ht(n,o)){const e=Pa();ye(r,e.exportsProxy,ca(t,o));Bt(n,o,e)}return Gt(n,o)};const Aa=(t,e)=>{const{sloppyGlobalsMode:r=false,__moduleShimLexicals__:o=undefined}=e;let n;if(o===undefined&&!r){({safeEvaluate:n}=t)}else{let{globalTransforms:e}=t;const{globalObject:s}=t;let a;if(o!==undefined){e=undefined;a=$(null,F(o))}({safeEvaluate:n}=Es({globalObject:s,moduleLexicals:a,globalTransforms:e,sloppyGlobalsMode:r}))}return{safeEvaluate:n}};const _a=(t,e,r)=>{if(typeof e!=="string"){throw v("first argument of evaluate() must be a string")}const{transforms:o=[],__evadeHtmlCommentTest__:n=false,__evadeImportExpressionTest__:s=false,__rejectSomeDirectEvalExpressions__:a=true}=r;const i=[...o];if(n===true){Ft(i,ns)}if(s===true){Ft(i,is)}if(a===true){Ft(i,us)}const{safeEvaluate:c}=Aa(t,r);return c(e,{localTransforms:i})};const{quote:va}=Uo;const Ia=(t,e,r,o,n,s)=>{const{exportsProxy:a,exportsTarget:i,activate:c}=wa(r,pe(t,r),o,n);const u=$(null);if(e.exports){if(!ft(e.exports)||Rt(e.exports,(t=>typeof t!=="string"))){throw v(`SES virtual module source "exports" property must be an array of strings for module ${n}`)}Tt(e.exports,(t=>{let e=i[t];const r=[];const o=()=>e;const n=t=>{e=t;for(const e of r){e(t)}};tt(i,t,{get:o,set:n,enumerable:true,configurable:false});u[t]=t=>{Ft(r,t);t(e)}}));u["*"]=t=>{t(i)}}const f={activated:false};return O({notifiers:u,exportsProxy:a,execute(){if(st(f,"errorFromExecute")){throw f.errorFromExecute}if(!f.activated){c();f.activated=true;try{e.execute(i,r,s)}catch(t){f.errorFromExecute=t;throw t}}}})};const Ta=(t,e,r,o)=>{const{compartment:n,moduleSpecifier:s,moduleSource:a,importMeta:i}=r;const{reexports:c=[],__syncModuleProgram__:u,__fixedExportMap__:f={},__liveExportMap__:l={},__reexportMap__:p={},__needsImport__:d=false,__needsImportMeta__:y=false,__syncModuleFunctor__:g}=a;const m=pe(t,n);const{__shimTransforms__:b,resolveHook:h,importMetaHook:S,compartmentImport:E}=m;const{exportsProxy:P,exportsTarget:w,activate:I}=wa(n,m,e,s);const x=$(null);const C=$(null);const F=$(null);const k=$(null);const R=$(null);if(i){T(R,i)}if(y&&S){S(s,R)}let M;if(d){M=async t=>E(h(t,s))}const U=$(null);const D=$(null);Tt(N(f),(([t,[e]])=>{let r=U[e];if(!r){let t;let o=true;let n=[];const s=()=>{if(o){throw A(`binding ${va(e)} not yet initialized`)}return t};const a=O((r=>{if(!o){throw v(`Internal: binding ${va(e)} already initialized`)}t=r;const s=n;n=null;o=false;for(const t of s||[]){t(r)}return r}));const i=e=>{if(e===a){return}if(o){Ft(n||[],e)}else{e(t)}};r={get:s,notify:i};U[e]=r;F[e]=a}x[t]={get:r.get,set:undefined,enumerable:true,configurable:false};D[t]=r.notify}));Tt(N(l),(([t,[e,r]])=>{let o=U[e];if(!o){let n;let s=true;const a=[];const i=()=>{if(s){throw A(`binding ${va(t)} not yet initialized`)}return n};const c=O((t=>{n=t;s=false;for(const e of a){e(t)}}));const u=t=>{if(s){throw A(`binding ${va(e)} not yet initialized`)}n=t;for(const e of a){e(t)}};const f=t=>{if(t===c){return}Ft(a,t);if(!s){t(n)}};o={get:i,notify:f};U[e]=o;if(r){tt(C,e,{get:i,set:u,enumerable:true,configurable:false})}k[e]=c}x[t]={get:o.get,set:undefined,enumerable:true,configurable:false};D[t]=o.notify}));const j=t=>{t(w)};D["*"]=j;function B(t){const e=$(null);e.default=false;for(const[r,n]of t){const t=Gt(o,r);t.execute();const{notifiers:s}=t;for(const[t,e]of n){const o=s[t];if(!o){throw _(`The requested module '${r}' does not provide an export named '${t}'`)}for(const t of e){o(t)}}if($t(c,r)){for(const[t,r]of N(s)){if(e[t]===undefined){e[t]=r}else{e[t]=false}}}if(p[r]){for(const[t,o]of p[r]){e[o]=s[t]}}}for(const[t,r]of N(e)){if(!D[t]&&r!==false){D[t]=r;let e;const o=t=>e=t;r(o);x[t]={get(){return e},set:undefined,enumerable:true,configurable:false}}}Tt(Mt(L(x)),(t=>tt(w,t,x[t])));O(w);I()}let G;if(g!==undefined){G=g}else{G=_a(m,u,{transforms:b,__moduleShimLexicals__:C})}let H=false;let W;function z(){if(G){const t=G;G=null;try{t(O({imports:O(B),onceVar:O(F),liveVar:O(k),import:M,importMeta:R}))}catch(t){H=true;W=t}}if(H){throw W}}return O({notifiers:D,exportsProxy:P,execute:z})};const{Fail:$a,quote:xa}=Uo;const Na=(t,e,r,o)=>{const{name:n,moduleRecords:s}=pe(t,r);const a=Gt(s,o);if(a===undefined){throw A(`Missing link to module ${xa(o)} from compartment ${xa(n)}`)}return Ma(t,e,a)};function Oa(t){return typeof t.__syncModuleProgram__==="string"}function Ca(t,e){const{__fixedExportMap__:r,__liveExportMap__:o}=t;!Pe(r)||$a`Property '__fixedExportMap__' of a precompiled module source must be an object, got ${xa(r)}, for module ${xa(e)}`;!Pe(o)||$a`Property '__liveExportMap__' of a precompiled module source must be an object, got ${xa(o)}, for module ${xa(e)}`}function Fa(t){return typeof t.execute==="function"}function ka(t,e){const{exports:r}=t;ft(r)||$a`Invalid module source: 'exports' of a virtual module source must be an array, got ${xa(r)}, for module ${xa(e)}`}function Ra(t,e){!Pe(t)||$a`Invalid module source: must be of type object, got ${xa(t)}, for module ${xa(e)}`;const{imports:r,exports:o,reexports:n=[]}=t;ft(r)||$a`Invalid module source: 'imports' must be an array, got ${xa(r)}, for module ${xa(e)}`;ft(o)||$a`Invalid module source: 'exports' must be an array, got ${xa(o)}, for module ${xa(e)}`;ft(n)||$a`Invalid module source: 'reexports' must be an array if present, got ${xa(n)}, for module ${xa(e)}`}const Ma=(t,e,r)=>{const{compartment:o,moduleSpecifier:n,resolvedImports:s,moduleSource:a}=r;const{instances:c}=pe(t,o);if(Ht(c,n)){return Gt(c,n)}Ra(a,n);const u=new i;let f;if(Oa(a)){Ca(a,n);f=Ta(t,e,r,u)}else if(Fa(a)){ka(a,n);f=Ia(t,a,o,e,n,s)}else{throw v(`Invalid module source, got ${xa(a)}`)}Bt(c,n,f);for(const[r,n]of N(s)){const s=Na(t,e,o,n);Bt(u,r,s)}return f};const La=new S;const Ua=new S;const Da=function t(e={},r={},o={}){throw v("Compartment.prototype.constructor is not a valid constructor.")};const ja=(t,e)=>{const{execute:r,exportsProxy:o}=Na(Ua,La,t,e);r();return o};const Ba={constructor:Da,get globalThis(){return pe(Ua,this).globalObject},get name(){return pe(Ua,this).name},evaluate(t,e={}){const r=pe(Ua,this);return _a(r,t,e)},module(t){if(typeof t!=="string"){throw v("first argument of module() must be a string")}const{exportsProxy:e}=wa(this,pe(Ua,this),La,t);return e},async import(t){const{noNamespaceBox:e,noAggregateLoadErrors:r}=pe(Ua,this);if(typeof t!=="string"){throw v("first argument of import() must be a string")}return Se(ha(Ua,La,this,t,{noAggregateErrors:r}),(()=>{const r=ja(this,t);if(e){return r}return{namespace:r}}))},async load(t){if(typeof t!=="string"){throw v("first argument of load() must be a string")}const{noAggregateLoadErrors:e}=pe(Ua,this);return ha(Ua,La,this,t,{noAggregateErrors:e})},importNow(t){if(typeof t!=="string"){throw v("first argument of importNow() must be a string")}const{noAggregateLoadErrors:e}=pe(Ua,this);Sa(Ua,La,this,t,{noAggregateErrors:e});return ja(this,t)}};x(Ba,{[z]:{value:"Compartment",writable:false,enumerable:false,configurable:true}});x(Da,{prototype:{value:Ba}});const Ga=(...t)=>{if(t.length===0){return{}}if(t.length===1&&typeof t[0]==="object"&&t[0]!==null&&"__options__"in t[0]){const{__options__:e,...r}=t[0];Uo(e===true,`Compartment constructor only supports true __options__ sigil, got ${e}`);return r}else{const[e={},r={},o={}]=t;Do(o.modules,undefined,`Compartment constructor must receive either a module map argument or modules option, not both`);Do(o.globals,undefined,`Compartment constructor must receive either globals argument or option, not both`);return{...o,globals:e,modules:r}}};const Ha=(t,e,r,{parentCompartment:o=undefined,enforceNew:n=false}={})=>{function s(...s){if(n&&new.target===undefined){throw v("Class constructor Compartment cannot be invoked without 'new'")}const{name:a="<unknown>",transforms:c=[],__shimTransforms__:u=[],globals:f={},modules:l={},resolveHook:p,importHook:d,importNowHook:y,moduleMapHook:g,importMetaHook:m,__noNamespaceBox__:b=false,noAggregateLoadErrors:h=false}=Ga(...s);const S=Ot([c,u],Ae);const E={__proto__:null,...f};const P={__proto__:null,...l};const w=new i;const A=new i;const _=new i;const I={};const $=this;Ln(I);Un(I);const{safeEvaluate:x}=Es({globalObject:I,globalTransforms:S,sloppyGlobalsMode:false});Dn(I,{intrinsics:e,newGlobalPropertyNames:Jo,makeCompartmentConstructor:t,parentCompartment:this,markVirtualizedNativeFunction:r});jn(I,x,r);T(I,E);const N=async t=>{if(typeof p!=="function"){throw v(`Compartment does not support dynamic import: no configured resolveHook for compartment ${mo(a)}`)}await ha(Ua,La,$,t,{noAggregateErrors:h});const{execute:e,exportsProxy:r}=Na(Ua,La,$,t);e();return r};ye(Ua,this,{name:`${a}`,globalTransforms:S,globalObject:I,safeEvaluate:x,resolveHook:p,importHook:d,importNowHook:y,moduleMap:P,moduleMapHook:g,importMetaHook:m,moduleRecords:w,__shimTransforms__:u,deferredExports:_,instances:A,parentCompartment:o,noNamespaceBox:b,compartmentImport:N,noAggregateLoadErrors:h})}s.prototype=Ba;return s};function Wa(t){return R(t).constructor}function za(){return arguments}const Ka=()=>{const e=ve.prototype.constructor;const o=C(za(),"callee");const n=o&&o.get;const a=fe(new m);const c=R(a);const u=yt[q]&&Zt(/./);const f=u&&R(u);const l=Lt([]);const p=R(l);const d=R(s);const y=Kt(new i);const b=R(y);const h=Jt(new g);const S=R(h);const E=R(p);function*P(){}const w=Wa(P);const A=w.prototype;async function _(){}const v=Wa(_);const I={"%InertFunction%":e,"%ArrayIteratorPrototype%":p,"%InertAsyncFunction%":v,"%Generator%":A,"%InertGeneratorFunction%":w,"%IteratorPrototype%":E,"%MapIteratorPrototype%":b,"%RegExpStringIteratorPrototype%":f,"%SetIteratorPrototype%":S,"%StringIteratorPrototype%":c,"%ThrowTypeError%":n,"%TypedArray%":d,"%InertCompartment%":Da};if(ke!==undefined){const t=Wa(ke);const e=t.prototype;const r=e.prototype;const o=R(r);T(I,{"%AsyncGenerator%":e,"%InertAsyncGeneratorFunction%":t,"%AsyncGeneratorPrototype%":r,"%AsyncIteratorPrototype%":o})}if(t.Iterator){I["%IteratorHelperPrototype%"]=R(t.Iterator.from([]).take(0));I["%WrapForValidIteratorPrototype%"]=R(t.Iterator.from({next(){return{value:undefined}}}))}if(t.AsyncIterator){I["%AsyncIteratorHelperPrototype%"]=R(t.AsyncIterator.from([]).take(0));I["%WrapForValidAsyncIteratorPrototype%"]=R(t.AsyncIterator.from({next(){}}))}const $=new r(0);const x=$.sliceToImmutable();const N=R(x);if(N!==r.prototype){I["%ImmutableArrayBufferPrototype%"]=N}return I};const qa=(t,e)=>{if(e==="safe"){return t}Object.isExtensible=()=>false;Object.isFrozen=()=>true;Object.isSealed=()=>true;Reflect.isExtensible=()=>false;if(t.isFake){return t}const r=t=>t;r.isFake=true;return O(r)};O(qa);const Va=()=>{const t=b;const e=t.prototype;const r=he(b,undefined);x(e,{constructor:{value:r}});const o=N(F(t));const n=G(Nt(o,(([t,e])=>[t,{...e,configurable:true}])));x(r,n);return{"%SharedSymbol%":r}};const Ya=t=>{try{t();return false}catch(t){return true}};const Ja=(t,e,r)=>{if(t===undefined){return false}const o=C(t,e);if(!o||"value"in o){return false}const{get:n,set:s}=o;if(typeof n!=="function"||typeof s!=="function"){return false}if(n()!==r){return false}if(et(n,t,[])!==r){return false}const a="Seems to be a setter";const i={__proto__:null};et(s,i,[a]);if(i[e]!==a){return false}const c={__proto__:t};et(s,c,[a]);if(c[e]!==a){return false}if(!Ya((()=>et(s,t,[r])))){return false}if("originalValue"in n){return false}if(o.configurable===false){return false}tt(t,e,{value:r,writable:true,enumerable:o.enumerable,configurable:true});return true};const Qa=t=>{Ja(t["%IteratorPrototype%"],"constructor",t.Iterator);Ja(t["%IteratorPrototype%"],z,"Iterator")};const Xa=()=>{const t=wt[K];tt(wt,K,{configurable:true,get(){return t},set(t){if(this===wt)return;if(H(this,K)){this[K]=t}tt(this,K,{value:t,writable:true,enumerable:true,configurable:true})}})};const Za=()=>{if(typeof pt.transfer==="function"){return{}}const e=t.structuredClone;if(typeof e!=="function"){return{}}const o={transfer(t=undefined){const o=Dt(this);if(t===undefined||t===o){return e(this,{transfer:[this]})}if(typeof t!=="number"){throw v(`transfer newLength if provided must be a number`)}if(t>o){const o=new r(t);const n=new h(this);const s=new h(o);jt(s,n);e(this,{transfer:[this]});return o}else{const r=Ut(this,0,t);e(this,{transfer:[this]});return r}}};tt(pt,"transfer",{value:o.transfer,writable:true,enumerable:false,configurable:true});return{}};const ti=t=>{let e=false;const r=(...r)=>{if(e){t(" ",...r)}else{t(...r)}};return{warn(...t){r(...t)},error(...t){r(...t)},groupCollapsed(...r){Uo(!e);t(...r);e=true},groupEnd(){e=false}}};const ei=()=>{};const ri=e=>{if(e==="none"){return ti(ei)}if(e==="console"||t.window===t||t.importScripts!==undefined){return console}if(t.console!==undefined){const e=t.console;const r=he(e.error,e);return ti(r)}if(t.print!==undefined){return ti(t.print)}return ti(ei)};const oi=(t,e,r)=>{const{warn:o,error:n,groupCollapsed:s,groupEnd:a}=e;const i=s&&a;let c=false;try{return r({warn(...e){if(i&&!c){s(t);c=true}o(...e)},error(...e){if(i&&!c){s(t);c=true}n(...e)}})}finally{if(i&&c){a();c=false}}};const{Fail:ni,details:si,quote:ai}=Uo;let ii;let ci;const ui=zo();const fi=()=>{let e;try{e=ve("return true")()}catch(t){e=false}let r;try{r=_e("true")}catch(t){r=false}let o;if(e&&r){o=ve("eval","SES_changed",`        eval("SES_changed = true");\n        return SES_changed;\n      `)(_e,false);if(!o){delete t.SES_changed}}return{functionAllowed:e,evalAllowed:r,directEvalAllowed:o}};const li=(e={})=>{const{errorTaming:r=Xe("LOCKDOWN_ERROR_TAMING","safe",["unsafe","unsafe-debug"]),errorTrapping:o=Xe("LOCKDOWN_ERROR_TRAPPING","platform",["none","report","abort","exit"]),reporting:n=Xe("LOCKDOWN_REPORTING","platform",["console","none"]),unhandledRejectionTrapping:s=Xe("LOCKDOWN_UNHANDLED_REJECTION_TRAPPING","report",["none"]),regExpTaming:a=Xe("LOCKDOWN_REGEXP_TAMING","safe",["unsafe"]),localeTaming:i=Xe("LOCKDOWN_LOCALE_TAMING","safe",["unsafe"]),consoleTaming:c=Xe("LOCKDOWN_CONSOLE_TAMING","safe",["unsafe"]),overrideTaming:u=Xe("LOCKDOWN_OVERRIDE_TAMING","moderate",["min","severe"]),stackFiltering:f=Xe("LOCKDOWN_STACK_FILTERING","concise",["omit-frames","shorten-paths","verbose"]),domainTaming:l=Xe("LOCKDOWN_DOMAIN_TAMING","safe",["unsafe"]),evalTaming:p=Xe("LOCKDOWN_EVAL_TAMING","safe-eval",["unsafe-eval","no-eval","safeEval","unsafeEval","noEval"]),overrideDebug:d=It(ce(Xe("LOCKDOWN_OVERRIDE_DEBUG",""),","),(t=>t!=="")),legacyRegeneratorRuntimeTaming:y=Xe("LOCKDOWN_LEGACY_REGENERATOR_RUNTIME_TAMING","safe",["unsafe-ignore"]),__hardenTaming__:g=Xe("LOCKDOWN_HARDEN_TAMING","safe",["unsafe"]),dateTaming:m,mathTaming:b,...h}=e;const S=it(h);S.length===0||ni`lockdown(): non supported option ${ai(S)}`;const E=ri(n);const{warn:P}=E;if(m!==undefined){P(`SES The 'dateTaming' option is deprecated and does nothing. In the future specifying it will be an error.`)}if(b!==undefined){P(`SES The 'mathTaming' option is deprecated and does nothing. In the future specifying it will be an error.`)}ii===undefined||Uo.fail(si`Already locked down at ${ii} (SES_ALREADY_LOCKED_DOWN)`,v);ii=v("Prior lockdown (SES_ALREADY_LOCKED_DOWN)");const{functionAllowed:w,evalAllowed:A,directEvalAllowed:_}=fi();if(_===false&&p==="safe-eval"&&(w||A)){throw v("SES cannot initialize unless 'eval' is the original intrinsic 'eval', suitable for direct eval (dynamically scoped eval) (SES_DIRECT_EVAL)")}const I=()=>t.Function.prototype.constructor!==t.Function&&typeof t.harden==="function"&&typeof t.lockdown==="function"&&t.Date.prototype.constructor!==t.Date&&typeof t.Date.now==="function"&&M(t.Date.prototype.constructor.now(),NaN);if(I()){throw v(`Already locked down but not by this SES instance (SES_MULTIPLE_INSTANCES)`)}_s(l);const T=As();const{addIntrinsics:$,completePrototypes:x,finalIntrinsics:N}=mn(E);const O=qa(ui,g);$({harden:O});$(Sn());$(En());$(na(r,f));$(Pn());$(wn(a));$(Va());$(Za());$(vs());$(Ka());x();const C=N();const F={__proto__:null};if(typeof t.Buffer==="function"){F.Buffer=t.Buffer}let L;if(r==="safe"){L=C["%InitialGetStackString%"]}const U=Ms(c,o,s,L);t.console=U.console;if(typeof U.console._times==="object"){F.SafeMap=R(U.console._times)}if((r==="unsafe"||r==="unsafe-debug")&&t.assert===Uo){t.assert=Lo(undefined,true)}Fn(C,i);Qa(C);oi("SES Removing unpermitted intrinsics",E,(t=>hn(C,T,t)));Un(t);Dn(t,{intrinsics:C,newGlobalPropertyNames:Yo,makeCompartmentConstructor:Ha,markVirtualizedNativeFunction:T});if(p==="no-eval"||p==="noEval"){jn(t,Ie,T)}else if(p==="safe-eval"||p==="safeEval"){const{safeEvaluate:e}=Es({globalObject:t});jn(t,e,T)}else;const D=()=>{ci===undefined||Uo.fail(si`Already locked down at ${ci} (SES_ALREADY_LOCKED_DOWN)`,v);ci=v("Prior lockdown (SES_ALREADY_LOCKED_DOWN)");oi("SES Enabling property overrides",E,(t=>In(C,u,t,d)));if(y==="unsafe-ignore"){Xa()}const e={intrinsics:C,hostIntrinsics:F,globals:{Function:t.Function,eval:t.eval,Compartment:t.Compartment,Symbol:t.Symbol}};for(const r of k(Yo)){e.globals[r]=t[r]}O(e);return O};return D};t.lockdown=e=>{const r=li(e);t.harden=r()};t.repairIntrinsics=e=>{const r=li(e);t.hardenIntrinsics=()=>{t.harden=r()}};const pi=As();const di=ri("none");t.Compartment=Ha(Ha,bn(t,di),pi,{enforceNew:true});t.assert=Uo;const yi=Cs(Mo);const gi=J("MAKE_CAUSAL_CONSOLE_FROM_LOGGER_KEY_FOR_SES_AVA");t[gi]=yi;function mi(t="",e=""){const r=crypto.randomUUID();const o=[];if(t)o.push(t);o.push(r);if(e)o.push(e);return o.join("_")}const bi={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;","/":"&#x2F;","`":"&#x60;","=":"&#x3D;"};const hi=/[&<>"'`=/]/g;function Si(t){if(!t)return"";return String(t).replace(hi,(t=>bi[t]))}function Ei(t,e,r){if(t.length===0)return;const o=(e%t.length+t.length)%t.length;const n=(r%t.length+t.length)%t.length;if(o!==n){const[e]=t.splice(o,1);t.splice(n,0,e)}}function Pi(t,e){if(t==e)return true;return Array.isArray(t)&&Array.isArray(e)&&t.length===e.length&&t.every(((t,r)=>t===e[r]))}function wi(t,e){if(t==null)return t;if(typeof e==="number"){return Array.isArray(t)?t[e]:undefined}if(typeof e!=="string"){console.error("Field must be a string or a number.");return undefined}const r=e.trim();if(r==="")return undefined;if(r.includes("|")){const e=r.split("|");return Ai(t,e)}if(r.includes("&")){const e=r.split("&");return _i(t,e)}const o=r.indexOf(".");if(o!==-1){const e=r.substring(0,o);const n=r.substring(o+1);const s=wi(t,e);return wi(s,n)}if(Array.isArray(t)&&t.length>0&&typeof t[0]==="object"){return t.map((t=>wi(t,r)))}return t[r]}function Ai(t,e){for(const r of e){const e=wi(t,r);if(e!=null)return e}return null}function _i(t,e){return e.reduce(((e,r)=>{const o=wi(t,r);if(o!=null){e.push(...Array.isArray(o)?o:[o])}return e}),[])}function vi(t,e,r){if(t==null){return}if(typeof e==="number"){t[e]=r;return}if(typeof e!=="string"){console.error("Field must be a string or a number.");return}const o=e.split(/[|&]/);if(o.length>1){for(const e of o){if(wi(t,e)!==undefined){vi(t,e,r);return}}vi(t,o[0],r);return}e=e.trim();const n=e.indexOf(".");if(n===-1){if(Array.isArray(t)&&t.length>0&&typeof t[0]==="object"){t.forEach((t=>{if(t){t[e]=r}}))}else{t[e]=r}return}const s=e.substring(0,n);const a=e.substring(n+1);const i=t[s];if(i){vi(i,a,r)}}function Ii(t,e,...r){if(e==null)return e;if(typeof e==="string"){if($i(e)){e=Ti(e)}else{const r=e.split(".");let o=t||(typeof window!=="undefined"?window:globalThis);for(const t of r){o=o?.[t];if(o===undefined)break}if(typeof o==="function"){e=o}}}if(typeof e==="function"){return Mi(t,e,...r)}return e}function Ti(t){if(typeof t!=="string"||t.trim()===""){throw new Error("Function string cannot be empty")}const e=/^export default\s+(async\s+)?function\s*\(([^)]*)\)\s*{([\s\S]*)}$/;const r=e.exec(t);if(!r){throw new Error("Invalid function string")}const o=!!r[1];const n=r[2].split(",").map((t=>t.trim())).filter(Boolean);const s=r[3].trim();const a=new Compartment;const i=o?Object.getPrototypeOf((async function(){})).constructor:Function;const c=new a.globalThis[i.name](...n,s);return c}function $i(t){if(typeof t!=="string"){return false}const e=t.trim();const r=/^export\s+default\s+function\s*[a-zA-Z0-9_$]*\s*\([^)]*\)\s*{[\s\S]*}$/;return r.test(e)}function xi(t,e){const r=t.filter((t=>t.conjunction!=="or"));const o=t.filter((t=>t.conjunction==="or"));if(r.some((t=>!Ni(t,e)))){return false}if(o.length>0&&!o.some((t=>Ni(t,e)))){return false}return true}function Ni(t,e){try{const r=Ii(null,t.field,e);const o=Ii(null,t.operator,e);const n=Ii(null,t.value,e);const s=ki(e,r);if(s===null||s===undefined){if(o==="=")return n===null||n===undefined;if(o==="!=")return n!==null&&n!==undefined;if(o==="empty")return true;if(o==="notempty")return false;return false}switch(o){case">":{const t=+s;const e=+n;return!isNaN(t)&&!isNaN(e)&&t>e}case"<":{const t=+s;const e=+n;return!isNaN(t)&&!isNaN(e)&&t<e}case">=":{const t=+s;const e=+n;return!isNaN(t)&&!isNaN(e)&&t>=e}case"<=":{const t=+s;const e=+n;return!isNaN(t)&&!isNaN(e)&&t<=e}case"=":return s===n||typeof s==="number"&&typeof n==="string"&&s===+n&&!isNaN(+n)||typeof s==="string"&&typeof n==="number"&&+s===n&&!isNaN(+s);case"!=":return s!==n&&!(typeof s==="number"&&typeof n==="string"&&s===+n&&!isNaN(+n))&&!(typeof s==="string"&&typeof n==="number"&&+s===n&&!isNaN(+s));case"like":{const t=String(s).toLowerCase();const e=String(n).toLowerCase();return t.includes(e)}case"include":return Array.isArray(s)&&s.includes(n);case"notinclude":return Array.isArray(s)&&!s.includes(n);case"in":return Array.isArray(n)&&n.includes(s);case"notin":return Array.isArray(n)&&!n.includes(s);case"typeof":if(typeof n!=="string"){console.warn("typeof ");return false}return typeof s===n;case"instanceof":if(typeof n!=="function"){console.warn("instanceof ");return false}return s instanceof n;case"empty":return s===""||Array.isArray(s)&&s.length===0||typeof s==="object"&&s!==null&&Object.keys(s).length===0;case"notempty":return s!==""&&!(Array.isArray(s)&&s.length===0)&&!(typeof s==="object"&&s!==null&&Object.keys(s).length===0);case"match":try{const t=String(n);return new RegExp(t).test(String(s))}catch(t){console.error(":",n);return false}default:throw new Error(`: ${o}`)}}catch(t){console.error(":",t);return false}}function Oi(t,e){const r=/\{([^}]+)\}/g;return t.replace(r,((t,r)=>{const o=wi(e,r);return o!==undefined?String(o):""}))}function Ci(t){if(!t)return{};if(typeof t==="object")return t;const e=t.trim().split(/\s+/);const r={};for(let t=0;t<e.length;t++){r[e[t]]=true}return r}function Fi(t,e){return{...Ci(t),...Ci(e)}}function ki(t,e,r){if(!t||typeof t!=="object"){return null}if(!Object.hasOwn(t,e)){if(e.includes(".")){const o=e.split(".");const n=o.shift();if(Object.hasOwn(t,n)){const e=t[n];return ki(e,o.join("."),r)}}return null}let o=t[e];if(typeof o==="string"&&$i(o)){try{o=t[e]=Ti(o)}catch(t){console.error(` '${e}':`,t);return null}}try{return Mi(t,o,...r||[])}catch(t){console.error(` '${e}' :`,t);return null}}function Ri(t,e,r='<span class="bg-warning text-dark">$1</span>'){if(!e||!t){return t}try{const o=Si(e);const n=new RegExp(`(${o})`,"gi");const s=r.replace("$1","$&");return t.replace(n,s)}catch(e){console.error(":",e);return t}}function Mi(t,e,...r){if(typeof e!=="function"){return e}return e.apply(t,r)}function Li(t){if(t==null||!Array.isArray(t)){return false}return t.every((t=>typeof t==="object"&&t!==null&&"field"in t&&"operator"in t&&"value"in t))}function Ui(t){if(t==null||!Array.isArray(t)){return null}return t.every((t=>typeof t==="object"&&t!==null&&"conditions"in t&&Li(t.conditions)&&"value"in t))}function Di(t,e,r="single"){if(!Array.isArray(t)||t.length===0)return null;const o=t.filter((t=>t.selected===true&&t.id)).map((t=>String(t.id)));if(o.length===0){if(e||r==="none"){return null}const n=t.find((t=>t.id));if(n){o.push(String(n.id))}else{return null}}return r==="single"?o[0]:o}function ji(t,e){if(e<0){console.warn("Delay time must be greater than or equal to 0. Using default value of 300ms.");e=300}let r;const o=function(...o){if(r!==undefined){clearTimeout(r)}r=setTimeout((()=>{try{t.apply(this,o)}catch(t){console.error("Error executing debounced function:",t)}r=undefined}),e)};o.cancel=function(){if(r!==undefined){clearTimeout(r);r=undefined}};return o}function Bi(t){if(Array.isArray(t)){if(t.length===0){return false}return t.some((t=>Bi(t)))}return typeof t==="string"&&t.trim()!==""}export{Pi as a,wi as b,Ei as c,ji as d,Ti as e,Ri as f,mi as g,Ui as h,$i as i,Li as j,xi as k,Si as l,Fi as m,Oi as n,Ii as o,Ci as p,Bi as q,ki as r,vi as s,Di as t};
//# sourceMappingURL=p-C51KEHDy.js.map