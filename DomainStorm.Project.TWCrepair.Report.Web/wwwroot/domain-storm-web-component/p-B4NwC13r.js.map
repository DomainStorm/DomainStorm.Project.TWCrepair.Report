{"version":3,"file":"p-B4NwC13r.js","sources":["src/utils/utils.ts","src/utils/functional/functional.tsx"],"sourcesContent":["import clsx from 'clsx';\r\nimport equal from 'fast-deep-equal/es6';\r\nimport { encode as escapeHtml } from 'he';\r\nimport 'ses';\r\nimport type { ConditionGroupInterface, ConditionInterface, ListItemInterface } from './interface';\r\n\r\nexport { arrayMoveMutable as arrayMove } from 'array-move';\r\nexport { default as debounce } from 'lodash.debounce';\r\nexport { default as clone } from 'rfdc';\r\nexport { clsx, escapeHtml };\r\n\r\n/**\r\n * 格式化名稱，將名稱的不同部分組合成一個完整名稱字串。\r\n * 自動過濾空值，並以空格分隔各部分。\r\n *\r\n * @param first 名稱的第一部分（如果為空值，將會回傳空字串）\r\n * @param middle 名稱的中間部分（可選）\r\n * @param last 名稱的最後部分（可選）\r\n * @returns 組合後的名稱字串\r\n * @example\r\n * // 回傳 'John Doe'\r\n * formatName('John', undefined, 'Doe');\r\n *\r\n * // 回傳 'John Smith Doe'\r\n * formatName('John', 'Smith', 'Doe');\r\n */\r\nexport function format(first: string | null | undefined, middle?: string | null, last?: string | null): string {\r\n  const safeFirst = first || '';\r\n\r\n  if (!middle && !last) return safeFirst;\r\n\r\n  return [safeFirst, middle, last]\r\n    .filter(Boolean)\r\n    .join(' ');\r\n}\r\n\r\n/**\r\n * 產生唯一標識符（UID）\r\n *\r\n * 使用 crypto.randomUUID() 生成 UUID，並可選擇添加前綴和/或後綴。\r\n * 若前綴或後綴非空，則使用底線「_」連接。\r\n *\r\n * @param prefix 產生的 UID 前綴字串，預設為空字串\r\n * @param suffix 產生的 UID 後綴字串，預設為空字串\r\n * @returns 組合後的唯一標識符\r\n * @throws 若環境不支援 crypto.randomUUID() 時拋出錯誤\r\n *\r\n * @example\r\n * // 回傳: 'user_550e8400-e29b-41d4-a716-446655440000'\r\n * generateUid('user');\r\n *\r\n * @example\r\n * // 回傳: '550e8400-e29b-41d4-a716-446655440000_temp'\r\n * generateUid('', 'temp');\r\n */\r\nexport function generateUid(prefix = '', suffix = ''): string {\r\n  const uuid = crypto.randomUUID();\r\n\r\n  const parts: string[] = [];\r\n  if (prefix) parts.push(prefix);\r\n  parts.push(uuid);\r\n  if (suffix) parts.push(suffix);\r\n\r\n  return parts.join('_');\r\n}\r\n\r\n// 優化的欄位解析快取，限制大小以防止記憶體洩漏\r\nconst fieldParseCache = new Map<string, {\r\n  type: 'pipe' | 'ampersand' | 'dot' | 'simple';\r\n  parts?: string[];\r\n  firstField?: string;\r\n  subField?: string;\r\n  removeNull?: boolean;\r\n}>();\r\n\r\nconst MAX_CACHE_SIZE = 500;\r\n\r\n/**\r\n * 從物件中取得指定欄位的值。\r\n *\r\n * @param obj   目標物件\r\n * @param field 欄位名稱或索引\r\n * @returns     欄位的值\r\n */\r\nexport function getFieldValue(obj: unknown, field: string | number): unknown {\r\n  // null / undefined 直接回傳（保持呼叫端語意）\r\n  if (obj == null) return obj;\r\n\r\n  // 數字當作索引處理\r\n  if (typeof field === 'number') {\r\n    return Array.isArray(obj) ? obj[field] : undefined;\r\n  }\r\n\r\n  if (typeof field !== 'string') {\r\n    throw new Error('Field must be a string or a number');\r\n  }\r\n\r\n  const trimmedField = field.trim();\r\n  if (trimmedField === '') return undefined;\r\n\r\n  // 檢查快取\r\n  let parseInfo = fieldParseCache.get(trimmedField);\r\n  if (!parseInfo) {\r\n    parseInfo = parseFieldPath(trimmedField);\r\n\r\n    // 限制快取大小（簡單 FIFO）\r\n    if (fieldParseCache.size >= MAX_CACHE_SIZE) {\r\n      const firstKey = fieldParseCache.keys().next().value;\r\n      fieldParseCache.delete(firstKey);\r\n    }\r\n\r\n    fieldParseCache.set(trimmedField, parseInfo);\r\n  }\r\n\r\n  let value: unknown;\r\n\r\n  switch (parseInfo.type) {\r\n    case 'pipe': {\r\n      // 例如 a|b|c：從多個欄位中找第一個有值的\r\n      value = findFieldValue(obj, parseInfo.parts!);\r\n      break;\r\n    }\r\n\r\n    case 'ampersand': {\r\n      // 例如 a&b&c：合併多個欄位的值\r\n      value = mergeFieldValue(obj, parseInfo.parts!);\r\n      break;\r\n    }\r\n\r\n    case 'dot': {\r\n      // 例如 user.name：先取 user 再取 name\r\n      const firstField = parseInfo.firstField!;\r\n      const subField = parseInfo.subField!;\r\n      const firstValue = getFieldValue(obj, firstField);\r\n      value = getFieldValue(firstValue, subField);\r\n      break;\r\n    }\r\n\r\n    case 'simple': {\r\n      const firstField = parseInfo.firstField!;\r\n      // 陣列 + 物件元素：對每個 item 做一次同樣的欄位取值\r\n      if (Array.isArray(obj) && obj.length > 0 && typeof obj[0] === 'object' && obj[0] !== null) {\r\n        value = obj.map(item => getFieldValue(item, firstField));\r\n      }\r\n      // 單一物件：直接用 key 取值\r\n      else if (typeof obj === 'object' && obj !== null) {\r\n        value = (obj as Record<string, unknown>)[firstField];\r\n      }\r\n      // 其他型別（string/number/boolean...）：取不到欄位\r\n      else {\r\n        value = undefined;\r\n      }\r\n      break;\r\n    }\r\n\r\n    default: {\r\n      // 理論上不會進來，保險用\r\n      value = undefined;\r\n      break;\r\n    }\r\n  }\r\n\r\n  // 支援 field 結尾帶 \"!\"：移除結果陣列中的 null / undefined\r\n  if (parseInfo.removeNull && Array.isArray(value)) {\r\n    const res: unknown[] = [];\r\n    for (let i = 0; i < value.length; i++) {\r\n      const v = value[i];\r\n      if (v != null) res.push(v);\r\n    }\r\n    return res;\r\n  }\r\n\r\n  return value;\r\n}\r\n\r\n/**\r\n * 解析欄位路徑，返回解析資訊。\r\n *\r\n * 支援格式：\r\n *   - a|b|c        → pipe\r\n *   - a&b&c        → ampersand\r\n *   - user.name    → dot\r\n *   - field        → simple\r\n *   - field!       → removeNull\r\n *\r\n */\r\nexport function parseFieldPath(field: string): {\r\n  type: 'pipe' | 'ampersand' | 'dot' | 'simple';\r\n  parts?: string[];\r\n  firstField?: string;\r\n  subField?: string;\r\n  removeNull?: boolean;\r\n} {\r\n  // 安全：不可直接修改輸入參數，避免外部引用被意外變更\r\n  let raw = field;\r\n\r\n  // 找出第一個特殊符號位置\r\n  let pipeIndex = -1;\r\n  let ampersandIndex = -1;\r\n  let dotIndex = -1;\r\n\r\n  // 單次迴圈 O(n) 找到三種符號（效能最佳）\r\n  for (let i = 0; i < raw.length; i++) {\r\n    const c = raw[i];\r\n    if (c === '|' && pipeIndex === -1) pipeIndex = i;\r\n    else if (c === '&' && ampersandIndex === -1) ampersandIndex = i;\r\n    else if (c === '.' && dotIndex === -1) dotIndex = i;\r\n  }\r\n\r\n  // \"|\" pipe 模式\r\n  if (pipeIndex !== -1) {\r\n    return {\r\n      type: 'pipe',\r\n      parts: raw.split('|')\r\n    };\r\n  }\r\n\r\n  // \"&\" ampersand 模式\r\n  if (ampersandIndex !== -1) {\r\n    return {\r\n      type: 'ampersand',\r\n      parts: raw.split('&'),\r\n    };\r\n  }\r\n\r\n  // \".\" dot 模式（只解析第一次 dot，符合常見 nested path）\r\n  if (dotIndex !== -1) {\r\n    return {\r\n      type: 'dot',\r\n      firstField: raw.substring(0, dotIndex),\r\n      subField: raw.substring(dotIndex + 1),\r\n    };\r\n  }\r\n\r\n  // 單一欄位\r\n  return {\r\n    type: 'simple',\r\n    firstField: raw.endsWith('!') ? raw.slice(0, -1) : raw,\r\n    removeNull: raw.endsWith('!'),\r\n  };\r\n}\r\n\r\n/**\r\n * 設定物件中指定欄位的值。\r\n *\r\n * @param obj 要設定值的物件\r\n * @param field 欄位名稱或索引\r\n * @param value 要設定的值\r\n */\r\nexport function setFieldValue(obj: unknown, field: string | number, value: unknown): void {\r\n  if (obj == null) {\r\n    return;\r\n  }\r\n\r\n  if (typeof field === 'number') {\r\n    if (Array.isArray(obj)) {\r\n      obj[field] = value;\r\n    }\r\n    return;\r\n  }\r\n\r\n  if (typeof field !== 'string') {\r\n    throw new Error('Field must be a string or a number');\r\n  }\r\n\r\n  const trimmedField = field.trim();\r\n  if (trimmedField === '') return;\r\n\r\n  let parseInfo = fieldParseCache.get(trimmedField);\r\n  if (!parseInfo) {\r\n    parseInfo = parseFieldPath(trimmedField);\r\n\r\n    if (fieldParseCache.size >= MAX_CACHE_SIZE) {\r\n      const firstKey = fieldParseCache.keys().next().value;\r\n      fieldParseCache.delete(firstKey);\r\n    }\r\n\r\n    fieldParseCache.set(trimmedField, parseInfo);\r\n  }\r\n\r\n  if (parseInfo.type === 'pipe' || parseInfo.type === 'ampersand') {\r\n    const parts = parseInfo.parts!;\r\n    for (let i = 0; i < parts.length; i++) {\r\n      const trimmedPart = parts[i].trim();\r\n      if (trimmedPart && getFieldValue(obj, trimmedPart) !== undefined) {\r\n        setFieldValue(obj, trimmedPart, value);\r\n        return;\r\n      }\r\n    }\r\n    const firstPart = parts[0]?.trim();\r\n    if (firstPart) {\r\n      setFieldValue(obj, firstPart, value);\r\n    }\r\n    return;\r\n  }\r\n\r\n  if (parseInfo.type === 'dot') {\r\n    if (typeof obj === 'object') {\r\n      const subObj = (obj as Record<string, unknown>)[parseInfo.firstField!];\r\n      if (subObj !== undefined) {\r\n        setFieldValue(subObj, parseInfo.subField!, value);\r\n      }\r\n    }\r\n    return;\r\n  }\r\n\r\n  if (Array.isArray(obj) && obj.length > 0 && typeof obj[0] === 'object') {\r\n    for (let i = 0; i < obj.length; i++) {\r\n      const subObj = obj[i];\r\n      if (subObj && typeof subObj === 'object') {\r\n        (subObj as Record<string, unknown>)[trimmedField] = value;\r\n      }\r\n    }\r\n  } else if (typeof obj === 'object') {\r\n    (obj as Record<string, unknown>)[trimmedField] = value;\r\n  }\r\n}\r\n\r\n/**\r\n * 從給定的物件中尋找特定欄位的值。\r\n * 遍歷所有欄位路徑，回傳第一個非空值。\r\n *\r\n * @param obj 要搜尋的物件\r\n * @param parts 欄位的路徑，以字串陣列表示\r\n * @returns 找到的欄位值，如果找不到則回傳 null\r\n */\r\nfunction findFieldValue(obj: unknown, parts: readonly string[]): unknown {\r\n  for (const part of parts) {\r\n    const trimmedPart = part.trim();\r\n    if (trimmedPart) {\r\n      const value = getFieldValue(obj, trimmedPart);\r\n      if (value != null) return value;\r\n    }\r\n  }\r\n  return null;\r\n}\r\n\r\n/**\r\n * 合併物件中多個欄位的值。\r\n * 將所有欄位的值合併成一個陣列，支援巢狀陣列展開。\r\n *\r\n * @param obj 要合併值的物件\r\n * @param parts 欄位名稱的陣列\r\n * @returns 合併後的值的陣列\r\n */\r\nfunction mergeFieldValue(obj: unknown, parts: readonly string[]): unknown[] {\r\n  const result: unknown[] = [];\r\n\r\n  for (const part of parts) {\r\n    const trimmedPart = part.trim();\r\n    if (trimmedPart) {\r\n      const value = getFieldValue(obj, trimmedPart);\r\n      if (value != null) {\r\n        if (Array.isArray(value)) {\r\n          result.push(...value);\r\n        } else {\r\n          result.push(value);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\n/**\r\n * 從物件中計算值，支援字串路徑、函式呼叫，以及提供預設值。\r\n *\r\n * @param obj 要查找的物件\r\n * @param value 要計算的值，可以是字串路徑、函式或直接的值\r\n * @param args 傳遞給函式的參數陣列\r\n * @returns 計算後的值\r\n */\r\nexport function calculateObjectValue(obj: unknown, value: unknown, ...args: unknown[]): unknown {\r\n  if (value == null) return value;\r\n\r\n  if (typeof value === 'string') {\r\n    if (isModuleFunctionString(value)) {\r\n      value = createFunctionFromString(value);\r\n    }\r\n    else {\r\n      const names = value.split('.');\r\n      let func: any = obj || (typeof window !== 'undefined' ? window : globalThis);\r\n\r\n      for (const name of names) {\r\n        func = func?.[name];\r\n        if (func === undefined) break;\r\n      }\r\n\r\n      if (typeof func === 'function') {\r\n        value = func;\r\n      }\r\n    }\r\n  }\r\n  if (typeof value === 'function') {\r\n    return executeFunction(obj, value, ...args);\r\n  }\r\n  return value;\r\n}\r\n\r\n/**\r\n * 從字串中解析並取得預設導出的函數。\r\n *\r\n * @param code 包含函數定義的字串，格式必須為 `export default function([params]) { [body] }`\r\n * @returns 解析後的函數\r\n * @throws {Error} 當函數字串格式不正確或解析失敗時拋出錯誤\r\n *\r\n * // 解析簡單函數\r\n * const add = createFunctionFromString('export default function(a, b) { return a + b; }');\r\n * console.log(add(1, 2)); // 輸出 3\r\n */\r\nexport function createFunctionFromString(code: string): (...args: any[]) => any {\r\n  if (typeof code !== 'string' || code.trim() === '') {\r\n    throw new Error('Function string cannot be empty');\r\n  }\r\n\r\n  const regex = /^export default\\s+(async\\s+)?function\\s*\\(([^)]*)\\)\\s*{([\\s\\S]*)}$/;\r\n  const matches = regex.exec(code);\r\n\r\n  if (!matches) {\r\n    throw new Error('Invalid function string');\r\n  }\r\n\r\n  const isAsync = !!matches[1];\r\n  const parameters = matches[2].split(',').map(param => param.trim()).filter(Boolean);\r\n  const functionBody = matches[3].trim();\r\n\r\n  const compartment = new Compartment();\r\n\r\n  const FuncConstructor = isAsync\r\n    ? Object.getPrototypeOf(async function () { }).constructor\r\n    : Function;\r\n\r\n  const func = new compartment.globalThis[FuncConstructor.name](...parameters, functionBody);\r\n\r\n  return func as (...args: any[]) => any;\r\n}\r\n\r\n/**\r\n * 檢查字串是否符合預期的模組函式格式\r\n *\r\n * 有效的模組函式字串格式為：\r\n * `export default function [name]([params]) { [body] }`\r\n *\r\n * @param code 要檢查的程式碼字串\r\n * @returns {boolean} 是否符合模組函式格式\r\n *\r\n * @example\r\n * // 回傳 true\r\n * isModuleFunctionString('export default function() { return 42; }');\r\n *\r\n * @example\r\n * // 回傳 true\r\n * isModuleFunctionString('export default function getData(id, type) { return fetch(`/api/${id}`); }');\r\n *\r\n * @example\r\n * // 回傳 false\r\n * isModuleFunctionString('function test() {}');\r\n */\r\nexport function isModuleFunctionString(code: string): boolean {\r\n  if (typeof code !== 'string') {\r\n    return false;\r\n  }\r\n  const trimmedCode = code.trim();\r\n  const regex = /^export\\s+default\\s+function\\s*[a-zA-Z0-9_$]*\\s*\\([^)]*\\)\\s*{[\\s\\S]*}$/;\r\n  return regex.test(trimmedCode);\r\n}\r\n\r\n/**\r\n * 依據提供的條件計算其真假值。\r\n *\r\n * @param value 要計算的條件，可以是一個 bool 值、一個函式、或者一個條件陣列\r\n * @param data 提供的數據對象\r\n * @returns 如果條件成立則回傳 true，否則回傳 false\r\n */\r\nexport function evaluateConditions(value: ConditionInterface[], data: Record<string, any>): boolean {\r\n  const andConditions = value.filter(condition => condition.conjunction !== 'or');\r\n  const orConditions = value.filter(condition => condition.conjunction === 'or');\r\n\r\n  if (andConditions.some(condition => !checkCondition(condition, data))) {\r\n    return false;\r\n  }\r\n\r\n  if (orConditions.length > 0 && !orConditions.some(condition => checkCondition(condition, data))) {\r\n    return false;\r\n  }\r\n\r\n  return true;\r\n}\r\n\r\n/**\r\n * 定義支援的條件比較運算符\r\n */\r\ntype ConditionOperator =\r\n  // 數值比較運算符\r\n  | '>' | '<' | '>=' | '<='\r\n  // 相等比較運算符\r\n  | '=' | '!='\r\n  // 字串操作運算符\r\n  | 'like'\r\n  // 陣列內容運算符\r\n  | 'include' | 'notinclude'\r\n  // 集合成員檢查運算符\r\n  | 'in' | 'notin'\r\n  // 型別檢查運算符\r\n  | 'typeof' | 'instanceof'\r\n  // 空值檢查運算符\r\n  | 'empty' | 'notempty'\r\n  | 'match';\r\n\r\n/**\r\n * 檢查條件是否符合資料物件\r\n *\r\n * 支援多種運算符比較資料屬性值與條件值:\r\n * - 數值比較: >, <, >=, <= (將兩側值轉換為數值進行比較)\r\n * - 相等比較: =, != (支援跨型別比較)\r\n * - 字串操作: like (不區分大小寫的子字串搜尋)\r\n * - 陣列操作: include, notinclude (檢查陣列中是否包含/不包含值)\r\n * - 集合檢查: in, notin (檢查值是否在/不在集合中)\r\n * - 型別檢查: typeof, instanceof (檢查值的型別或類別)\r\n * - 空值檢查: empty, notempty (檢查值是否為空/非空)\r\n * - 正則表達式: match (使用正則表達式匹配字串)\r\n *\r\n * @param condition 欲檢查的條件，包含欄位、運算符與要比較的值\r\n * @param data 要檢查的資料物件\r\n * @returns 若條件符合則回傳 true，否則回傳 false\r\n * @throws {Error} 當使用不支援的運算符時拋出錯誤\r\n */\r\nfunction checkCondition(condition: ConditionInterface, data: Record<string, any>): boolean {\r\n  try {\r\n    const field = calculateObjectValue(null, condition.field, data) as string;\r\n    const operator = calculateObjectValue(null, condition.operator, data) as ConditionOperator;\r\n    const value = calculateObjectValue(null, condition.value, data);\r\n    const fieldValue = resolvePropertyValue(data, field);\r\n\r\n    if (fieldValue === null || fieldValue === undefined) {\r\n      if (operator === '=') return value === null || value === undefined;\r\n      if (operator === '!=') return value !== null && value !== undefined;\r\n      if (operator === 'empty') return true;\r\n      if (operator === 'notempty') return false;\r\n      return false;\r\n    }\r\n\r\n    switch (operator) {\r\n      case '>': {\r\n        const numField = +fieldValue;\r\n        const numValue = +value;\r\n        return !isNaN(numField) && !isNaN(numValue) && numField > numValue;\r\n      }\r\n      case '<': {\r\n        const numField = +fieldValue;\r\n        const numValue = +value;\r\n        return !isNaN(numField) && !isNaN(numValue) && numField < numValue;\r\n      }\r\n      case '>=': {\r\n        const numField = +fieldValue;\r\n        const numValue = +value;\r\n        return !isNaN(numField) && !isNaN(numValue) && numField >= numValue;\r\n      }\r\n      case '<=': {\r\n        const numField = +fieldValue;\r\n        const numValue = +value;\r\n        return !isNaN(numField) && !isNaN(numValue) && numField <= numValue;\r\n      }\r\n      case '=':\r\n        return fieldValue === value ||\r\n          (typeof fieldValue === 'number' && typeof value === 'string' && fieldValue === +value && !isNaN(+value)) ||\r\n          (typeof fieldValue === 'string' && typeof value === 'number' && +fieldValue === value && !isNaN(+fieldValue));\r\n      case '!=':\r\n        return fieldValue !== value &&\r\n          !(typeof fieldValue === 'number' && typeof value === 'string' && fieldValue === +value && !isNaN(+value)) &&\r\n          !(typeof fieldValue === 'string' && typeof value === 'number' && +fieldValue === value && !isNaN(+fieldValue));\r\n      case 'like': {\r\n        const strField = String(fieldValue).toLowerCase();\r\n        const strValue = String(value).toLowerCase();\r\n        return strField.includes(strValue);\r\n      }\r\n      case 'include':\r\n        return Array.isArray(fieldValue) && fieldValue.includes(value);\r\n      case 'notinclude':\r\n        return Array.isArray(fieldValue) && !fieldValue.includes(value);\r\n      case 'in':\r\n        return Array.isArray(value) && value.includes(fieldValue);\r\n      case 'notin':\r\n        return Array.isArray(value) && !value.includes(fieldValue);\r\n      case 'typeof':\r\n        if (typeof value !== 'string') {\r\n          console.warn('typeof 運算符需要字串型別的比較值');\r\n          return false;\r\n        }\r\n        return typeof fieldValue === value;\r\n      case 'instanceof':\r\n        if (typeof value !== 'function') {\r\n          console.warn('instanceof 運算符需要函數型別的比較值');\r\n          return false;\r\n        }\r\n        return fieldValue instanceof value;\r\n      case 'empty':\r\n        return fieldValue === '' ||\r\n          (Array.isArray(fieldValue) && fieldValue.length === 0) ||\r\n          (typeof fieldValue === 'object' && fieldValue !== null &&\r\n            Object.keys(fieldValue).length === 0);\r\n      case 'notempty':\r\n        return fieldValue !== '' &&\r\n          !(Array.isArray(fieldValue) && fieldValue.length === 0) &&\r\n          !(typeof fieldValue === 'object' && fieldValue !== null &&\r\n            Object.keys(fieldValue).length === 0);\r\n      case 'match':\r\n        try {\r\n          const pattern = String(value);\r\n          return new RegExp(pattern).test(String(fieldValue));\r\n        } catch (error) {\r\n          console.error('無效的正則表達式:', value);\r\n          return false;\r\n        }\r\n      default:\r\n        throw new Error(`不支援的運算符: ${operator}`);\r\n    }\r\n  } catch (error) {\r\n    console.error('條件檢查失敗:', error);\r\n    return false;\r\n  }\r\n}\r\n\r\n/**\r\n * 替換字串中的佔位符為對應的值。\r\n *\r\n * @param str 要處理的字串\r\n * @param data 提供的資料\r\n * @returns 替換後的字串\r\n */\r\nexport function replacePlaceholders(str: string, data: Record<string, any>): string {\r\n  const placeholderRegex = /\\{([^}]+)\\}/g;\r\n\r\n  return str.replace(placeholderRegex, (_, field) => {\r\n    const value = getFieldValue(data, field);\r\n    return value !== undefined ? String(value) : '';\r\n  });\r\n}\r\n\r\n/**\r\n * 依據輸入值取得對應的類別物件。\r\n *\r\n * 內部使用 'clsx' 套件進行類別名稱處理，提供更好的效能。\r\n *\r\n * @param value 輸入值，可以是包含類別名稱的物件或者空格分隔的類別字串\r\n * @returns 對應的類別物件\r\n */\r\nexport function parseClassNames(value: string | Record<string, boolean> | null | undefined): Record<string, boolean> {\r\n  if (!value) return {};\r\n\r\n  if (typeof value === 'object') return value;\r\n\r\n  const trimmed = value.trim();\r\n  if (!trimmed) return {};\r\n\r\n  // 使用 clsx 處理並轉換為物件格式\r\n  return trimmed.split(/\\s+/).reduce((result, className) => {\r\n    if (className) result[className] = true;\r\n    return result;\r\n  }, {} as Record<string, boolean>);\r\n}\r\n\r\n/**\r\n * 合併兩個類別物件或類別字串\r\n *\r\n * 內部使用 'clsx' 套件進行類別合併，提供更好的效能和更多功能。\r\n *\r\n * @param value1 第一個類別物件或類別字串\r\n * @param value2 第二個類別物件或類別字串\r\n * @returns 合併後的類別物件\r\n */\r\nexport function mergeClasses(\r\n  value1: Record<string, boolean> | string | null | undefined,\r\n  value2: Record<string, boolean> | string | null | undefined\r\n): Record<string, boolean> {\r\n  // 使用 clsx 合併類別\r\n  const merged = clsx(value1, value2);\r\n  if (!merged) return {};\r\n\r\n  // 轉換為物件格式以保持向後兼容性\r\n  return merged.split(/\\s+/).reduce((result, className) => {\r\n    if (className) result[className] = true;\r\n    return result;\r\n  }, {} as Record<string, boolean>);\r\n}\r\n\r\n/**\r\n * 從物件中取得指定屬性的值，並依據屬性類型進行處理\r\n *\r\n * 此函式支援以下功能:\r\n * 1. 如果屬性不存在，回傳 null\r\n * 2. 如果屬性值是符合模組函式格式的字串，會將其轉換為函式並快取\r\n * 3. 如果屬性值是函式，會以指定物件為上下文執行並回傳結果\r\n *\r\n * @template T - 回傳值的預期型別\r\n * @param targetObject - 要取得屬性的目標物件\r\n * @param propertyName - 要取得的屬性名稱\r\n * @param functionArgs - 如果屬性是函式，傳遞給該函式的參數\r\n * @returns 處理後的屬性值，如果無法取得則回傳 null\r\n *\r\n * @example\r\n * // 取得簡單屬性\r\n * const name = resolvePropertyValue(user, 'name');\r\n *\r\n * @example\r\n * // 取得並執行函式屬性\r\n * const fullName = resolvePropertyValue(user, 'getFullName', ['withTitle']);\r\n */\r\nexport function resolvePropertyValue(\r\n  targetObject: Record<string, any> | null | undefined,\r\n  propertyName: string,\r\n  functionArgs?: any[]\r\n): any {\r\n  if (!targetObject || typeof targetObject !== 'object') {\r\n    return null;\r\n  }\r\n  let propertyValue = getFieldValue(targetObject, propertyName);\r\n  if (typeof propertyValue === 'string' && isModuleFunctionString(propertyValue)) {\r\n    try {\r\n      propertyValue = createFunctionFromString(propertyValue);\r\n      setFieldValue(targetObject, propertyName, propertyValue);\r\n    } catch (error) {\r\n      console.error(`無法解析函式字串 '${propertyName}':`, error);\r\n      return null;\r\n    }\r\n  }\r\n\r\n  try {\r\n    return executeFunction(targetObject, propertyValue, ...(functionArgs || []));\r\n  } catch (error) {\r\n    console.error(`執行屬性 '${propertyName}' 時發生錯誤:`, error);\r\n    return null;\r\n  }\r\n}\r\n\r\n/**\r\n * 在文字中標記搜尋關鍵字，使其以指定樣式高亮顯示\r\n *\r\n * 此函式將搜尋文字中符合關鍵字的部分，並用 HTML 標記包裹以實現視覺高亮效果。\r\n * 搜尋過程不區分大小寫（case-insensitive）。\r\n *\r\n * @param text 要處理的原始文字\r\n * @param searchTerm 要高亮顯示的搜尋關鍵字\r\n * @param highlightTemplate 用於高亮顯示的 HTML 模板，使用 $1 作為關鍵字位置的佔位符\r\n * @returns 處理後的文字，包含高亮標記；若輸入或搜尋詞為空則回傳原文\r\n *\r\n * @example\r\n * // 回傳: \"找到了重要<span class=\"bg-warning text-dark\">關鍵字</span>！\"\r\n * highlightSearchTerms(\"找到了重要關鍵字！\", \"關鍵字\");\r\n *\r\n * @example\r\n * // 使用自訂樣式\r\n * highlightSearchTerms(\"Hello World\", \"world\", '<mark>$1</mark>');\r\n * // 回傳: \"Hello <mark>World</mark>\"\r\n */\r\nexport function appendHighlight(\r\n  text: string,\r\n  searchTerm: string,\r\n  highlightTemplate = '<span class=\"bg-warning text-dark\">$1</span>'\r\n): string {\r\n  if (!searchTerm || !text) {\r\n    return text;\r\n  }\r\n\r\n  try {\r\n    const escapedSearchTerm = escapeHtml(searchTerm);\r\n    const searchRegex = new RegExp(`(${escapedSearchTerm})`, 'gi');\r\n    const processedTemplate = highlightTemplate.replace('$1', '$&');\r\n    return text.replace(searchRegex, processedTemplate);\r\n  } catch (error) {\r\n    console.error('搜尋高亮處理錯誤:', error);\r\n    return text;\r\n  }\r\n}\r\n\r\n/**\r\n * 安全地執行函數\r\n *\r\n * 此函式會嘗試以指定的上下文執行目標函數，並處理可能的錯誤。\r\n * 如果輸入不是函數，則直接回傳原始值，且不會執行任何操作。\r\n *\r\n * @template TFunc 函數類型\r\n * @template TResult 回傳值類型\r\n * @param context 函數執行的上下文對象（this 指向）\r\n * @param fn 要執行的函數（若不是函數則原樣回傳）\r\n * @param args 傳遞給函數的參數列表\r\n * @returns 函數執行結果、Promise<結果>（如果是非同步函數）或原始值\r\n *\r\n * @example\r\n * // 回傳函數執行結果\r\n * const result = executeFunction(user, user.getName, 'full');\r\n *\r\n * @example\r\n * // 若 fn 不是函數，直接回傳原始值\r\n * const result = executeFunction(user, 'notAFunction');\r\n */\r\nexport function executeFunction<T = any>(\r\n  context: any,\r\n  fn: ((...args: any[]) => T) | any,\r\n  ...args: any[]\r\n): T | Promise<T> {\r\n  if (typeof fn !== 'function') {\r\n    return fn;\r\n  }\r\n\r\n  return fn.apply(context, args);\r\n}\r\n\r\n/**\r\n * 檢查是否為有效的條件陣列\r\n *\r\n * 有效的條件陣列必須滿足以下條件：\r\n * 1. 不為 null 或 undefined\r\n * 2. 為陣列型別\r\n * 3. 陣列中的每個元素都必須包含 field、operator、value 屬性\r\n *\r\n * @param conditions 要檢查的潛在條件陣列\r\n * @returns 如果是有效的條件陣列則回傳 true，否則回傳 false\r\n *\r\n * @example\r\n * // 回傳 true\r\n * isConditions([\r\n *   { field: 'age', operator: '>', value: 18 },\r\n *   { field: 'status', operator: '=', value: 'active', conjunction: 'and' }\r\n * ]);\r\n *\r\n * @example\r\n * // 回傳 false - 缺少必要屬性\r\n * isConditions([{ field: 'name', operator: '=' }]);\r\n */\r\nexport function isConditions(value: unknown): value is ConditionInterface[] {\r\n  if (value == null || !Array.isArray(value)) {\r\n    return false;\r\n  }\r\n\r\n  return value.every(\r\n    (item): item is ConditionInterface =>\r\n      typeof item === 'object' &&\r\n      item !== null &&\r\n      'field' in item &&\r\n      'operator' in item &&\r\n      'value' in item\r\n  );\r\n}\r\n\r\n/**\r\n * 檢查是否為有效的條件群組陣列\r\n *\r\n * 有效的條件群組陣列必須滿足以下條件：\r\n * 1. 不為 null 或 undefined\r\n * 2. 為陣列型別\r\n * 3. 陣列中的每個元素都必須包含 conditions 屬性（陣列型別）和 value 屬性\r\n * 4. conditions 屬性必須是有效的條件陣列\r\n *\r\n * @param value 要檢查的潛在條件群組陣列\r\n * @returns 如果是有效的條件群組陣列則回傳 true，否則回傳 false\r\n *\r\n * @example\r\n * // 回傳 true\r\n * isConditionGroups([\r\n *  { conditions: [{ field: 'age', operator: '>', value: 18 }], value: 'adult' },\r\n * { conditions: [{ field: 'status', operator: '=', value: 'active' }], value: 'active' }\r\n * ]);\r\n * * @example\r\n * // 回傳 false - 缺少必要屬性\r\n * isConditionGroups([{ conditions: [{ field: 'name', operator: '=' }], value\r\n * : 'John' }]);\r\n */\r\nexport function isConditionGroups(value: unknown): value is ConditionGroupInterface[] {\r\n  if (value == null || !Array.isArray(value)) {\r\n    return false;\r\n  }\r\n\r\n  return value.every(\r\n    (item): item is ConditionGroupInterface =>\r\n      typeof item === 'object' &&\r\n      item !== null &&\r\n      'conditions' in item &&\r\n      isConditions(item.conditions) &&\r\n      'value' in item\r\n  );\r\n}\r\n\r\n/**\r\n * 取得選中的項目 ID 清單\r\n *\r\n * 依據選擇模式回傳不同格式的選中項目 ID：\r\n * - 'single': 回傳單一選中項目 ID (字串)\r\n * - 'multiple': 回傳所有選中項目 ID 陣列\r\n * - 'none': 不允許選擇，回傳 null\r\n *\r\n * 若無選中項目：\r\n * - 若 nullable 為 true，則回傳 null\r\n * - 若 nullable 為 false，則選擇第一個項目作為預設值\r\n *\r\n * @param items 項目清單，包含所有可選擇的項目\r\n * @param nullable 是否允許空值。true 表示允許回傳 null；false 表示至少選中一個項目\r\n * @param selection 選擇模式，預設為 'single'（單選）\r\n * @returns 選中的項目 ID 或 ID 列表，或 null（當無選中項目且 nullable 為 true 時）\r\n *\r\n * @example\r\n * // 回傳單一選中 ID\r\n * getSelectedItemIds(items, false, 'single');\r\n *\r\n * @example\r\n * // 回傳選中 ID 的陣列\r\n * getSelectedItemIds(items, true, 'multiple');\r\n */\r\nexport function getSelectedItemIds(\r\n  items: ListItemInterface[],\r\n  nullable: boolean,\r\n  selection: 'single' | 'multiple' | 'none' = 'single'\r\n): string | string[] | null {\r\n  if (!Array.isArray(items) || items.length === 0) return null;\r\n\r\n  const selectedIds = items\r\n    .filter(item => item.selected === true && item.id)\r\n    .map(item => String(item.id));\r\n\r\n  if (selectedIds.length === 0) {\r\n    if (nullable || selection === 'none') {\r\n      return null;\r\n    }\r\n\r\n    const firstItem = items.find(item => item.id);\r\n    if (firstItem) {\r\n      selectedIds.push(String(firstItem.id));\r\n    } else {\r\n      return null;\r\n    }\r\n  }\r\n\r\n  return selection === 'single'\r\n    ? selectedIds[0]\r\n    : selectedIds;\r\n}\r\n\r\n/**\r\n * 檢查一個字串或字串陣列是否包含任何非空值\r\n *\r\n * 對於單個字串，會檢查去除空格後是否有內容\r\n * 對於字串陣列，會檢查是否至少有一個字串去除空格後有內容\r\n *\r\n * @param value 要檢查的字串或字串陣列\r\n * @returns 如果至少有一個非空值，則返回 true，否則返回 false\r\n */\r\nexport function isNonEmptyValue(value: string | string[]): boolean {\r\n  if (Array.isArray(value)) {\r\n    if (value.length === 0) {\r\n      return false;\r\n    }\r\n\r\n    return value.some(str => isNonEmptyValue(str));\r\n  }\r\n\r\n  return typeof value === 'string' && value.trim() !== '';\r\n}\r\n\r\nexport function deepEqual(a: any, b: any): boolean {\r\n  return a == b || equal(a, b);\r\n}\r\n","import { FunctionalComponent, h } from '@stencil/core';\r\nimport { debounce, parseClassNames } from '../utils';\r\nimport type { FnHrProps, FnIconProps, FnIconSwitchProps, FnSearchInputProps, FnTagProps } from './interface';\r\n\r\n/**\r\n * 圖示\r\n * @param ref 元素的引用函式\r\n * @param class\r\n * @param children 圖示名稱\r\n * @returns JSX 元素\r\n */\r\nexport const FnIcon: FunctionalComponent<FnIconProps & { ref?: (el: HTMLElement | null) => void }> = ({ class: classes, onClick, ref }, children) => {\r\n  if (!children || !Array.isArray(children) || children.length !== 1 || typeof children[0] !== 'string' || !String(children[0]).trim()) return;\r\n\r\n  const iconClass = {\r\n    'material-icons': true,\r\n    'align-middle': true,\r\n    ...parseClassNames(classes),\r\n  };\r\n\r\n  return (\r\n    <i\r\n      class={iconClass}\r\n      ref={ref}\r\n      onClick={ev => {\r\n        if (!onClick) return;\r\n        ev.stopPropagation();\r\n        onClick(ev);\r\n      }}\r\n    >\r\n      {children}\r\n    </i>\r\n  );\r\n};\r\n\r\n/**\r\n * 切換圖示元件\r\n * @param class 類別名稱\r\n * @param on 是否開啟狀態\r\n * @param onToggle 切換狀態的事件處理函式\r\n * @param disabled 是否禁用\r\n * @returns JSX 元素\r\n */\r\nexport const FnIconSwitch: FunctionalComponent<FnIconSwitchProps> = ({ class: classes, on = false, onToggle, toggleOnIcon = 'remove', toggleOffIcon = 'add' }) => {\r\n  let onIconRef: HTMLElement | null = null;\r\n  let offIconRef: HTMLElement | null = null;\r\n  let currentOn = on;\r\n\r\n  const toggleIcons = () => {\r\n    currentOn = !currentOn;\r\n\r\n    if (onIconRef && offIconRef) {\r\n      onIconRef.classList.toggle('d-none', !currentOn);\r\n      offIconRef.classList.toggle('d-none', currentOn);\r\n    }\r\n\r\n    onToggle && onToggle(currentOn);\r\n  };\r\n\r\n  const handleClick = (ev: MouseEvent) => {\r\n    ev.stopPropagation();\r\n    toggleIcons();\r\n  };\r\n  return (\r\n    <span\r\n      class={{\r\n        'cursor-pointer': true,\r\n        ...parseClassNames(classes),\r\n      }}\r\n      onClick={handleClick}\r\n    >\r\n      <FnIcon ref={el => (onIconRef = el)} class={{ 'd-none': !on }}>\r\n        {toggleOnIcon}\r\n      </FnIcon>\r\n      <FnIcon ref={el => (offIconRef = el)} class={{ 'd-none': on }}>\r\n        {toggleOffIcon}\r\n      </FnIcon>\r\n    </span>\r\n  );\r\n};\r\n\r\n/**\r\n * 搜尋框元件\r\n *\r\n * @param ref 對應的 HTMLStormInputGroupElement 元素的引用\r\n * @param value 輸入框目前的值\r\n * @param onValueChanged 當值變更時觸發的事件處理函式\r\n * @param placeholder 輸入框預設文字，預設為 '搜尋'\r\n *\r\n * @returns JSX 元素\r\n */\r\nexport const FnSearchInput: FunctionalComponent<FnSearchInputProps> = ({ ref, value, onValueChanged, placeholder }) => {\r\n  const handleValueChanged = debounce((ev: CustomEvent) => {\r\n    if (!onValueChanged) return;\r\n    onValueChanged(ev);\r\n  }, 500);\r\n\r\n  return (\r\n    <div class=\"mb-1\">\r\n      <storm-input-group\r\n        ref={ref}\r\n        placeholder={placeholder ?? '搜尋'}\r\n        input-style=\"outline\"\r\n        prepend-icon=\"search\"\r\n        value={value}\r\n        onValueChanged={(ev: CustomEvent) => {\r\n          ev.stopPropagation();\r\n          handleValueChanged(ev);\r\n        }}\r\n        onChange={(ev: CustomEvent) => {\r\n          if (ev) ev.stopPropagation();\r\n        }}\r\n      ></storm-input-group>\r\n    </div>\r\n  );\r\n};\r\n\r\nexport const FnHr: FunctionalComponent<FnHrProps> = ({ class: classes }) => (\r\n  <hr\r\n    class={{\r\n      dark: true,\r\n      horizontal: true,\r\n      'mx-2': true,\r\n      'my-0': true,\r\n      ...parseClassNames(classes),\r\n    }}\r\n  />\r\n);\r\n\r\nexport const FnTag: FunctionalComponent<FnTagProps> = ({ lable, onClickCancel }) => (\r\n  <span\r\n    class={{\r\n      'storm-tag': true,\r\n      badge: true,\r\n      'bg-primary': true,\r\n      'rounded-pill': true,\r\n      'me-1': true,\r\n      'px-2': true,\r\n      'py-1': true,\r\n    }}\r\n  >\r\n    {lable}\r\n    {onClickCancel != null ? <FnIcon onClick={onClickCancel}>cancel</FnIcon> : undefined}\r\n  </span>\r\n);\r\n"],"names":[],"mappings":"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"}